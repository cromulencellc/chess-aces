/*
filename    random
password    2kpwd
changedby   Papi
EmailAdd    Papi  <seifert@dikumud.com>
request     compile
version     1
END HEADER*/

#include <macros.h>


%zone		        randomt

lifespan 25
reset RESET_ANYHOW

creators {"papi"}

notes
"This zone is an attempt to make random treasure by Papi."


help
"Player should never be in here."


%dil

//
// ======================== UTILITY =========================
//

dilbegin identify(u :unitptr, norm : string, improved: string);
var
    exd : extraptr;
code
{
    if (norm != "")
    {
        exd := "$identify" in u.extra;
        if (exd == null)
        {
            addextra(u.extra, {"$identify"}, "");
            exd := "$identify" in u.extra;
        }

        exd.descr := exd.descr + norm + "<br/>";
    }

    if (improved != "")
    {
        exd := "$improved identify" in u.extra;
        if (exd == null)
        {
            addextra(u.extra, {"$improved identify"}, "");
            exd := "$improved identify" in u.extra;
        }

        exd.descr := exd.descr + improved + "<br/>";
    }

    return;
}
dilend


dilbegin string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
   vowels : string;
   ana : string;
code
{
    vowels := "aeiou";

    if (a1 != "")
    {
        s := replace("$1n", a1, s);

        if (a1.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$1a", ana, s);
    }

    if (a2 != "")
    {
        s := replace("$2n", a2, s);

        if (a2.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$2a", ana, s);
    }

    if (a3 != "")
    {
        s := replace("$3n", a3, s);

        if (a3.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$3a", ana, s);
    }

    if (a4 != "")
    {
        s := replace("$4n", a4, s);

        if (a4.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$4a", ana, s);
    }

    return (s);
}
dilend


dilbegin integer minmax7(i : integer);
code
{
    if (i > 7)
        return (7);

    if (i < -7)
        return (-7);

    return (i);
}
dilend


//
// ======================== ROLLS =========================
//


// il : intlist  [array of integers from 5..94]
//
// This function presume rolls of < 5 are a failure, each -50 is -1 more
// This function presume rolls of > 95 are a open-ended success, each +50 is +1 more
// The integers in the intlist are the number of bonuses, in the range
// 5..94 
//
// Example: {15,75,90}
//  Roll <= -50     = -2
//  Roll [-49..4]   = -1
//  Roll [ 5..15]   =  0
//  Roll [16..75]   = +1
//  Roll [76..90]   = +2
//  Roll [91..141]  = +3
//  Roll [142..192] = +4
//
// The first intlist entry must be > 4
//
dilbegin integer successroll_oe(il : intlist, rollskew : integer);
var
    roll : integer;
    j : integer;
    m : integer;
code
{
    roll := openroll(100, 5) + rollskew;
    
    // Test if failure
    if (roll <= 4)
    {
        if (roll > -50)
            return (-1);
        else
            return ((roll / 50)-1);
    }

    j := 0;
    m := length(il);

    if (m < 1)
    {
        log("Illegal intlist in successroll_oe()");
        quit;
    }

    while (j < m)
    {
        if (roll <= il.[j])
            break;
        j := j + 1;
    }

    if (j < m)
        return (j); // First match = 0, second = +1, etc.

    // Roll is larger than last number in il

    return (m + (roll - il.[m-1])/50);
}
dilend



// returns an index in the list il.
// Will return a number in [0..length(il)]
// E.g. {10,75,90}
//  0 = roll <= 10
//  1 = roll in [11..75]
//  2 = roll in [76..90]
//  3 = roll > 90
//
dilbegin integer successroll(il : intlist, rollskew : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);

var
    i : integer;
code
{
    i := successroll_oe(il, rollskew);

    if (i < 0)
        return (0);

    if (i > length(il))
        return (length(il));

    return (i);
}
dilend



//
// max = length(list);
//
dilbegin integer bonuslistroll(il : intlist, bonuslvl : integer, max : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);

var
    i : integer;
code
{

    i := successroll_oe(il, 0) + bonuslvl;
    if (i < 0)
        return (0);

    if (i >= max)
        return (max-1);

    return (i);
}
dilend


//
// ======================== ENCHANTMENTS =========================
//


dilbegin integer enc_light(u : unitptr, bonuslvl : integer, data : string);
external
    integer successroll(il : intlist, rollskew : integer);
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    if (bonuslvl > 7)
    {
        bonuslvl := 7;
        log("enc_light bonuslvlifier too large ");
    }
    if (bonuslvl < -7)
    {
        bonuslvl := -7;
        log("enc_light bonuslvlifier too small ");
    }

    i := successroll({50, 80, 95}, bonuslvl*5);

    if (i == 0)
        return(1);

    setbright(u, i); // 0..3
    identify(u, "Emits a magical light.", "Emits a magical light +" + itoa(i) +".");

    return (1);
}
dilend


dilbegin integer enc_dark(u : unitptr, bonuslvl : integer, data : string);
external
    integer successroll(il : intlist, rollskew : integer);
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    if (bonuslvl > 7)
    {
        bonuslvl := 7;
        log("enc_dark bonuslvlifier too large ");
    }
    if (bonuslvl < -7)
    {
        bonuslvl := -7;
        log("enc_dark bonuslvlifier too small ");
    }

    i := -successroll({50, 80, 95}, bonuslvl*5);

    if (i == 0)
        return(1);

    setbright(u, i); // 0..-3
    identify(u, "Emits magical darkness.", "Emits magical darkness " + itoa(i) +".");

    return (1);
}
dilend


// Enchant the weapon either dark or light
dilbegin integer enc_lightdark(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_dark(u : unitptr, bonuslvl : integer, data : string);
    integer enc_light(u : unitptr, bonuslvl : integer, data : string);

var
    i : integer;
code
{
    if (rnd(0,1) == 0)
        return (enc_dark(u, bonuslvl, data));
    else
        return (enc_light(u, bonuslvl, data));
}
dilend


//
// call with e.g. (u, BONUS_ARTIFACT, QUOTE(ABIL_STR))
//
dilbegin integer enc_ability(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);

var
    il : intlist;
    abilid : integer;
    i : integer;
    sl : stringlist;
code
{
    // debug log("Enchant ability");
    if (bonuslvl > BONUS_ARTIFACT)
    {
        bonuslvl := BONUS_ARTIFACT;
        log("enc_ability modifier too large ");
    }
    if (bonuslvl < BONUS_JUNK)
    {
        bonuslvl:= BONUS_JUNK;
        log("enc_ability modifier too small ");
    }

    il := {-ID_RAISE_MAG, TIF_MAG_INC, TIF_MAG_DEC, 
           -ID_RAISE_DIV, TIF_DIV_INC, TIF_DIV_DEC, 
           -ID_RAISE_STR, TIF_STR_INC, TIF_STR_DEC, 
           -ID_RAISE_DEX, TIF_DEX_INC, TIF_DEX_DEC, 
           -ID_RAISE_CON, TIF_CON_INC, TIF_CON_DEC, 
           -ID_RAISE_CHA, TIF_CHA_INC, TIF_CHA_DEC, 
           -ID_RAISE_BRA, TIF_BRA_INC, TIF_BRA_DEC, 
           -ID_RAISE_HPP, TIF_HIT_INC, TIF_HIT_DEC    };


    abilid := atoi(data);
    if (abilid < ABIL_MAG)
    {
        log("Illegal ability modifier " + data);
        quit;
    }

    if (abilid >= ABIL_TREE_MAX)
    {
        log("Illegal ability modifier " + data);
        quit;
    }

    // XXX TODO. Determine how much to modify the ability

    i := getinteger(DIL_GINT_BONUS_B, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, il.[abilid*3], -1, 0,
	       abilid, i, 0,
           il.[abilid*3+1], TIF_NONE, il.[abilid*3+2], APF_ABILITY);

    sl := {"magic", "divine", "strength", "dexterity", "constitution", "charisma", "brain", "hitpoints"};
    identify(u, "Improves "+sl.[abilid] +" ability.", "Improves "+sl.[abilid]+" with +"+itoa(i)+".");

    return (1);
}
dilend


// Grants 1-3 abilities on an item
// call with e.g. (u, BONUS_ARTIFACT, "")
//
dilbegin integer enc_abilities(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_ability(u : unitptr, bonuslvl : integer, data : string);

var
    il : intlist;
    numenc : integer;
    numenccopy : integer;
    i : integer;
    r : integer;
code
{
    // debug log("Enchant abilities");

    numenc := 1+rnd(0,1)+rnd(0,1);
    numenccopy := numenc;

    il := { ABIL_MAG, ABIL_DIV, ABIL_STR, ABIL_DEX, ABIL_CON, ABIL_CHA, ABIL_BRA, ABIL_HP };
    i := length(il)-1;

    while (numenc > 0)
    {
        r := rnd(0,i);
        enc_ability(u, bonuslvl, itoa(il.[r]));
        il.[r] := il.[i];
        i := i - 1;
        numenc := numenc - 1;
    }

    return (numenccopy);
}
dilend


// Make up to 4 ticks faster
dilbegin integer enc_haste(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var
    spd : integer;
code
{
    spd := ((SPEED_DEFAULT/3)*bonuslvl)/7;

    if (spd == 0)
        spd := 1;

	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT - spd, 0, 0,
           TIF_SPEED_BETTER, TIF_NONE, TIF_SPEED_WORSE, APF_SPEED);

    identify(u, "Makes you hasted.", "Improved haste with " + itoa((100*spd)/SPEED_DEFAULT) + "%.");

    return (1);
}
dilend


// Make 4 ticks slower
dilbegin integer enc_slow(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var
    spd : integer;
code
{
    spd := ((SPEED_DEFAULT/3)*bonuslvl)/7;

    if (spd == 0)
        spd := 1;

	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT+spd, 0, 0,
           TIF_SPEED_WORSE, TIF_NONE, TIF_SPEED_BETTER, APF_SPEED);

    identify(u, "Makes you slower.", "Slows you " + itoa((100*spd)/SPEED_DEFAULT) + "%.");

    return (1);
}
dilend



// Enchant the weapon either dark or light
dilbegin integer enc_haste_slow(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_haste(u : unitptr, bonuslvl : integer, data : string);
    integer enc_slow(u : unitptr, bonuslvl : integer, data : string);

var
    i : integer;
code
{
    if (rnd(0,1) == 0)
        return (enc_haste(u, bonuslvl, data));
    else
        return (enc_slow(u, bonuslvl, data));
}
dilend




dilbegin integer enc_goodprot(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_PROT_GOOD_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_GOOD_ON, TIF_NONE, TIF_PROT_GOOD_OFF, APF_NONE);

    u.alignment := 1000;

    identify(u, "Makes you protected against good.", "Makes you protected against good.");

    return (1);
}
dilend


dilbegin integer enc_evilprot(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_PROT_EVIL_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_EVIL_ON, TIF_NONE, TIF_PROT_EVIL_OFF, APF_NONE);

    u.alignment := -1000;

    identify(u, "Makes you protected against evil.", "Makes you protected against evil.");

    return (1);
}
dilend


// Enchant the weapon either good or evil
dilbegin integer enc_good_evil(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_goodprot(u : unitptr, bonuslvl : integer, data : string);
    integer enc_evilprot(u : unitptr, bonuslvl : integer, data : string);

var
    i : integer;
code
{
    if (rnd(0,1) == 0)
        return (enc_goodprot(u, bonuslvl, data));
    else
        return (enc_evilprot(u, bonuslvl, data));
}
dilend


// Resistance against spells in any spell category
//SPL_DIVINE             
//SPL_PROTECTION         
//SPL_DETECTION          
//SPL_SUMMONING          
//SPL_CREATION           
//SPL_MIND               
//SPL_HEAT               	/* Fire          */
//SPL_COLD               	/* Frost         */
//SPL_CELL               	/* Electricity   */
//SPL_INTERNAL          	/* Poison        */
//SPL_EXTERNAL          	/* Acid          */

dilbegin integer enc_resist(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var 
    splid : integer;
    sl : stringlist;
    i : integer;
code
{
    splid := atoi(data);

    if (splid < SPL_DIVINE)
    {
        log("OOB LB spell id " + data);
        quit;
    }

    if (splid >= SPL_GROUP_MAX)
    {
        log("OOB UB spell id " + data);
        quit;
    }

    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_SPELL_DEFENSE, -1, 0,
	       splid, i, 0,
           TIF_SPL_INC, TIF_NONE, TIF_SPL_DEC, APF_SPELL_ADJ);

    sl := {"not possible", "divination", "protection", "detection", "summoning", "creation", 
           "mind", "fire", "cold", "electricity", "poison", "acid"};

    identify(u, "Increases your resistance against " + sl.[splid] + ".",
                "Increases your resistance against " + sl.[splid] + " by +" + itoa(i) + ".");

    return (1);
}
dilend



// Grants 1-5 resistances on an item
// call with e.g. (u, BONUS_ARTIFACT, "")
//
dilbegin integer enc_resistances(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_resist(u : unitptr, bonuslvl : integer, data : string);

var
    il : intlist;
    numenc : integer;
    numenccopy : integer;
    i : integer;
    r : integer;
code
{
    // debug log("Enchant resistances");

    numenc := 1+rnd(0,1)+rnd(0,1)+rnd(0,1)+rnd(0,1);
    numenccopy := numenc;

    il := { SPL_DIVINE, SPL_PROTECTION, SPL_DETECTION, SPL_SUMMONING, SPL_CREATION, SPL_MIND,
            SPL_HEAT, SPL_COLD, SPL_CELL, SPL_INTERNAL, SPL_EXTERNAL };
    i := length(il)-1;

    while (numenc > 0)
    {
        r := rnd(0,i);
        enc_resist(u, bonuslvl, itoa(il.[r]));
        il.[r] := il.[i];
        i := i - 1;
        numenc := numenc - 1;
    }

    return (numenccopy);
}
dilend




// Weapon defence
// WPN_AXE_HAM   1		/* Axe/hammer category        */
// WPN_SWORD     2		/* Sword Category             */
// WPN_CLUB_MACE 3		/* Club/Mace/Flail Category   */
// WPN_POLEARM   4		/* Polearm category           */
// WPN_UNARMED   5		/* Natural attacks            */
// WPN_SPECIAL   6		/* Special weapons            */
// WPN_GROUP_MAX 7		/* #[0..6] of groups          */

dilbegin integer enc_defence(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var 
    defid : integer;
    i : integer;
    sl : stringlist;
code
{
    defid := atoi(data);

    if (defid < WPN_AXE_HAM)
    {
        log("OOB LB wpn id " + data);
        quit;
    }

    if (defid >= WPN_GROUP_MAX)
    {
        log("OOB UB wpn id " + data);
        quit;
    }

    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_WEAPON_DEFENSE, -1, 0,
	       defid, i, 0,
           TIF_WPN_INC, TIF_NONE, TIF_WPN_DEC, APF_WEAPON_ADJ);

    sl := {"not possible", "axes and hammers", "bladed weapons", "clubs and maces", "polearms", "natural attacks", "special weapons"};

    identify(u, "Increases your defence against " + sl.[defid] + ".",
                "Increases your defence against " + sl.[defid] + " by +" + itoa(i) + ".");

    return (1);
}
dilend


// Grants 1-2 defences on an item
// call with e.g. (u, BONUS_ARTIFACT, "")
//
dilbegin integer enc_defences(u : unitptr, bonuslvl : integer, data : string);
external
    integer enc_defence(u : unitptr, bonuslvl : integer, data : string);

var
    il : intlist;
    numenc : integer;
    numenccopy : integer;
    i : integer;
    r : integer;
code
{
    // debug log("Enchant defences");

    numenc := 1+rnd(0,1);
    numenccopy := numenc;

    il := { WPN_AXE_HAM, WPN_SWORD, WPN_CLUB_MACE, WPN_POLEARM, WPN_UNARMED, WPN_SPECIAL };
    i := length(il)-1;

    while (numenc > 0)
    {
        r := rnd(0,i);
        enc_defence(u, bonuslvl, itoa(il.[r]));
        il.[r] := il.[i];
        i := i - 1;
        numenc := numenc - 1;
    }

    return (numenccopy);
}
dilend




dilbegin integer enc_wpnslaying(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);

var
    sl : stringlist;
    i : integer;
    exd : extraptr;
code
{
    // debug log("Enchant slaying");

    sl := {
        // Race from, Race to, "$n slayer" name

        QUOTE(RACE_MOSQUITO), "", "mosquito",
        QUOTE(RACE_ARTHROPODA_MIN), QUOTE(RACE_ARTHROPODA_MAX), "arthropoda", // ants beetles, ...
        QUOTE(RACE_ANNELIDA_MIN), QUOTE(RACE_ANNELIDA_MAX), "annelida", // WOrms, leeches
        QUOTE(RACE_CNIDARIA_MIN), QUOTE(RACE_CNIDARIA_MAX), "cnidaria", // Jellyfish
        QUOTE(RACE_MOLLUSK_MIN), QUOTE(RACE_MOLLUSK_MAX), "mollusk", // Oysters, etc
        QUOTE(RACE_RABBIT), "", "rabbit",
        QUOTE(RACE_BOAR), "", "boar",
        QUOTE(RACE_BEAR), "", "bear",
        QUOTE(RACE_GOBLIN), "", "goblin", 
        QUOTE(RACE_HUMAN), "", "human", 
        QUOTE(RACE_DWARF), "", "dwarf", 
        QUOTE(RACE_ELF), "", "elf", 
        QUOTE(RACE_DROW), "", "drow",
        QUOTE(RACE_ORC), "", "orc",
        QUOTE(RACE_HOBGOBLIN), "", "hobgoblin", 
        QUOTE(RACE_JAWLESS_FISH_MIN), QUOTE(RACE_BONEY_FISH_MAX), "fish", 
        QUOTE(RACE_BIRD_MIN), QUOTE(RACE_BIRD_MAX), "bird", 
        QUOTE(RACE_PLANT_MIN), QUOTE(RACE_PLANT_MAX), "plant", 
        QUOTE(RACE_AMPHIBIAN_MIN), QUOTE(RACE_AMPHIBIAN_MAX), "amphibian", 
        QUOTE(RACE_TROLL), "", "troll", 
        QUOTE(RACE_GIANT), "", "giant", 
        QUOTE(RACE_REPTILES_MIN), QUOTE(RACE_REPTILES_MAX), "reptile", 
        QUOTE(RACE_MAMMAL_MIN), QUOTE(RACE_MAMMAL_MAX), "mammal", 
        QUOTE(MIN_HUMANOID_PC), QUOTE(MAX_HUMANOID_NPC), "humanoid", 
        QUOTE(RACE_WEREWOLF), "", "werewolf",
        QUOTE(RACE_GHOST), "", "ghost",
        QUOTE(RACE_VAMPIRE), "", "vampire",
        QUOTE(RACE_ELEMENTAL_MIN), QUOTE(RACE_ELEMENTAL_MAX), "elemental", 
        QUOTE(RACE_LICH_MIN), QUOTE(RACE_LICH_MAX), "lich",
        QUOTE(RACE_UNDEAD_MIN), QUOTE(RACE_UNDEAD_MAX), "undead", 
        QUOTE(RACE_DEMON_MIN), QUOTE(RACE_DEMON_MAX), "demon", 
        QUOTE(RACE_DRAGON_BLACK), "", "black dragon", 
        QUOTE(RACE_DRAGON_BLUE), "", "blue dragon", 
        QUOTE(RACE_DRAGON_GREEN), "", "green dragon", 
        QUOTE(RACE_DRAGON_RED), "", "red dragon", 
        QUOTE(RACE_DRAGON_WHITE), "", "white dragon", 
        QUOTE(RACE_DRAGON_SILVER), "", "silver dragon", 
        QUOTE(RACE_DRAGON_MIN), QUOTE(RACE_DRAGON_MAX), "dragon"
    };

    // 38

    i := rnd(0, (length(sl)/3)-1)*3;

    u.value[3] := atoi(sl.[i]);
    identify(u, "You sense a low hum.", "Slaying against "+sl.[i+2]+"s.");

    if (sl.[i+1] != "") // Check if a range
    {
        addextra(u.extra, {"$slayer"}, sl.[i+2]);
        exd := "$slayer" in u.extra;
        insert(exd.vals, 0, atoi(sl.[i]));
        insert(exd.vals, 1, atoi(sl.[i+1]));
    }

    return (1);
}
dilend


// Confer a magic attack bonus on a weapon
//
dilbegin integer enc_wpnenchant(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
    u.value[2] := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (u.value[2] == 0)
        return(1);

    identify(u, "Confers an enchanted attack bonus.", "Confers an enchanted attack bonus of +" + itoa(u.value[2])+".");
    return (1);
}
dilend


// u : weapon
// The wielder of this weapon will get a magic bonus to his attack skill.
//
dilbegin integer enc_wpnskill(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_WEAPON_DEFENSE, -1, 0,
	       u.value[0], i, 0,
           TIF_WPN_INC, TIF_NONE, TIF_WPN_DEC, APF_WEAPON_ADJ);

    identify(u, "Increases your skill with this weapon.",
                "Increases your skill with this weapon by +" + itoa(i)+".");

    return (1);
}
dilend


//
// ======================== ENCHANT SUPER FUNCTIONS =========================
//

dilbegin integer encWpn(u : unitptr, bonuslvl : integer, blade : string);
var
    enchantments : integer;
    lvl : integer;
    i : integer;
    r : integer;
    n : integer;
    s : string;
    encs : stringlist;
    encn : intlist;

    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;
    exd : extraptr;

code
{
    exd := "" in u.extra;
    rollenc := exd.vals.[4]; // Enchantment roll
    enc1 := exd.vals.[5];    // enchantment material 1
    enc2 := exd.vals.[6];    // enchantment material 2
    enc3 := exd.vals.[7];    // enchantment material 3

    lvl := (rollenc + enc1 + enc2 + enc3) / 4; // Take the average

    // debug log("encWpn() lvl = " + itoa(lvl));

    if (lvl == 0)
        return (0);

    u.flags := u.flags | UNIT_FL_MAGIC;

    // debug log("Enchant the weapon: lvl=" + itoa(lvl) + " u.value2="+itoa(u.value[2]));

    encs := {
        "enc_haste_slow@randomt", "",   // 0
        "enc_wpnslaying@randomt", "",   // 1
        "enc_wpnskill@randomt", "",     // 2
        "enc_good_evil@randomt", "",    // 3
        "enc_abilities@randomt", "",    // 4
        "enc_resistances@randomt", "",  // 5
        "enc_defences@randomt", "",     // 6 
        "enc_lightdark@randomt", "",    // 7 
        "enc_wpnenchant@randomt", ""    // 8 
        };


    encn := { 0, 2, 4, 6, 8, 7, 5, 3, 1 };
    i := length(encn)-1;

    if (i+1 != length(encs)/2)
    {
        log("ERROR: The two arrays must be in sync");
        quit;
    }

    enchantments := lvl;
    while (enchantments > 0)
    {
        // debug log("enchantment "+itoa(enchantments));
        r := (rnd(0,i)+rnd(0,i))/2;
        n := dilcall(encs.[encn.[r]*2])(u, lvl, encs.[encn.[r]*2+1]);

        encn.[r] := encn.[i]; // Well not perfect but it probably works
        i := i - 1;
        enchantments := enchantments - n;
    }

    return (0);
}
dilend



dilbegin integer encJewelry(u : unitptr, bonuslvl : integer, blade : string);
var
    enchantments : integer;
    lvl : integer;
    i : integer;
    r : integer;
    n : integer;
    s : string;
    encs : stringlist;
    encn : intlist;

    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;
    exd : extraptr;

code
{
    exd := "" in u.extra;
    rollenc := exd.vals.[4]; // Enchantment roll
    enc1 := exd.vals.[5];    // enchantment material 1
    enc2 := exd.vals.[6];    // enchantment material 2
    enc3 := exd.vals.[7];    // enchantment material 3

    lvl := (rollenc + enc1 + enc2 + enc3) / 4; // Take the average

    // debug log("encWpn() lvl = " + itoa(lvl));

    if (lvl == 0)
        return (0);

    u.flags := u.flags | UNIT_FL_MAGIC;

    // debug log("Enchant the weapon: lvl=" + itoa(lvl) + " u.value2="+itoa(u.value[2]));

    encs := {
        "enc_haste_slow@randomt", "",   // 0
        "enc_good_evil@randomt", "",    // 1
        "enc_abilities@randomt", "",    // 2
        "enc_resistances@randomt", "",  // 3
        "enc_defences@randomt", "",     // 4 
        "enc_lightdark@randomt", ""     // 5 
        };


    encn := { 0, 2, 4, 5, 3, 1 };
    i := length(encn)-1;

    if (i+1 != length(encs)/2)
    {
        log("ERROR: The two arrays must be in sync");
        quit;
    }

    enchantments := lvl;
    while (enchantments > 0)
    {
        // debug log("enchantment "+itoa(enchantments));
        r := (rnd(0,i)+rnd(0,i))/2;
        n := dilcall(encs.[encn.[r]*2])(u, lvl, encs.[encn.[r]*2+1]);

        encn.[r] := encn.[i]; // Well not perfect but it probably works
        i := i - 1;
        enchantments := enchantments - n;
    }

    return (0);
}
dilend


// ========================= MATERIALS ==========================

// Main metals for metal weapons, e.g. a long sword or mace made of iron
// (handle / hilt is another matter). Matroll [-7..+7]
//
dilbegin string matMetal(matlvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "coroded copper", "coroded copper", "worn copper", "worn copper", "worn copper", "copper", "bronze",
        "iron",
        "silver", "steel", "high steel", "black steel", "true steel", "adamantium", "mithril"};

    return (materials.[matlvl+7]);
}
dilend


// Metals for enchantment, e.g. inlaid runes, enclvl[-7..+7]
//
dilbegin string matMetalEnc(enclvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "", "", "", "", "", "", "",
        "",
        "silver", "silver", "silver", "silver", "red gold", "gold", "platinum"};

    return (materials.[enclvl+7]);
}
dilend


// Metals for the hilt, hiltlvl[-7..+7]
//
dilbegin string matHilt(hiltlvl : integer);
var 
    i : integer;
    materials : stringlist;
code
{
    materials := {
        "wood", "wood", "wood", "wood", "bone", "bone", "bone",
        "iron",
        "silver", "steel", "high steel", "black steel", "true steel", "adamantium", "mithril"};

    return (materials.[hiltlvl+7]);
}
dilend


// Gem for e.g. a hilt [-7..+7]
//
dilbegin string matGem(gemlvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "", "", "", "", "", "", "",
        "",
        "pearl", "black pearl", "moonstone", "emerald", "sapphire", "ruby", "diamond"};

    return (materials.[gemlvl+7]);
}
dilend


// ========================= LYRICS ==========================

// For e.g. a long sword, made of mithril, set the title and name
// and outside description to ...mihtril long sword...
//
dilbegin setMatDescr(u : unitptr, mat : string);
var
    ana : string;
code
{
    if (mat.[0] in "aeiou")
        ana := "an ";
    else
        ana := "a ";

    // Set name, title, description, extra
    addstring(u.names, mat + " " + u.name);
    u.title := ana + mat + " " + u.name;
    u.outside_descr := ana + mat + " " + u.name + " is laying here.";

    return;
}
dilend



// For the weapon u, set an appropriate overall smithing description 
// based on the success of the smithing roll [-7..+7]
//
dilbegin setJewelrySmith(u : unitptr, mat : string, smithlvl : integer);
external
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
    sl : stringlist;
    exd : extraptr;
code
{
    // Get a smithing description based on weapons quality
    sl := {
        "You look at the lump of $2n and wonder if it is even $1a $1n.", // -7
        "This lump of $2n was clearly an unsuccessful attempt at making $1a $1n.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "It's $2a $2n $1n.", // 0
        "A pretty $2n $1n.",  // +1
        "A pretty well made$2n $1n.",
        "A beautiful $2n $1n.",
        "A beautiful well made $2n $1n.",
        "A stunning $2n $1n.",
        "A stunning well made $2n $1n.",
        "Probably the most beautiful $2n $1n you've ever seen." };

    // debug log("Jewelry extra : " + sl.[smithlvl+7]);

    exd := "" in u.extra;
    exd.descr :=  sreplace(sl.[smithlvl+7], u.name, mat, "", "");

    // debug log("exd name = [" + exd.name + "] descr = " + exd.descr);

    return;
}
dilend


dilbegin setJewelryGem(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
external
    string matGem(gemlvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    gem : string;
    t : string;
    r : string;
    exd : extraptr;
code
{
    gem := matGem(mat2);
    if (gem == "")
        return;

    sl := {
        "", // -7
        "",
        "",
        "",
        "",
        "",
        "A tiny broken $2n is set in the $1n.",
        "A tiny $2n is set in the $1n.", // 0
        "A tiny flawless $2n is set in the $1n.",
        "A small $2n is set in the $1n.",
        "A small flawless $2n is set in the $1n.",
        "A medium sized $2n is set in the $1n.",
        "A medium sized flawless $2n is set in the $1n.",
        "A large $2n is set in the $1n.",
        "A large flawless $2n is set in the $1n." // +7
    };

    r := sreplace(sl.[mat3+7], u.name, gem, "", "");

    // debug log("Gem extra: " + r);

    exd := "" in u.extra;
    exd.descr := exd.descr + " " + r;
    // debug log("Gem name = [" + exd.name + "]  descr="+exd.descr);

    return;
}
dilend



// For the weapon u, set an appropriate overall smithing description 
// based on the success of the smithing roll [-7..+7]
//
dilbegin setWpnSmithing(u : unitptr, mat : string, smithlvl : integer);
external
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
    sl : stringlist;
    exd : extraptr;
code
{
    // Get a smithing description based on weapons quality
    sl := {
        "You look at the lump of $2n and wonder if it is even $1a $1n.", // -7
        "This lump of $2n was clearly an unsuccessful attempt at making $1a $1n.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "It's $2a $2n $1n.", // 0
        "A decent $2n $1n.",  // +1
        "A good $2n $1n.",
        "This is a very good $2n $1n.",
        "An excellent $2n $1n.",
        "An excellent and well balanced $2n $1n.",
        "A superior $2n $1n.",
        "Probably the best $2n $1n you've ever seen." };

    // debug log("weapon extra : " + sl.[smithlvl+7]);

    exd := "" in u.extra;
    exd.descr :=  sreplace(sl.[smithlvl+7], u.name, mat, "", "");

    // debug log("exd name = [" + exd.name + "] descr = " + exd.descr);

    return;
}
dilend


// lvl1 - skill of making the blade
// lvl2 - material for inlaid runes / engravings
//
dilbegin setWpnBlade(u : unitptr, lvl1 : integer, lvl2 : integer, kind : string);
external
    string matMetalEnc(enclvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    s : string;
    t : string;
    exd : extraptr;
code
{
    sl := {
        "You wonder if that's really $1a $1n $2n, it is crooked and uneven.", // -7
        "The $2n is crooked and could be a lot better.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "The $2n looks plain.", // 0
        "The $2n is very smooth and well made.",
        "The well made $2n is both very sharp and smooth.",
        "It's strong $2n has $3n runes inlaid.",
        "It's strong well made $2n has $3n runes inlaid.",
        "It's beautiful and strong $2n has $3n runes inlaid.",
        "It's fantastic $1n $2n which is highly decorated and with inlaid $3n runes.",
        "It's probably the most stunning $1n $2n you have ever seen, it is highly decorated and with inlaid $3n runes."  //+7
    };

    s := sl.[lvl1 + 7];
    // debug log("Blade : " + s);

    t := matMetalEnc(lvl2);
    exd := "" in u.extra;
    exd.descr := exd.descr + " " + sreplace(s, u.name, kind, t, "");
    // debug log("setWpnBlade extra : " + exd.descr);

    return;
}
dilend


dilbegin setWpnHilt(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
external
    string matHilt(hiltlvl : integer);
    string matGem(gemlvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    s : string;
    t : string;
    r : string;
    exd : extraptr;
code
{
    // Fix the hilt, $2n = hilt, $3n = hilt material, $4n = gem
    sl := {
        "You wonder if you can even hold onto the oddly shaped $3n $2n.", // -7
        "The $3n $2n looks really terrible.", // -6
        "The $3n $2n looks terrible.", 
        "The $3n $2n looks really bad.", 
        "The $3n $2n looks bad.", 
        "The $2n is made of $3n and it isn't impressive.",
        "A functional $2n made of $3n but could be better.",
        "The $2n is made of $3n.", // 0
        "The $2n is made of $3n and looks like it is well made.",
        "The $2n is made of $3n and looks good.",
        "The $2n is made of $3n and looks really good.",
        "The $2n is made of $3n and looks excellent.",
        "The $2n is made of $3n and looks really excellent.",
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end." // +7
    };

    s := matHilt(mat2);
    t := matGem(mat3);
    r := sreplace(sl.[mat2+7], u.name, kind, s, t);

    // debug log("Hilt decor: " + r);

    exd := "" in u.extra;
    exd.descr := exd.descr + " " + r;
    // debug log("setWpnHilt name = [" + exd.name + "]  descr="+exd.descr);

    return;
}
dilend


// ========================= GENERAL TREASURE ==========================

// Find treasure's materials, adjust cost, adjust weight
// When finished u.extra.vals holds the rolls [-10..10] like this
//   {Craftsmanship, mat1, mat2, mat3, Enchantment, enc1, enc2, enc3}
//
dilbegin treasureroll(u : unitptr, bonuslvl : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);
    integer minmax7(i : integer);

var
    rollmat : integer;
    mat1 : integer;
    mat2 : integer;
    mat3 : integer;
    
    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;

    il : intlist;
code
{
   // debug log("treasureroll");
   if (u.extra == null)
      addextra(u.extra, {""}, "");

   rollmat := (7*(successroll_oe({45,70,90}, 0) + bonuslvl))/10;
   rollmat := minmax7(rollmat);
   mat1 := minmax7(rollmat + rnd(-1,1));
   mat2 := minmax7(rollmat + rnd(-1,1));
   mat3 := minmax7(rollmat + rnd(-1,1));

   rollenc := (7*(successroll_oe({45,70,90}, 0) + bonuslvl))/10;
   rollenc := minmax7(rollenc);
   enc1 := minmax7(rollenc + rnd(-1,1));
   enc2 := minmax7(rollenc + rnd(-1,1));
   enc3 := minmax7(rollenc + rnd(-1,1));

   // Adjust weight, cost, hits

   set_weight_base(u, u.weight - (u.weight * rollmat*5) / 100);  // +7 means 35% less weight, -7 +35% weight

   u.max_hp := 1000;

   if (rollmat > 0)
   {
      u.max_hp := u.max_hp + (rollmat * 1000);
      u.cost   := u.cost * rollmat * 50;  // +7 means x350 cost.
   }

   if (rollmat < 0)
   {
      u.max_hp := u.max_hp + (rollmat * 125);  // Down to 125 hits for -7
      u.cost := u.cost + (u.cost * rollmat * 10) / 100;  // -7 means 70% reduced cost.
   }

   u.hp := u.max_hp;

   if (u.outside.type == UNIT_ST_NPC)
   {
      u.height := u.outside.height;
   }
   else
   {
      // Human, elf, dwarf, halfling, gnome, half-orc, half-ogre, half-elf, brownie, groll, dark elf
      il := {175, 147, 120, 90, 98, 172, 205, 150, 75, 227, 148};
      u.height := il.[rnd(0, length(il))];
   }

   il := {};
   insert(il, 0, rollmat);
   insert(il, 1, mat1);
   insert(il, 2, mat2);
   insert(il, 3, mat3);
   insert(il, 4, rollenc);
   insert(il, 5, enc1);
   insert(il, 6, enc2);
   insert(il, 7, enc3);

   u.extra.vals := il;

   return;
}
dilend



dilbegin treasureize(bonuslvl : integer,
                     matDil : string, matArg : string, 
                     encDil : string, encArg : string);
external
   treasureroll(u : unitptr, bonuslvl : integer);
var
   i : integer;
   exd : extraptr;
code
{
   treasureroll(self, bonuslvl);

   if (matDil != "")
      i := dilcall(matDil)(self, bonuslvl, matArg); 

   if (encDil != "")
      i := dilcall(encDil)(self, bonuslvl, encArg);

   exd := "" in self.extra;
   exd.vals := {};  // remove temporary storage of rolls

   return;
}
dilend


// 'self' must be the item to create and must be from this zone
//
//
dilbegin createItem(itemname : string,
                    item_type : integer, price : integer, size : integer, lbs : integer);
code
{
   if ((self.zoneidx != "randomt") or (self.type != UNIT_ST_OBJ))
   {
      log("error in createItem(). Can only be used on item shells from @randomt");
      quit;
   }

   self.objecttype := item_type;
   self.names.[0] := itemname;

   self.cost := price;
   set_weight_base(self, lbs);

   if (self.outside.type == UNIT_ST_NPC)
      self.height := self.outside.height;
   else
      self.height := size;

    return;
}
dilend



// ========================= ?CATEGORY? ==========================


dilbegin integer matJewelry(u : unitptr, bonuslvl : integer, data : string);
external
   string matMetal(roll : integer);
   setMatDescr(u : unitptr, mat : string);
   setJewelrySmith(u : unitptr, mat : string, smithlvl : integer);
   setJewelryGem(u : unitptr, mat2 : integer, mat3 : integer, kind : string);

var
   rollsmith : integer;
   mat1 : integer;
   mat2 : integer;
   mat3 : integer;
   rollenc : integer;
   enc1 : integer;
   s : string;
   t : string;
   i : integer;
   sl : stringlist;

code
{
   // debug log("matJewelry");

   rollsmith := u.extra.vals.[0];  // Smithing roll
   mat1 := u.extra.vals.[1];  // Primary jewelry material
   mat2 := u.extra.vals.[2];  // Secondary jewelry material
   mat3 := u.extra.vals.[3];  // Tertiary jewelry material
   rollenc := u.extra.vals.[4];  // 
   enc1 := u.extra.vals.[5];  // 

   // Get the main jewelry material
   s := matMetal(mat1);

   setMatDescr(u, s);

   setJewelrySmith(u, s, i);
   setJewelryGem(u, mat2, mat3, "");

   return (0);
}
dilend


dilbegin integer matWpnBlade(u : unitptr, bonuslvl : integer, data : string);
external
   string matMetal(roll : integer);
   identify(u :unitptr, norm : string, improved: string);
   setMatDescr(u : unitptr, mat : string);
   setWpnSmithing(u : unitptr, mat : string, smithlvl : integer);
   setWpnHilt(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
   setWpnBlade(u : unitptr, lvl1 : integer, lvl2 : integer, kind : string);

var
   rollsmith : integer;
   mat1 : integer;
   mat2 : integer;
   mat3 : integer;
   rollenc : integer;
   enc1 : integer;
   s : string;
   t : string;
   i : integer;
   sl : stringlist;

code
{
   // debug log("matWpnBlade");

   rollsmith := u.extra.vals.[0];  // Smithing roll
   mat1 := u.extra.vals.[1];  // Primary blade material
   mat2 := u.extra.vals.[2];  // Primary hilt material
   mat3 := u.extra.vals.[3];  // [Primary hilt gemstone]
   rollenc := u.extra.vals.[4];  // 
   enc1 := u.extra.vals.[5];  // 

   // Get the main bladed weapon material
   s := matMetal(mat1);

   setMatDescr(u, s);
   
   i := (rollsmith + mat1) / 2; // Set average weapon material bonus [-7..+7]
   u.value[1] := getinteger(DIL_GINT_BONUS_A, null, i);
   if (u.value[1] > 0)
      identify(u, "Weapon has a quality bonus.", "Weapon has a quality bonus of +" + itoa(u.value[1]) + ".");
   else if (u.value[1] < 0)
      identify(u, "Weapon has a quality penalty.", "Weapon has a quality penalty of " + itoa(u.value[1]) + ".");

   setWpnSmithing(u, s, i);

   sl := split(data, "//");

   setWpnBlade(u, rollsmith, mat1, sl.[0]);
   setWpnHilt(u, mat2, mat3, sl.[1]);

   return (0);
}
dilend



// ========================= CREATE ITEM TYPE ==========================

dilbegin createWeapon(bonuslvl : integer);
external
    treasureize(bonuslvl : integer,
                  matDil : string, matArg : string, 
                  encDil : string, encArg : string);
    createItem(itemname : string,
                item_type : integer, price : integer, size : integer, lbs : integer);
var
    wpns : stringlist;
    idxWpn : integer;
    s : string;
code
{
    // weapon id, cost cp, weight
    wpns := {
            QUOTE(WPN_GREAT_SWORD),   "200", "16", "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_LONG_SWORD),    "100", "8",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_BROAD_SWORD),   "100", "8",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_CLAYMORE),      "120", "9",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_SCIMITAR),      "100", "7",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_FALCHION),       "90", "9",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_SHORT_SWORD),    "70", "6",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_RAPIER),         "60", "4",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_MAIN_GAUCHE),    "50", "2",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_STILETTO),       "40", "1",  "blade//hilt",  "matWpnBlade@randomt", 
            QUOTE(WPN_DAGGER),         "40", "1",  "blade//hilt",  "matWpnBlade@randomt",
            QUOTE(WPN_BATTLE_AXE),    "160", "16", "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_HAND_AXE),       "60", "6",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_WAR_MATTOCK),    "90", "10", "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_ADZE),           "70", "7",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_WAR_MAUL),       "60", "9",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_WAR_HAMMER),     "55", "7",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_BATTLE_CLUB),    "50", "6",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_CLUB),           "20", "4",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_BATTLE_MACE),    "80", "12", "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_MACE),           "60", "6",  "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_FLAIL),         "140", "16", "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_MORNING_STAR),   "80", "16", "head//handle", "matWpnBlade@randomt",
            QUOTE(WPN_HALBERD),        "80", "10", "head//shaft",  "matWpnBlade@randomt",
            QUOTE(WPN_BARDICHE),       "80", "10", "head//shaft",  "matWpnBlade@randomt",
            // QUOTE(WPN_QUARTERSTAFF),   "50", "10", "tip//shaft",   "matWpnBlade@randomt",
            QUOTE(WPN_SPEAR),          "40", "6",  "head//shaft",  "matWpnBlade@randomt",
            QUOTE(WPN_JAVELIN),        "60", "7",  "head//shaft",  "matWpnBlade@randomt",
            QUOTE(WPN_TRIDENT),        "70", "12", "fork//shaft",  "matWpnBlade@randomt"
            };


    // debug log("Random weapon");
    idxWpn := rnd(0,length(wpns)/5-1) * 5;

    createItem(weapon_name(atoi(wpns.[idxWpn])), ITEM_WEAPON, atoi(wpns.[idxWpn+1]), 180, atoi(wpns.[idxWpn+2]));
    self.manipulate := self.manipulate | MANIPULATE_WIELD;
    self.value[0] := atoi(wpns.[idxWpn]); // Set the weapon type

    treasureize(bonuslvl, wpns.[idxWpn+4], wpns.[idxWpn+3], "encWpn@randomt", wpns.[idxWpn+3]);

    return;
}
dilend


dilbegin createJewelry(bonuslvl : integer);
external
    treasureize(bonuslvl : integer,
                matDil : string, matArg : string, 
                encDil : string, encArg : string);
    createItem(itemname : string,
                item_type : integer, price : integer, size : integer, lbs : integer);
var
    i : integer;
    s : string;
    sl : stringlist;
    wear : integer;
    price : integer;
code
{
    i := rnd(0,5);

    if (i == 0) // Ring
    {
        s := "ring";
        price := 3 * IRON_MULT;
        wear := MANIPULATE_WEAR_FINGER;
    }
    else if (i == 1) // necklace
    {
        price := 4 * IRON_MULT;
        s := "necklace";
        wear := MANIPULATE_WEAR_NECK;
    }
    else if (i == 2)
    {
        price := 20 * IRON_MULT;
        sl := {"crown", "tiara"};
        i := rnd(0,1);
        s := sl.[i];
        wear := MANIPULATE_WEAR_HEAD;
    }
    else if (i == 3)
    {
        price := 4 * IRON_MULT;
        s := "bracelet";
        wear := MANIPULATE_WEAR_WRIST;
    }
    else if (i == 4)
    {
        price := 4 * IRON_MULT;
        s := "anklet";
        wear := MANIPULATE_WEAR_ANKLE;
    }
    else if (i == 5)
    {
        price := 4 * IRON_MULT;
        s := "earring";
        wear := MANIPULATE_WEAR_EAR;
    }

    // debug log("Random Jewelry");
    createItem(s, ITEM_TREASURE, price, 180, 0);
    self.manipulate := self.manipulate | wear;
    
    treasureize(bonuslvl, "matJewelry@randomt", "", "encJewelry@randomt", "");

    return;
}
dilend





// Current approach, roughly:
//   We receive the BONUS_LVL (0-7)
//   First we make rolls for:
//      Craftsmanship                       Enchantmenship
//      Main material (e.g. mithril blade) / Main enchantment (e.g. gold runes)
//      Secondary material (carved ivory)  / secondary enchantment (diamond)
//      Tertiary material                  / tertiary enchantment
//
// All these numbers are saved on the unit in the default extra
//
// Then after that, we generate the descriptions based on description tables.
//

//
// createWeapon() -> to create a frame unit for treasureize
//   treasureize()
//     calls treasureroll() -> to get all material bonuses, set cost, weight. Data in new extra "" created
//     calls param matDil
//         e.g. matWpnBlade() -> customized to set the weapon's blade materials and value[1] bonus
//                               also sets the hilt and hilt gem
//     calls param encDil
//         e.g. encWpn() -> customized to enchant a weapon and set value[2]
//
// ========================= CREATE ITEM TYPE ==========================
//

dilbegin RndTreasure(lvl : integer);
external
    createJewelry(bonuslvl : integer);
    createWeapon(bonuslvl : integer);

code
{
   heartbeat := PULSE_SEC;
   pause;

   if (rnd(0,1) == 1)
      createWeapon(lvl);
   else
      createJewelry(lvl);

   // Wear it if applicable?   
   quit;
}
dilend


%rooms

treasury

title "Test treasury"
descr
"You are in the treasury, its a huge square room with no exits. Apparently
the room is empty - obviously the treasures are beyond the reach of mere
mortals."

flags {UNIT_FL_NO_WEATHER, UNIT_FL_INDOORS, UNIT_FL_NO_TELEPORT, UNIT_FL_NO_MOB}
ALWAYS_LIGHT

// Thoughts in progess, these are not used.
extra {"$iron",
         "copper",
         "bronze",
         "iron",
         "silver",
         "steel",
         "high steel",
         "black steel",
         "true steel",
         "adamantium",
         "mithril"} ""

extra {"$pmetal",
         "copper",
         "bronze",
         "iron",
         "silver",
         "steel",
         "high steel",
         "black steel",
         "true steel",
         "red gold",
         "gold",
         "adamantium",
         "platinum",
         "mithril"} ""

extra {"$wood",
         "pine",
         "oak",
         "black oak",
         "ente wood"} 
         "Woods"


extra {"$hilt",
        "wood",
        "bone",
        "iron",
        "silver",
        "steel",
        "high steel",
        "black steel",
        "true steel",
        "adamantium",
        "mithril"} 
        "Materials that can adorn a hilt"

end


%objects

anklet // A thought experiment
names {"$2n anklet", "anklet"}
title "$2a $2n anklet"
descr "$2a $2n anklet has is lying here."
extra {} ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_AVERAGE);
end


rnd0_avg
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_AVERAGE);
end

rnd1_avgplus
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_AVERAGE_PLUS);
end

rnd2_good
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_GOOD);
end

rnd3_goodplus
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_GOOD_PLUS);
end

rnd4_exel
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_EXCELLENT);
end

rnd5_exelplus
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_EXCELLENT_PLUS);
end

rnd6_superior
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_SUPERIOR);
end

rnd7_artifact
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
dilcopy RndTreasure@randomt(BONUS_ARTIFACT);
end


treasure0
names {"treasure0"}
title "the treasure chest"
descr "treasure0 is here, open it"
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}
CONTAINER_DEF(10)
end

treasure4
names {"treasure4"}
title "the tresure4 chest"
descr "treasure4 is here, open it"
CONTAINER_DEF(10)
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}
end

treasure7
names {"treasure7"}
title "the tresure7 chest"
descr "treasure7 is here, open it"
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}
CONTAINER_DEF(10)
end



%reset

load treasure0 into treasury max 1
{
   load rnd0_avg local 5
   load rnd0_avg local 5
   load rnd0_avg local 5
   load rnd0_avg local 5
   load rnd0_avg local 5
}

load treasure4 into treasury max 1
{
   load rnd4_exel local 5
   load rnd4_exel local 5
   load rnd4_exel local 5
   load rnd4_exel local 5
   load rnd4_exel local 5
}

load treasure7 into treasury max 1
{
   load rnd7_artifact local 5
   load rnd7_artifact local 5
   load rnd7_artifact local 5
   load rnd7_artifact local 5
   load rnd7_artifact local 5
}

%end

// TODO:
// Cost
// Weight
// Hitpoints
//
// --
// Treasure types:
// More weapons: quaterstaff, bows, etc.
// Armors
// Other body wear, such as cloak, quivers, backpacks, belts, hold, etc.
// 
// Maybe even predesigned treasure, e.g. "The holy avenger of San Luis Obispo"

//  Possible enchantment expansions
//    NEW: All, maybe go through affect list and pick more such as bless, etc?
//    NEW: All, has embedded spells that can be used X times / day
//    NEW: All, add magic bonus to a skill
//    NEW: All, add magic bonus to a spell
//    NEW: non-weapon, add magic bonus to a weapon skill (silly to wield an axe and get + to long sword)
//    NEW: Weapon Fireblade, Coldblade, Electricity, (how?)
//    NEW: Weapon Soul saver? When you die your soul is saved.
//    NEW: Weapon Intelligent. Weapon fights for you while you're down.
//

