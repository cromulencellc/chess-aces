/*
filename    rebirth
password    mfxmas
changedby   Etna
EmailAdd
request     compile
version     40
END HEADER*/



/* I am Eirinn of Borg. You will be inseminated. */
/* 12-2000 added rebirth dice  Ratlin/Darg */
/*11/2008 removed death room dilcopy to stop dead
and newbie characters from dying in one round. 
Looking at adding based on greater than level 50 later 
Also added subextra statement for hellhound to remove 
spell from mortals' list ETNA*/
/*09/2008 Fixed assassin recharge bug that when taken to 0
did not allow it to recahrge. Most texts said special 
good for 10 times per morph, counter total set at  2 or 3,
split the difference and made it 5 in both. ETNA*/
/*2010.05.26 GLy removed till can be made so that cannot
bypass no tele or fly to item  being abused by players */

#include <macros.h>

%zone rebirth

title "Cypress Forest@Mainland"

lifespan 20

reset RESET_ANYHOW

creators {"eirinn"}

notes "This zone contains all the dil, objects, and rooms for rebirth."

help "Help is good when you can get it."

#define REBIRTH_DATA "$Rebirth Data"
#define PC_REBIRTHS "$Total Rebirths"
#define F_REBIRTHS "$Fighter Rebirths"
#define T_REBIRTHS "$Thief Rebirths"
#define H_REBIRTHS "$Healer Rebirths"
#define C_REBIRTHS "$Conjurer Rebirths"
#define R_REBIRTHS "$Ranger Rebirths"
#define P_REBIRTHS "$Paladin Rebirths"
#define S_REBIRTHS "$Sorcerer Rebirths"
#define A_REBIRTHS "$Assassin Rebirths"
#define N_REBIRTHS "$Necromancer Rebirths"
#define D_REBIRTHS "$Druid Rebirths"
#define DK_REBIRTHS "$Dark Knight Rebirths"
#define DEMI_SCORE "$Demigod Score"
#define SAC_POINTS "$Sacrifice Points"

/*

 NOT YET:
New Format
NAMES {REBIRTH_DATA,"# of rebirths","0 0","0 0","0 0","0 0","0 0","0 0","0 0",
"0 0","0 0","0 0","0","0"}

Old format:
Names {"$Rebirth Data","0"}
"BLANKETY BLANK"

       0            1                          2             3
Names {REBIRTH_DATA,"Number of time rebirthed","Fighter 0 0","Thief 0 0",
4            5              6             7              8
"Healer 0 0","Conjurer 0 0","Paladin 0 0","Sorcerer 0 0","Assassin 0 0",
9                 10              11          12       13
"Necromancer 0 0","Ranger 0 0","Druid 0 0","Demi 0", "God 0"}

GUILD_UDG_FIGHTER "Udgaard Fighter"
GUILD_UDG_THIEF   "Udgaard Thief"
GUILD_UDG_CLERIC  "Udgaard Healer"
GUILD_UDG_MAGE    "Udgaard Conjurer"
GUILD_PALADIN     "Midgaard Paladin"
GUILD_SORCERER    "Midgaard Sorcerer"
GUILD_ASSASSIN    "Khorsabad Assassin"
GUILD_NECROMANCER "Necromancer"
GUILD_NYM_RANGER  "Nymgaard Ranger"
GUILD_NYM_DRUID  "Nymgaard Druid"

*/


/* +++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++  D I L C O D E   S E C T I O N  +++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++ */
%dil

dilbegin aware recall no_wear();

code
{
:start:
   wait(SFB_CMD, ((command("wear") or command("wield"))
              and (activator == self)));
   block;
   act("Your equipment doesn't seem to fit you very well at the moment!",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;
}
dilend /* no_wear */

dilbegin aware busy_command(the_cmd : string);

code
{
:start:
   wait(SFB_CMD, (command(the_cmd) and (activator == self) ));
   block;
   act("You need a few seconds to recover before you " +
       "can do that again!",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;
}
dilend /* busy_command */

dilbegin aware recall basil_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("petrify") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used up all your power to petrify for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(petrify)", self);

   if ("self" in argument)
   {
      act("You can't do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't petrify that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n's eyes flare bright red!",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("Your eyes flare as you attempt to petrify $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n's eyes flare bright red at $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   i := cast_spell (SPL_PETRIFY, self, self, self.fighting, "");
   total := total - 1;
}
dilend /* basil_special */


dilbegin aware basilisk_combat();

code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*10;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You lash $3n with your lethal spiked tail!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n lashes you with $1s lethal spiked tail!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n lashes $3n with $1s lethal spiked tail!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   self.fighting.hp := self.fighting.hp -
   (self.abilities[ABIL_CON]/10 + rnd(10,20));

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* basilisk_combat */


dilbegin recall aware morph_basilisk();

var
   expd        : extraptr;

   pc_name     : string; /* My name */
   t_string    : string;

   i           : integer;

   a           : integer;
   b           : integer;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, growing scales and lethal spikes as $1e becomes "+
       "a fearsome basilisk!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Basilisk");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "Basilisk");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null, "Covered with greenish brown scales and "+
                              "spikes and easily weighing a ton, this "+
                              "tremendous lizard can turn living flesh "+
                              "into stone by sheer will alone!");

   self.title := "- Lord of Stone"; /* And the title */

   self.race := RACE_DINOSAUR;

   /* Now change appropriate abilities and attack, then add special */

   position_update(self);

   self.height := self.height + 300;
/*   setweight(self, self.weight + 600);  */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("basilisk_combat@rebirth", self);
   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_PETRIFY]));
   self.spells[SPL_PETRIFY] := 40;
   dilcopy("basil_special@rebirth", self);

   act("You morph into a Basilisk!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically lash at your victims " +
       "with your immense tail, but you can also PETRIFY creatures "+
       "and things (up to 5 times per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;

   substring(self.names, pc_name + " the Basilisk");
   substring(self.names, "Basilisk");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_PETRIFY] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");

   self.height := self.height - 300;
/*   setweight(self, self.weight - 600); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("basil_special@rebirth", self);
   i := dildestroy ("basilisk_combat@rebirth", self);
   i := dildestroy ("busy_command@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Basilisk suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);

   position_update(self);
   quit;
}
dilend /* morph_basilisk */


dilbegin aware recall giant_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("pound") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your pounding power for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(pound)", self);

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC | UNIT_ST_OBJ)))
   {
      act("You can't pound that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (targ.type == UNIT_ST_OBJ)
   {
      i := self.abilities[ABIL_STR] - (targ.value[1] + targ.value[2]);

      if (dilfind("bob_code@basis", targ))
      {
         act("The gods prevent you from doing that!",
             A_ALWAYS, self, null, null, TO_CHAR);
         goto start;
      }
      if ((targ.hp - i) <= 0)
      {
         act("$1n POUNDS the " + targ.name + " and destroys it!",
             A_SOMEONE, self, null, null, TO_REST);
         act("You POUND the " + targ.name + " and destroy it!",
             A_ALWAYS, self, null, null, TO_CHAR);
         targ.hp := targ.hp - i;
         total := total - 1;
         position_update(targ);
         goto start;
      }
      else
      {
         act("$1n POUNDS the " + targ.name + ", badly damaging it!",
             A_SOMEONE, self, null, null, TO_REST);
         act("You POUND the " + targ.name + ", badly damaging it!",
             A_ALWAYS, self, null, null, TO_CHAR);
         targ.hp := targ.hp - i;
         total := total - 1;
         position_update(targ);
         goto start;
      }
   }
   act("$1n POUNDS $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);
   act("You POUND $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n POUNDS you!",
       A_SOMEONE, self, null, targ, TO_VICT);
   sendto("pounding", self);
   i := cast_spell (SPL_CLENCHED_FIST, self, self, targ, "");
   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* giant_special */

dilbegin aware recall phoenix_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("heal") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your healing power for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(heal)", self);

   if ("self" in argument)
   {
      targ := self;
      goto begin;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC)))
   {
      act("You can't heal that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n calls forth the healing power of the gods!",
       A_SOMEONE, self, null, null, TO_REST);
   act("You call forth the healing power of the gods!",
       A_ALWAYS, self, null, null, TO_CHAR);

   i := cast_spell (SPL_CURE_WOUNDS_3, self, self, targ, "");

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* phoenix_special */

dilbegin aware recall viper_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("constrict") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used up all your power to constrict for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(constrict)", self);

   if ("self" in argument)
   {
      act("You can't do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't constrict that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n attemps to constrict you!",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("You attempt to constrict $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n attempts to constrict $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   self.attack_type := WPN_CRUSH;

   sendto("constricting", self);

   i := 0;
   i := meleeattack (self, targ, i, 0);

   self.attack_type := WPN_BITE;

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* viper_special */

dilbegin aware recall demon_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("sleep") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your power to make others sleep for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(sleep)", self);

   if ("self" in argument)
   {
      if (self.sex == SEX_MALE)
      {
         act("Grow up, dude.",
             A_ALWAYS, self, null, null, TO_CHAR);
      }
      else
         act("Grow up, dudette.",
             A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't sleep that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n stares into your eyes. You feel like you are falling " +
       "into those deep pools of darkness...",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("You stare into $3n's eyes...",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n stares into $3n's eyes...",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   i := cast_spell (SPL_SLEEP, self, self, targ, "");

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* demon_special */

/*dilbegin aware recall dragon_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

   thing : string;

code
{
   total := 5;
   heartbeat := PULSE_SEC*2;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("fly") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   thing := argument;

   if (total <= 0)
   {
      act("You have used all your power to fly for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(fly)", self);

   if ("self" in argument)
   {
      if (self.sex == SEX_MALE)
      {
         act("Grow up, dude.",
             A_ALWAYS, self, null, null, TO_CHAR);
      }
      else
         act("Grow up, dudette.",
             A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if ((self.outside.nameidx == "nightmare") or
       (self.outside.zoneidx == "basis"))
   {
      act("You cannot do that here.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_GLOBAL, null);

   if (targ == null)
   {
      act("You don't sense that anywhere in the world! Remember that " +
          "it must be a person or monster!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You can't sense that anywhere in the world!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }
   // added to block non pay by darg
  if (self.type==UNIT_ST_PC)
   if (not(paycheck( self,targ)))
   {
      act("You do not have access to that location, type 'help donation'.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (targ.type == UNIT_ST_ROOM)
   {
      act("You must name a being which you wish to " +
          "fly to.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (isset(targ.outside.flags, UNIT_FL_NO_TELEPORT))
   {
      act("Your destination is hidden from you. Choose another.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act ("Your dragon wings spread out in an awe inspiring splendor.",
        A_ALWAYS, self, null, null, TO_CHAR);
   act ("$1n's wings spread out in an awe inspiring splendor.",
        A_HIDEINV, self, null, null, TO_REST);
   pause;
   act ("Your wings start to flap and build to a tremendous speed.",
        A_ALWAYS, self, null, null, TO_CHAR);
   act ("The wings start to flap and build to a tremendous "+
        "speed, causing a great gust of wind that almost knocks you "+
        "off your feet.",
        A_HIDEINV, self, null, null, TO_REST);
   pause;
   act ("The wings carry you off to your destination and you "+
        "land gently.",
        A_ALWAYS, self, null, null, TO_CHAR);
   act ("The wings slowly lift $1n off the ground and carry $1m "+
        "off into the distance.",
        A_HIDEINV, self, null, null, TO_REST);

   targ := findunit(self, thing, FIND_UNIT_GLOBAL, null);

   link (self, targ);

:link_again:
   if (self.outside.type != UNIT_ST_ROOM)
      link(self, self.outside.outside);

   if (self.outside.type != UNIT_ST_ROOM)
      goto link_again;

   exec ("look", self);

   act ("$1n flies in on the wing." ,
        A_HIDEINV, self, null, null, TO_REST);

   total := total - 1;

   pause;

   goto start;
}
dilend  dragon_special */

dilbegin aware recall lion_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("roar") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your power to roar for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(roar)", self);

   if ("self" in argument)
   {
      if (self.sex == SEX_MALE)
      {
         act("Grow up, dude.",
             A_ALWAYS, self, null, null, TO_CHAR);
      }
      else
         act("Grow up, dudette.",
             A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("What good will roaring at that do?!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n ROARS at you!",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("You ROAR at $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n ROARS at $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   i := cast_spell (SPL_STUN, self, self, targ, "");

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* lion_special */

dilbegin aware recall panther_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

   dir          : integer;
   dest         : unitptr;
   here         : unitptr;
   isthere      : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("run") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your power to run for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(run)", self);

/* Manum code */

      dir := -1; /* For contiguousness (bla mouthful) */

:get_dir:  /* We're checking for the existance of an exit here, if there isn't
one, we bomb                     out, if there is one, we go to the random
direction generator */

dir:= dir + 1;   /* Start at north and increment (tries all dirs) */

isthere:= self.outside.exit_info[dir];
here:= self.outside;
dest:= self.outside.exit_to[dir];

if (dir > 5) goto no_exit;

if ((isset (isthere, EX_CLOSED)) or (isset (isthere, EX_LOCKED))) goto
get_dir;

if ((dest == null) or (dest.movement == SECT_WATER_SWIM) or (dest.movement ==
SECT_WATER_SAIL) or (dest.movement == SECT_UNDER_WATER)) goto get_dir;

if (("clans" in dest.zoneidx) or ("clan_bus" in dest.zoneidx) or ("clan_dra" in dest.zoneidx)
or ("clan_uch" in dest.zoneidx) or ("clan_aoh" in dest.zoneidx) or ("clan_kin" in dest.zoneidx))   goto get_dir; 


:rnd_dir:

dir:= rnd(0,5); /* Random - a bit tedious but any other way is way more
complicated */

isthere:= self.outside.exit_info[dir];
here:= self.outside;
dest:= self.outside.exit_to[dir];

if ((isset (isthere, EX_CLOSED)) or (isset (isthere, EX_LOCKED))) goto
rnd_dir;

if ((dest == null) or (dest.movement == SECT_WATER_SWIM) or (dest.movement ==
SECT_WATER_SAIL) or (dest.movement == SECT_UNDER_WATER)) goto rnd_dir;

/* if ("clans" in dest.zoneidx) goto rnd_dir; was this i changed tofix cklan entry*/

if (("clans" in dest.zoneidx) or ("clan_bus" in dest.zoneidx) or ("clan_dra" in dest.zoneidx)
or ("clan_uch" in dest.zoneidx) or ("clan_aoh" in dest.zoneidx) or ("clan_kin" in dest.zoneidx))   goto rnd_dir; 


 if ("clans" in dest.zoneidx) goto failedit;

   act("You run like the wind!",
       A_ALWAYS,self,null,null,TO_CHAR);
   act("$1n runs like the wind!",
       A_SOMEONE,self,null,null,TO_REST);

   link(self,dest);
   self.position:=POSITION_STANDING;
   position_update(self);

   act("$1n runs into the room!",
       A_SOMEONE,self,null,null,TO_REST);

   goto end;

:no_exit:
   act("You can't get away - there is nowhere to run to!",
       A_ALWAYS,self,null,null,TO_CHAR);
   act("$1n attempts to run, but there's nowhere to run to!",
       A_HIDEINV,self,null,null,TO_REST);
   goto end;

:failedit:

   act("You can't use this command in he area of a clant!",
       A_ALWAYS,self,null,null,TO_CHAR);
   act("$1n attempts to run, but finds there's nowhere to hide!",
       A_HIDEINV,self,null,null,TO_REST);
   goto end;


/* End Manum code */

:end:

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* panther_special */

dilbegin aware recall vampire_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("transfix") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your power to transfix others for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(transfix)", self);

   if ("self" in argument)
   {
      if (self.sex == SEX_MALE)
      {
         act("Grow up, dude.",
             A_ALWAYS, self, null, null, TO_CHAR);
      }
      else
         act("Grow up, dudette.",
             A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't transfix that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n holds your soul in $1s hands...",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("You stare into $3n's eyes...",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n stares into $3n's eyes, trying to transfix $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   if (rnd(1, 100) > 40)
   {
      change_speed(targ, 3*PULSE_VIOLENCE);
      act("You are transfixed!",
          A_ALWAYS, targ, null, null, TO_CHAR);
      act("You have transfixed $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
   }
   else
   {
      act("$1n fails to transfix you!",
          A_ALWAYS, self, null, targ, TO_VICT);
      act("You have failed to transfix $3n!",
          A_ALWAYS, self, null, targ, TO_CHAR);
   }

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* vampire_special */

dilbegin aware recall ice_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("call") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used all your power to call lightning for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(call)", self);

   if ("self" in argument)
   {
      if (self.sex == SEX_MALE)
      {
         act("Grow up, dude.",
             A_ALWAYS, self, null, null, TO_CHAR);
      }
      else
         act("Grow up, dudette.",
             A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("Lightning wouldn't do much good on that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n closes its eyes and a storm cloud quickly forms above you!",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("You close your eyes and a storm cloud quickly forms above " +
       "$3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n closes its eyes and a storm cloud quickly forms above " +
       "$3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   i := cast_spell (SPL_LIGHTNING_3, self, self, targ, "");

   total := total - 1;

   heartbeat := PULSE_SEC*3;

   pause;

   goto start;
}
dilend /* ice_special */

dilbegin aware recall giant_combat(); /* Giant attack */

var
   attack_power  : integer;
   defense_power : integer;

code
{
:init:
   attack_power := self.abilities[ABIL_STR] + self.abilities[ABIL_DEX]/10;
   interrupt(SFB_MSG, (activator == self) and ("pounding" in argument),
             am_pounding);
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;
   wait(SFB_PRE, ((CMD_AUTO_DAMAGE) and
                  (activator == self) and (power > 0) and (target != self)));

   defense_power := target.abilities[ABIL_STR] + target.abilities[ABIL_DEX];
   power := power + rnd(15,30) + attack_power - (defense_power / 2);
   act("You SQUASH $3n! You hear some bones break!",
       A_ALWAYS, self, null, target, TO_CHAR);
   act("$1n SQUASHES you! You feel some bones break!",
       A_SOMEONE, self, null, target, TO_VICT);
   act("$1n SQUASHES $3n! You hear some bones break!",
       A_SOMEONE, self, null, target, TO_NOTVICT);
   exec("scream", target);
   pause;
   goto start;

:am_pounding:
   heartbeat:=PULSE_SEC*2;
   pause;
   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* giant_combat */

dilbegin aware phoenix_combat(); /* Phoenix attack */

var
   i    : integer;

code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You summon a Divine Firestorm upon $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n summons a Divine Firestorm upon you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n summons a Divine Firestorm upon $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   i := cast_spell (SPL_CAUSE_WOUNDS_3, self, self, self.fighting, "");

/*   heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* phoenix_combat */

dilbegin aware viper_combat(); /* Viper attack */

var
   i    : integer;

code
{
   interrupt(SFB_MSG, (activator == self) and ("constricting" in argument),
             constricting);
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You bite $3n, trying to poison $3m!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n bites you, trying to poison you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n bites $3n, trying to poison $3m!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   i := cast_spell (SPL_POISON, self, self, self.fighting, "");

/*   heartbeat := PULSE_VIOLENCE; */

   pause;
   goto start;

:constricting:
   heartbeat:=PULSE_SEC*2;
   pause;
   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* viper_combat */

dilbegin aware demon_combat(); /* Shadow Demon attack */

var
   i    : integer;

code
{
   interrupt(SFB_MSG, (activator == self) and ("sleep" in argument),
             sleeping);
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You spit acid at $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n spits acid on you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n spits acid on $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);

   i := cast_spell (SPL_ACIDBALL_2, self, self, self.fighting, "");

   pause;
   goto start;

:sleeping:
   heartbeat:=PULSE_SEC*2;
   pause;
   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* demon_combat */

dilbegin aware dragon_combat();

var
   i    : integer;

code
{
   interrupt(SFB_MSG, (activator == self) and ("fly" in argument),
             flying);
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You breath fire at $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n breaths fire on you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n breaths fire on $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);

   i := cast_spell (SPL_FIRE_BREATH, self, self, self.fighting, "");

   pause;
   goto start;

:flying:
   heartbeat:=PULSE_SEC*2;
   pause;
   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;
}
dilend /* dragon_combat */

dilbegin aware lion_combat();

var
  i : integer;

code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You MAUL $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n MAULS you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n MAULS $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   i := (self.abilities[ABIL_DEX]/15) + rnd(5,10);
   i := meleeattack (self, self.fighting, i, 0);
/*   self.fighting.hp := self.fighting.hp - (self.abilities[ABIL_DEX]
                                           + rnd(10,50));
*/
/* heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* lion_combat */

dilbegin aware panther_combat();

var
   i  : integer;
code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You RIP $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n RIPS you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n RIPS $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
/*   self.fighting.hp := self.fighting.hp - (self.abilities[ABIL_DEX]
                       + rnd(10,50));
*/

   i := (self.abilities[ABIL_DEX]/15) + rnd(5,10);
   i := meleeattack (self, self.fighting, i, 0);

/*   heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* panther_combat */
/* hound special */
dilbegin aware recall hound_special();

var
   targ : unitptr;

   i    : integer;
   total : integer;

code
{
   total := 5;

:start:
   i := dildestroy("busy_command@rebirth", self);
   wait(SFB_CMD, (command("breath") and (activator == self) and
                  (self.position >= POSITION_RESTING)));
   block;

   if (total <= 0)
   {
      act("You have used up all your power to breath for this " +
          "morph period!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (self.position <= POSITION_SITTING)
   {
      act("You must be standing up to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   dilcopy("busy_command@rebirth(breath)", self);

   if ("self" in argument)
   {
      act("You can't do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   targ := findunit(self, argument, FIND_UNIT_SURRO, null);

   if (targ == null)
   {
      act("You don't see that here!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(visible(self, targ)))
   {
      act("You don't see that here!!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

   if (not(targ.type & (UNIT_ST_PC | UNIT_ST_NPC)))
   {
      act("You can't breath that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start;
   }

:begin:

   act("$1n's eyes flare bright red!",
       A_SOMEONE, self, null, targ, TO_VICT);
   act("Your eyes flare as you attempt to fire breath $3n!",
       A_ALWAYS, self, null, targ, TO_CHAR);
   act("$1n's eyes flare bright red at $3n!",
       A_SOMEONE, self, null, targ, TO_NOTVICT);

   i := cast_spell (SPL_FIRE_BREATH, self, self, self.fighting, "");
   total := total - 1;
}
dilend /* basil_special */


dilbegin aware hound_combat();

var
   i  : integer;
code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You sink your fangs into $3n and shake $3m violently!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n sinks $1s fangs into you and shakes you violently!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n sinks $1s fangs into $3n and shakes $3m violently!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
/*   self.fighting.hp := self.fighting.hp - (self.abilities[ABIL_DEX]
                       + rnd(10,50));
*/

   i := (self.abilities[ABIL_DEX]/15) + rnd(5,10);
   i := meleeattack (self, self.fighting, i, 0);

/*   heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* hound_combat */


dilbegin aware vampire_combat();

var
   i    : integer;

   t_int : integer;

code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You attempt to bite $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n tries to bite you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n tries to bite $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);

   if (rnd(1,100) > 30)
   {
      act("You sink your teeth into $3n's neck and drain $3s blood!",
          A_ALWAYS, self, null, self.fighting, TO_CHAR);
      act("$1n sinks $1s teeth into your neck and drains your blood!",
          A_SOMEONE, self, null, self.fighting, TO_VICT);
      act("$1n sinks $1s teeth into $3n's neck and drains $3s blood!",
          A_SOMEONE, self, null, self.fighting, TO_NOTVICT);

      t_int := rnd(10, 50);

      self.fighting.hp := self.fighting.hp - t_int;
      self.hp := self.hp + t_int;
      if (self.hp > self.max_hp)
         self.hp := self.max_hp;
      act("You feel weaker from bloodloss!",
          A_ALWAYS, self.fighting, null, null, TO_CHAR);
      act("You feel stronger after draining $3n!",
          A_ALWAYS, self, null, self.fighting, TO_CHAR);
   }
   else
   {
      act("You fail to find $3n's neck with your bite!",
          A_ALWAYS, self, null, self.fighting, TO_CHAR);
      act("$1n fails to find your neck with $1s bite!",
          A_SOMEONE, self, null, self.fighting, TO_VICT);
      act("$1n fails to find $3n's neck with $1s bite!",
          A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   }

/*   heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* vampire_combat */

dilbegin aware ice_combat();

var
   i    : integer;

code
{
   interrupt(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                      (target == self)), morphcorpse);

:start:
   heartbeat := PULSE_SEC*1;

   wait(SFB_COM, ((CMD_AUTO_COMBAT) and (activator == self) ));

   if (self.fighting == null) goto start;
   act("You summon an Elemental Storm of Ice upon $3n!",
       A_ALWAYS, self, null, self.fighting, TO_CHAR);
   act("$1n summons an Elemental Storm of Ice upon you!",
       A_SOMEONE, self, null, self.fighting, TO_VICT);
   act("$1n summons an Elemental Storm of Ice upon $3n!",
       A_SOMEONE, self, null, self.fighting, TO_NOTVICT);
   i := cast_spell (SPL_FROSTBALL_3, self, self, self.fighting, "");

/*   heartbeat := PULSE_VIOLENCE; */

   pause;

   goto start;

:morphcorpse:

   if((self.hp - power) < 10) sendto("unmorph", self); /* Switch off */
   goto start;

}
dilend /* ice_combat */

dilbegin aware morph_commands(); /* This is a special dil for morphees */

var
   align_string : string;
   race_string  : string;
   sex_string   : string;
   wimpy_string : string;

code
{
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

:start:
   wait(SFB_CMD, (activator == self));
   if (command("quit")) goto is_quit;
/*
   else if (command("status")) goto is_status;
*/
   else if (command("practice")) goto is_prac;
   else if (command("rebirth")) goto is_rebirth;
   else goto start;

:is_rebirth:
   block;
   act("You cannot do that while you are morphed!",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;

:is_quit:
   block;
   act("You cannot quit while you are morphed!",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;

:is_prac:
   block;
   act("You cannot do that while you are morphed!",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;
/*
:is_status:
   if (argument != "") goto start;
   block;
   if (self.alignment < -349) align_string := "Evil";
   else if (self.alignment > 349) align_string := "Good";
   else align_string := "Neutral";

   if (self.sex == SEX_MALE) sex_string := "male";
   else if (self.sex == SEX_FEMALE) sex_string := "female";
   else sex_string := "neuter";

   if (self.race == RACE_GIANT) race_string := "giant";
   else if (self.race == RACE_BIRD) race_string := "phoenix";
   else if (self.race == RACE_SNAKE) race_string := "viper";
   else if (self.race == RACE_DOG) race_string := "Hell Hound";
   else if (self.race == RACE_VAMPIRE) race_string := "vampire";
   else if (self.race == RACE_DRAGON_RED) race_string := "red dragon";
   else if (self.race == RACE_ELEMENTAL_FROST) race_string := "ice elemental";
   else if (self.race == RACE_LION) race_string := "lion";
   else if (self.race == RACE_SHADOW_DEVIL) race_string := "shadow demon";
   else if (self.race == RACE_CAT) race_string := "black panther";
   else if (self.race == RACE_DINOSAUR) race_string := "basilisk";

   if (isset(self.charflags, CHAR_WIMPY)) wimpy_string := "wimpy";
   else wimpy_string := "brave";

   act(self.name + " " + self.title + " (" + align_string +
       " alignment (" + itoa(self.alignment) + ")\n" +
       "You are a " + itoa(self.exp) + " year old " + sex_string +
       " " + race_string + " at level " + itoa(self.level + 100) +
       ".\n" +
       "Str " + itoa(self.abilities[ABIL_STR]) + ", " +
       "Dex " + itoa(self.abilities[ABIL_DEX]) + ", " +
       "Con " + itoa(self.abilities[ABIL_CON]) + ", " +
       "Cha " + itoa(self.abilities[ABIL_CHA]) + ", " +
       "Bra " + itoa(self.abilities[ABIL_BRA]) + ", " +
       "Mag " + itoa(self.abilities[ABIL_MAG]) + ", " +
       "Div " + itoa(self.abilities[ABIL_DIV]) +
       "\n" +
       "You are in " + wimpy_string + " mode.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;
*/

:end: /* That's all folks */
   quit;
}
dilend /* morph_commands */

dilbegin recall aware morph_giant(); /* Actually set up Morph */

var
   expd        : extraptr;

   pc_name     : string; /* My name */
   t_string    : string;

   i           : integer;

   a           : integer;
   b           : integer;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, growing into a large Giant before your " +
       "very eyes!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Giant");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "Giant");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null, "Over ten metres tall, this giant could quite
" +
                              "easily pulverize you with its bare hands!");

   if (self.race == RACE_HUMAN)
      t_string := "Human";
   else if (self.race == RACE_ELF)
      t_string := "Elf";
   else if (self.race == RACE_DWARF)
      t_string := "Dwarf";
   else if (self.race == RACE_HALFLING)
      t_string := "Halfling";
   else if (self.race == RACE_GNOME)
      t_string := "Gnome";
   else if (self.race == RACE_HALF_ORC)
      t_string := "Half-Orc";
   else if (self.race == RACE_HALF_OGRE)
      t_string := "Half-Ogre";
   else if (self.race == RACE_HALF_ELF)
      t_string := "Half-Elf";
   else if (self.race == RACE_BROWNIE)
      t_string := "Brownie";
   else if (self.race == RACE_GROLL)
      t_string := "Groll";
   else if (self.race == RACE_DARK_ELF)
      t_string := "Darkelf";

   self.title := t_string; /* And the title */

   self.race := RACE_GIANT;

   /* Now change appropriate abilities and attack, then add special */

   position_update(self);
   self.height := self.height + 1000;
/*   setweight(self, self.weight + 1200);  */

   self.attack_type := WPN_CRUSH;
   self.weapons[WPN_CRUSH] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("giant_combat@rebirth", self);
   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_CLENCHED_FIST]));
   self.spells[SPL_CLENCHED_FIST] := 100;
   dilcopy("giant_special@rebirth", self);

   act("You morph into a Giant!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically squash your victims, " +
       "but you can also POUND creatures and things (up to 5 times " +
       "per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;

:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;

   substring(self.names, pc_name + " the Giant");
   substring(self.names, "Giant");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_CLENCHED_FIST] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");

   position_update(self);

   self.height := self.height - 1000;
/*   setweight(self, self.weight - 1200); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CRUSH] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("giant_special@rebirth", self);
   i := dildestroy ("giant_combat@rebirth", self);
   i := dildestroy ("busy_command@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Giant suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);

   quit;
}
dilend /* morph_giant */

dilbegin recall aware morph_phoenix(); /* Healer */

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape and form, with feathers of fire growing from " +
       "$1s skin, and morphs into the Phoenix!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Phoenix");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "phoenix");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null, "A great bird of fire, the phoenix has " +
                              "powers of healing and fire which make it " +
                              "almost immortal! Its feathers are actually "+
                              "on fire and there is little doubt that it " +
                              "is a force to be reckoned with in combat!");

   self.title := "- Immortal Bird of Legend"; /* And the title */

   self.race := RACE_BIRD;

   /* Now change appropriate abilities and attack, then add special */

   self.height := self.height + 100;
/*   setweight(self, self.weight + 200); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_LEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   addextra(self.extra, {"$My_Spell_1"},
            itoa(self.spells[SPL_CURE_WOUNDS_3]));
   addextra(self.extra, {"$My_Spell_2"},
            itoa(self.spells[SPL_CAUSE_WOUNDS_3]));

   self.spells[SPL_CURE_WOUNDS_3] := 100;
   self.spells[SPL_CAUSE_WOUNDS_3] := 100;

   dilcopy("phoenix_special@rebirth", self);
   dilcopy("phoenix_combat@rebirth", self);

   act("You morph into the Phoenix!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically firestorm your victims, " +
       "but you can also HEAL creatures and yourself (up to 5 times " +
       "per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Phoenix");
   substring(self.names, "phoenix");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell_1" in self.extra;
   self.spells[SPL_CURE_WOUNDS_3] := atoi(expd.descr);

   expd := "$My_Spell_2" in self.extra;
   self.spells[SPL_CAUSE_WOUNDS_3] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell_1");
   subextra(self.extra, "$My_Spell_2");

   self.height := self.height - 100;
/*   setweight(self, self.weight - 200); */

   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("phoenix_special@rebirth", self);
   i := dildestroy ("phoenix_combat@rebirth", self);

   self.attack_type := WPN_FIST;

   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Phoenix suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/

   quit;
}
dilend /* morph_phoenix */

dilbegin recall aware morph_viper();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, $1s body elongating into that of a Viper!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Viper");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "viper");
   addstring(self.names, "snake");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null, "Slithering over the ground at great speed, " +
                              "the viper has a cold attitude to life and " +
                              "death, killing indescriminately and with " +
                              "no mercy. It is a very large animal, " +
                              "and quite deadly.");

   self.title := "- most poisonous of the snakes"; /* And the title */

   self.race := RACE_SNAKE;

   /* Now change appropriate abilities and attack, then add special */
   self.height := self.height + 50;
/*   setweight(self, self.weight + 1200); */

   self.attack_type := WPN_BITE;
   self.weapons[WPN_BITE] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("viper_combat@rebirth", self);
   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_POISON]));
   self.spells[SPL_POISON] := 100;

   dilcopy("viper_special@rebirth", self);

   act("You morph into a Viper!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will poison your victims, and you can also "+
       "CONSTRICT your victims (up to 5 times per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Viper");
   substring(self.names, "viper");
   substring(self.names, "snake");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_POISON] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");

   self.height := self.height - 50;
/*   setweight(self, self.weight - 1200); */

   self.weapons[WPN_BITE] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("viper_special@rebirth", self);
   i := dildestroy ("viper_combat@rebirth", self);

   self.attack_type := WPN_FIST;

   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Viper suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/

   quit;
}
dilend /* morph_viper */

dilbegin recall aware morph_demon();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;
   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, morphing into a great shadow demon!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Shadow Demon");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "shadow demon");
   addstring(self.names, "demon");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"This massive beast, a nightmare of fever-warmed blood, does not look " +
"like a being to be trifled with.  It is difficult to focus on the demon " +
"to make out details, but it is large, and it is evil.");

   self.title := "- Emissary of Evil"; /* And the title */

   self.race := RACE_SHADOW_DEVIL;

   /* Now change appropriate abilities and attack, then add special */

   self.height := self.height + 100;
/*   setweight(self, self.weight + 500); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_CHAIN, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("demon_combat@rebirth", self);
   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_ACIDBALL_2]));
   addextra(self.extra, {"$My_Spell2"}, itoa(self.spells[SPL_SLEEP]));

   self.spells[SPL_ACIDBALL_2] := 100;
   self.spells[SPL_SLEEP] := 100;

   dilcopy("demon_special@rebirth", self);

   act("You morph into a Shadow Demon!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically spit acid on your victims, " +
       "but you may also compel them to SLEEP (up to 5 times " +
       "per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name +  " the Shadow Demon");
   substring(self.names, "shadow demon");
   substring(self.names, "demon");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_ACIDBALL_2] := atoi(expd.descr);

   expd := "$My_Spell2" in self.extra;
   self.spells[SPL_SLEEP] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");
   subextra(self.extra, "$My_Spell2");

   self.height := self.height - 100;
/*   setweight(self, self.weight - 500); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("demon_special@rebirth", self);

   i := dildestroy ("demon_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Shadow Demon suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);

/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/

   quit;
}
dilend /* morph_demon */

dilbegin recall aware morph_dragon();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, growing into a great red dragon!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Red Dragon");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "red dragon");
   addstring(self.names, "dragon");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"You shudder to think that you are face to face with a great Red " +
"Dragon... an event not many have lived to tell about. " +
"Its scales appear to be as strong as any metal, and appear to be a " +
"very deep red.  Great amounts of smoke and flame " +
"emerge from its mouth as it roars.");

   self.title := "- spawn of Tiamat"; /* And the title */

   self.race := RACE_DRAGON_RED;

   /* Now change appropriate abilities and attack, then add special */

   addextra(self.extra, {"$My_Spell"},
            itoa(self.spells[SPL_CONTROL_TELEPORT]));
   addextra(self.extra, {"$My_Spell2"}, itoa(self.spells[SPL_FIRE_BREATH]));

   self.spells[SPL_CONTROL_TELEPORT] := 100;
   self.spells[SPL_FIRE_BREATH] := 100;

   self.height := self.height + 2000;
/*   setweight(self, self.weight + 1000); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
/*   self.armour_type := ARM_PLATE; */
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_PLATE, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("dragon_combat@rebirth", self);
   dilcopy("dragon_special@rebirth", self);

   act("You morph into a great Red Dragon!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically breath fire on your " +
       "victims, but you can also FLY to places, creatures and " +
       "things (up to 5 times per morph period).",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Red Dragon");
   substring(self.names, "red dragon");
   substring(self.names, "dragon");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_CONTROL_TELEPORT] := atoi(expd.descr);

   expd := "$My_Spell2" in self.extra;
   self.spells[SPL_FIRE_BREATH] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");
   subextra(self.extra, "$My_Spell2");

   self.height := self.height - 2000;
/*   setweight(self, self.weight - 1000); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("dragon_special@rebirth", self);
   i := dildestroy ("dragon_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Red Dragon suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_dragon */

dilbegin recall aware morph_lion();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, morphing into a lion!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Lion");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "lion");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"As you look at the creature, you are awed at the utter grace and " +
"elegance that it holds. Powerfully built and equally deadly, this " +
"lion could be quite an adversary in combat.");

   self.title := "- King of the Plains"; /* And the title */

   self.race := RACE_LION;

   /* Now change appropriate abilities and attack, then add special */

   self.height := self.height + 100;
/*   setweight(self, self.weight + 500); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
/*   self.armour_type := ARM_HLEATHER; */
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("lion_special@rebirth", self);
   dilcopy("lion_combat@rebirth", self);

   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_STUN]));
   self.spells[SPL_STUN] := 100;

   act("You morph into a Lion!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will maul your opponents, but you can also " +
       "ROAR at your opponent up to 5 times per morph period!",
       A_ALWAYS, self, null, null, TO_CHAR);
   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Lion");
   substring(self.names, "lion");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_STUN] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");

   self.height := self.height - 100;
/*   setweight(self, self.weight - 500); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("lion_special@rebirth", self);
   i := dildestroy ("lion_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Lion suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_lion */

dilbegin recall aware morph_panther();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, morphing into a panther!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Panther");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "panther");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,"A pair of beady eyes stare back at you " +
"in a knowing manner. This creature is the Lord of the jungle, agile " +
"and sleek, its majesty is only surpassed by its deadliness.");

   self.title := "- Lord of the Jungle"; /* And the title */

   self.race := RACE_CAT;

   /* Now change appropriate abilities and attack, then add special */

   self.height := self.height + 80;
/*   setweight(self, self.weight + 400); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
/*   self.armour_type := ARM_HLEATHER; */
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("panther_special@rebirth", self);
   dilcopy("panther_combat@rebirth", self);

   act("You morph into a Panther!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will rip your opponents, but you may also " +
       "RUN up to 5 times per morph period!",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Panther");
   substring(self.names, "panther");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");

   self.height := self.height - 80;
/*   setweight(self, self.weight - 400); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("panther_special@rebirth", self);
   i := dildestroy ("panther_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Panther suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

  setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_panther */

/* morph hellhound */
dilbegin recall aware morph_hellhound();

var
   expd        : extraptr;

   pc_name     : string; /* My name */
   t_string    : string;

   i           : integer;

   a           : integer;
   b           : integer;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, morphing into a Hell hound!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Hell Hound");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "hound");
      addstring(self.names, "hell hound");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
   "A pair of blood red eyes stare back at you."+
   "The master of the Astral realms this Hound ripples with Muscles and a magic "+
   "known only to few.");


   self.title := "- Lord of the Astral planes"; /* And the title */

   self.race := RACE_DOG;

   /* Now change appropriate abilities and attack, then add special */

   position_update(self);

   self.height := self.height + 80;
/*   setweight(self, self.weight + 600);  */

   self.attack_type := WPN_BITE;
   self.weapons[WPN_BITE] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_HLEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;


   dilcopy("hound_combat@rebirth", self);
   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_FIRE_BREATH]));
   self.spells[SPL_FIRE_BREATH] := 40;
   dilcopy("hound_special@rebirth", self);

   act("You morph into a Hell hound!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will bite your opponents, but you may also " +
       "BREATH up to 5 times per morph period!",
       A_ALWAYS, self, null, null, TO_CHAR);




   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the hell hound");
   substring(self.names, "hound");
      substring(self.names, "hell hound");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);
   
   expd := "$My_Spell" in self.extra;
   self.spells[SPL_FIRE_BREATH] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");   //removing spell after completeion 
                                       //remains in list otherwise
   
   self.height := self.height - 80;
/*   setweight(self, self.weight - 400); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_BITE] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("hound_special@rebirth", self);
   i := dildestroy ("hound_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Hell hound suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

  setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_hound*/
dilbegin recall aware morph_vampire();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n changes shape, morphing into a vampire!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, "The Vampire " + pc_name);
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "vampire");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"It is truly an arch vampire - one of the most feared creatures of " +
"the night. The blood-shot eyes contrast the deathly palor of the " +
"face, and the sight of its dreaded fangs alone injects terror into " +
"the bravest of warriors.");

   self.title := "- Drainer of Souls"; /* And the title */

   self.race := RACE_VAMPIRE;

   /* Now change appropriate abilities and attack, then add special */
   self.height := self.height + 20;
/*   setweight(self, self.weight + 50); */

   self.attack_type := WPN_CLAW;
   self.weapons[WPN_CLAW] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_LEATHER, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("vampire_special@rebirth", self);
   dilcopy("vampire_combat@rebirth", self);

   act("You morph into a Vampire!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically attempt to bite your " +
       "opponent, but you may also TRANSFIX them up to 5 times " +
       "per morph period!",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, "The Vampire " + pc_name);
   substring(self.names, "vampire");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");

   self.height := self.height - 20;
/*   setweight(self, self.weight - 50); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("vampire_special@rebirth", self);
   i := dildestroy ("vampire_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Vampire suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_vampire */

dilbegin recall aware morph_ice();

var
   expd        : extraptr;

   pc_name     : string; /* My name */

   i           : integer;

   a           : integer;
   b           : integer;

   t_u         : unitptr;

code
{
   heartbeat := PULSE_SEC*60*3; /* Morph for 3 minutes no more no less */
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n suddenly freezes into an ice elemental!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Ice Elemental");
    /* Sort out the names */
   substring(self.names, pc_name);
   addstring(self.names, "elemental");
   addstring(self.names, "ice");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"This towering figure seems to be solid ice, " +
"but it moves with fluid movements. It has great ice fists that could " +
"smash anything.");

   self.title := "- minion of Frost"; /* And the title */

   self.race := RACE_ELEMENTAL_FROST;

   /* Now change appropriate abilities and attack, then add special */

   self.height := self.height + 200;
/*   setweight(self, self.weight + 400); */

   self.attack_type := WPN_CRUSH;
   self.weapons[WPN_CRUSH] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_PLATE, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("ice_special@rebirth", self);
   dilcopy("ice_combat@rebirth", self);

   addextra(self.extra, {"$My_Spell"}, itoa(self.spells[SPL_FROSTBALL_3]));
   self.spells[SPL_FROSTBALL_3] := 100;
   addextra(self.extra, {"$My_Spell2"}, itoa(self.spells[SPL_LIGHTNING_3]));
   self.spells[SPL_LIGHTNING_3] := 100;

   act("You morph into an Ice Elemental!",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("\nDuring combat you will automatically summon an elemental Ice " +
       "storm upon your opponent, but you may also CALL lightning " +
       "up to 5 times per morph period!",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Ice Elemental");
   substring(self.names, "elemental");
   substring(self.names, "ice");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   expd := "$My_Spell" in self.extra;
   self.spells[SPL_FROSTBALL_3] := atoi(expd.descr);

   expd := "$My_Spell2" in self.extra;
   self.spells[SPL_LIGHTNING_3] := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");
   subextra(self.extra, "$My_Spell");
   subextra(self.extra, "$My_Spell2");

   self.height := self.height - 200;
/*   setweight(self, self.weight - 400); */

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CRUSH] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("ice_special@rebirth", self);
   i := dildestroy ("ice_combat@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Ice Elemental suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);
/*
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
   quit;
}
dilend /* morph_ice */

/*

dilbegin recall aware morph_fire();

var
   expd        : extraptr;

   pc_name     : string;

   i           : integer;

   a           : integer;
   b           : integer;

code
{
   heartbeat := PULSE_SEC*60*3;
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n suddenly ignites and burns into a fire elemental!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Fire Elemental");
   substring(self.names, pc_name);
   addstring(self.names, "elemental");
   addstring(self.names, "fire");
   addstring(self.names, pc_name);

   subextra(self.extra, "");
   addextra(self.extra, null,
"This towering figure seems to be made from fire itself. It's almost " +
"impossible to discern the features of its body - it's simply a tower " +
"of flame.");

   self.title := "- minion of Flame";

   self.race := RACE_ELEMENTAL_FIRE;

   self.height := self.height + 200;

   self.attack_type := WPN_CRUSH;
   self.weapons[WPN_CRUSH] := 150;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_PLATE, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("fire_special@rebirth", self);

   act("You morph into a Fire Elemental!",
       A_ALWAYS, self, null, null, TO_CHAR);

   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;

   substring(self.names, pc_name + " the Fire Elemental");
   substring(self.names, "elemental");
   substring(self.names, "fire");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");

   self.height := self.height - 200;

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("fire_special@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Fire Elemental suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);

   quit;
}
dilend

dilbegin recall aware morph_air();

var
   expd        : extraptr;

   pc_name     : string;

   i           : integer;

   a           : integer;
   b           : integer;

code
{
   heartbeat := PULSE_SEC*60*3;
   interrupt(SFB_MSG, (activator == self) and (argument == "unmorph"), end);

   setbright(self, self.bright + 1);

   pc_name := self.name;
   expd := "" in self.extra;

   addextra(self.extra, {"$My_Name"}, self.name);
   addextra(self.extra, {"$My_Title"}, self.title);
   addextra(self.extra, {"$My_Descr"}, expd.descr);
   addextra(self.extra, {"$My_Race"}, itoa(self.race));

   act("$1n suddenly phases and is replace by a swirling air elemental!",
       A_HIDEINV, self, null, null, TO_REST);

   addstring(self.names, pc_name + " the Air Elemental");
   substring(self.names, pc_name);
   addstring(self.names, "elemental");
   addstring(self.names, "air");
   addstring(self.names, pc_name);

   addextra(self.extra, null,"");

   self.title := "- minion of the Ether";

   self.race := RACE_ELEMENTAL_AIR;

   self.height := self.height + 200;

   self.attack_type := WPN_CRUSH;
   self.weapons[WPN_CRUSH] := 100;
   addaff(self, ID_NATURAL_ARMOUR, 50, WAIT_SEC*181,
          ARM_PLATE, 0, 0, TIF_NONE, TIF_NONE, TIF_NONE,
          APF_NATURAL_ARMOUR);

   self.hp := self.max_hp;

   dilcopy("air_special@rebirth", self);

   act("You morph into an Air Elemental!",
       A_ALWAYS, self, null, null, TO_CHAR);
   pause;
:end:
   expd := "$My_Name" in self.extra;
   pc_name := expd.descr;
   substring(self.names, pc_name + " the Air Elemental");
   substring(self.names, "elemental");
   substring(self.names, "air");

   subextra(self.extra, "");

   expd := "$My_Title" in self.extra;
   self.title := expd.descr;

   expd := "$My_Descr" in self.extra;
   addextra(self.extra, null, expd.descr);

   expd := "$My_Race" in self.extra;
   self.race := atoi(expd.descr);

   subextra(self.extra, "$My_Name");
   subextra(self.extra, "$My_Title");
   subextra(self.extra, "$My_Descr");
   subextra(self.extra, "$My_Race");

   self.height := self.height - 200;

   self.attack_type := WPN_FIST;
   self.weapons[WPN_CLAW] := 0;
   subaff(self, ID_NATURAL_ARMOUR);

   subextra(self.extra, "$morphed");

   i := dildestroy ("air_special@rebirth", self);
   i := dildestroy ("no_wear@rebirth", self);
   i := dildestroy ("morph_commands@rebirth", self);

   position_update(self);

   act("You return to your natural form!",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("The Air Elemental suddenly changes before your eyes into $1n!",
       A_HIDEINV, self, null, null, TO_REST);

   setbright(self, self.bright - 1);

   quit;
}
dilend
 */

dilbegin morph(arg : string); /* It's MORPHIN TIME! */

var
   expd       : extraptr;

   i          : integer;
   morph_type : integer;

   weapon     : unitptr;    /* Remove eq */
   nxt        : unitptr;

   link_u     : unitptr;
   t_u        : unitptr;
   slist      : stringlist;

code
{
/* rem out below to put back in */

  act("Morph has been temporarily disabled due to problems " +
       "with some morphs being unbalanced against others. " +
	   "As well as other issues. This will be fixed asap.",
       A_ALWAYS, self, null, null, TO_CHAR);
   subextra(self.extra, "$morphed");
   quit;
//to here
   if ((isset(self.pcflags, PC_PK_RELAXED)) and ("$Rebirth_Bob" in
        self.quests)) 

   if (isset(self.pcflags, PC_SPIRIT))
   {
      act("You can't do that when you're dead.",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if ("$morphed" in self.extra)
   {
      subextra(self.extra, "$morphed");
      sendto("unmorph", self); /* Switch off */
/*
Removed by Eirinn - this was never supposed to be in morph code, fool.
       Deal with dictionaries
      t_u := findunit(self, "rebbag", FIND_UNIT_IN_ME, null);
      if (t_u != null)
      {
         while(t_u.inside)
            link(t_u.inside, t_u.outside);
         destroy(t_u);
      }
*/
      quit;
   }

   if (self.level >= IMMORTAL_LEVEL)
   {
      act("It's MORPHIN time!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto start_morph;
   }

   if (not(PC_REBIRTHS in self.extra))
   {
      act("The gods have not bestowed that power upon you.",
          A_ALWAYS, self, null, null, TO_CHAR);
      subextra(self.extra, "$morphed");
      quit;
   }

:start_morph:

   if (not(dilfind("cmd_interpreter@commands", self)))
      dilcopy("cmd_interpreter@commands", self);

   if (arg == "giant")
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_1;

      if(not(F_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as an Udgaard Fighter!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := F_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Giant morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_1:
         morph_type := 1;
      }
   }

   else if ((arg == "snake") or (arg == "viper"))
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_2;

      if(not(T_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as an Udgaard Thief!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := T_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Viper morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_2:
         morph_type := 2;
      }
   }

   else if (arg == "phoenix")
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_3;

      if(not(H_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as an Udgaard Healer!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := H_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Phoenix morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_3:
         morph_type := 3;
      }
   }

   else if ("dragon" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_4;

      if(not(C_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as an Udgaard Conjurer!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := C_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Dragon morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_4:
         morph_type := 4;
      }
   }

   else if (arg == "lion")
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_5;

      if(not(P_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Midgaard Paladin!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := P_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Lion morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_5:
         morph_type := 5;
      }
   }

   else if ("elemental" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_6;

      if(not(S_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as an Midgaard Sorcerer!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := S_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Elemental morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_6:
         morph_type := 6;
      }
   }

   else if ("demon" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_7;

      if(not(A_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Khorsabad Assassin!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := A_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Shadow Demon morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_7:
         morph_type := 7;
      }
   }

   else if ("vampire" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_8;

      if(not(N_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Necromancer!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := N_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Vampire morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_8:
         morph_type := 8;
      }
   }

   else if ("panther" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_9;

      if(not(R_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Nymgaard Ranger!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := R_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Panther morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_9:
         morph_type := 9;
      }
   }
   else if ("hound" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_11;

      if(not(DK_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Midgaard Dark Knight!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := DK_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Dark Knight morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_11:
         morph_type := 11;
      }
   }


   else if ("basilisk" in arg)
   {
      if (self.level >= IMMORTAL_LEVEL) goto god_10;

      if(not(D_REBIRTHS in self.extra))
      {
         act("You have not rebirthed as a Nymgaard Druid!",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
      }

      expd := D_REBIRTHS in self.extra;
      slist := getwords(expd.names.[1]);
       if(atoi(slist.[0]) <= 0)
        {
         act("You don't have any Basilisk morphing time right now.",
             A_ALWAYS, self, null, null, TO_CHAR);
         quit;
        }

      else
      {
       slist.[0] := itoa(atoi(slist.[0]) - 1);
       expd.names.[1] := slist.[0] +" "+ slist.[1];
:god_10:
         morph_type := 10;
      }
   }

   else if (arg == "")
   {
      act("Morph? Yes! Fine! Morph we must, but into WHAT??",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   else
   {
      act("You don't know how to morph into that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      quit;
   }

   if (self.level >= IMMORTAL_LEVEL) goto is_god;

   if (self.position == POSITION_FIGHTING)
   {
      change_speed(self,2*PULSE_VIOLENCE);
      act("You begin to change...",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("$1n begins to change before your eyes!",
          A_ALWAYS, self, null, null, TO_REST);
      heartbeat := PULSE_VIOLENCE*3;
      pause;
   }

:is_god:

   dilcopy("no_wear@rebirth", self);

   /* Unequip all */

   weapon := self.inside;
   while ( weapon )
   {
      nxt := weapon.next;
      if (weapon.equip > 1)
         unequip(weapon);
      weapon := nxt;
   }

/* Remove affects */

   /* This is almost a copy/paste from basis dispel_magic */

   if (isaff(self, ID_BLESS))
     subaff(self, ID_BLESS);
   if (isaff(self, ID_UNHOLY_BLESSING))
     subaff(self, ID_UNHOLY_BLESSING);
   if (isaff(self, ID_RAGE))
     subaff(self, ID_RAGE);
   if (isaff(self, ID_BERSERK))
     subaff(self, ID_BERSERK);
   if (isaff(self, ID_DETECT_ALIGN))
     subaff(self, ID_DETECT_ALIGN);
   if (isaff(self, ID_DETECT_INVISIBLE))
     subaff(self, ID_DETECT_INVISIBLE);
   if (isaff(self, ID_DETECT_MAGIC))
     subaff(self, ID_DETECT_MAGIC);
   if (isaff(self, ID_DETECT_POISON))
     subaff(self, ID_DETECT_POISON);
   if (isaff(self, ID_DETECT_UNDEAD))
     subaff(self, ID_DETECT_UNDEAD);
   if (isaff(self, ID_DETECT_CURSE))
     subaff(self, ID_DETECT_CURSE);
   if (isaff(self, ID_DETECT_LIFE))
     subaff(self, ID_DETECT_LIFE);
   if (isaff(self, ID_ENCHANT_WEAPON))
     subaff(self, ID_ENCHANT_WEAPON);
   if (isaff(self, ID_ENCHANT_ARMOUR))
     subaff(self, ID_ENCHANT_ARMOUR);
   if (isaff(self, ID_ABSORBTION))
     subaff(self, ID_ABSORBTION);
   if (isaff(self, ID_INVISIBILITY))
     subaff(self, ID_INVISIBILITY);
   if (isaff(self, ID_HOLD))
     subaff(self, ID_HOLD);
   if (isaff(self, ID_CHARM))
     subaff(self, ID_CHARM);
   if (isaff(self, ID_MAGIC_LIGHT))
     subaff(self, ID_MAGIC_LIGHT);
   if (isaff(self, ID_MAGIC_DARK))
     subaff(self, ID_MAGIC_DARK);
   if (isaff(self, ID_SPL_RAISE_MAG))
     subaff(self, ID_SPL_RAISE_MAG);
   if (isaff(self, ID_SPL_RAISE_DIV))
     subaff(self, ID_SPL_RAISE_DIV);
   if (isaff(self, ID_SPL_RAISE_STR))
     subaff(self, ID_SPL_RAISE_STR);
   if (isaff(self, ID_SPL_RAISE_DEX))
     subaff(self, ID_SPL_RAISE_DEX);
   if (isaff(self, ID_SPL_RAISE_CON))
     subaff(self, ID_SPL_RAISE_CON);
   if (isaff(self, ID_SPL_RAISE_CHA))
     subaff(self, ID_SPL_RAISE_CHA);
   if (isaff(self, ID_SPL_RAISE_BRA))
     subaff(self, ID_SPL_RAISE_BRA);
   if (isaff(self, ID_SPL_RAISE_HPP))
     subaff(self, ID_SPL_RAISE_HPP);
   if (isaff(self, ID_SPL_RAISE_DIVINE))
     subaff(self, ID_SPL_RAISE_DIVINE);
   if (isaff(self, ID_SPL_RAISE_SUMMONING))
     subaff(self, ID_SPL_RAISE_SUMMONING);
   if (isaff(self, ID_SPL_RAISE_MIND))
     subaff(self, ID_SPL_RAISE_MIND);
   if (isaff(self, ID_SPL_RAISE_HEAT))
     subaff(self, ID_SPL_RAISE_HEAT);
   if (isaff(self, ID_SPL_RAISE_COLD))
     subaff(self, ID_SPL_RAISE_COLD);
   if (isaff(self, ID_SPL_RAISE_CELL))
     subaff(self, ID_SPL_RAISE_CELL);
   if (isaff(self, ID_SPL_RAISE_INTERNAL))
     subaff(self, ID_SPL_RAISE_INTERNAL);
   if (isaff(self, ID_SPL_RAISE_EXTERNAL))
     subaff(self, ID_SPL_RAISE_EXTERNAL);
   if (isaff(self, ID_RAISE_MAG))
     subaff(self, ID_RAISE_MAG);
   if (isaff(self, ID_RAISE_DIV))
     subaff(self, ID_RAISE_DIV);
   if (isaff(self, ID_RAISE_STR))
     subaff(self, ID_RAISE_STR);
   if (isaff(self, ID_RAISE_DEX))
     subaff(self, ID_RAISE_DEX);
   if (isaff(self, ID_RAISE_CON))
     subaff(self, ID_RAISE_CON);
   if (isaff(self, ID_RAISE_CHA))
     subaff(self, ID_RAISE_CHA);
   if (isaff(self, ID_RAISE_BRA))
     subaff(self, ID_RAISE_BRA);
   if (isaff(self, ID_RAISE_HPP))
     subaff(self, ID_RAISE_HPP);
   if (isaff(self, ID_RAISE_DIVINE))
     subaff(self, ID_RAISE_DIVINE);
   if (isaff(self, ID_RAISE_SUMMONING))
     subaff(self, ID_RAISE_SUMMONING);
   if (isaff(self, ID_RAISE_MIND))
     subaff(self, ID_RAISE_MIND);
   if (isaff(self, ID_RAISE_HEAT))
     subaff(self, ID_RAISE_HEAT);
   if (isaff(self, ID_RAISE_COLD))
     subaff(self, ID_RAISE_COLD);
   if (isaff(self, ID_RAISE_CELL))
     subaff(self, ID_RAISE_CELL);
   if (isaff(self, ID_RAISE_INTERNAL))
     subaff(self, ID_RAISE_INTERNAL);
   if (isaff(self, ID_RAISE_EXTERNAL))
     subaff(self, ID_RAISE_EXTERNAL);
   if (isaff(self, ID_POISON))
     subaff(self, ID_POISON);
   if (isaff(self, ID_FOCUS))
     subaff(self, ID_FOCUS);
   if (isaff(self, ID_MIRE))
     subaff(self, ID_MIRE);
   if (isaff(self, ID_CONDEMN))
     subaff(self, ID_CONDEMN);
   if (isaff(self, ID_SPEED))
     subaff(self, ID_SPEED);

   dilcopy("morph_commands@rebirth", self);

   addextra(self.extra, {"$morphed"}, "");

/*
   link_u := load("bag@midgaard");
    if(link_u == null)
     {
      log("Midgaard bag not available during morph.");
      quit;
     }
   link(link_u, self);
   addstring(link_u.names, "reb_2_bag");
:start_l:
   t_u := self.inside;
   while (t_u != null)
   {
        if("dictionary" in t_u.names) link(t_u, link_u.inside);
        t_u := t_u.next;
   }
   link_u.minv := 251;
*/
   if (morph_type == 1)
   {
      dilcopy("morph_giant@rebirth", self);
      goto end;
   }
   else if (morph_type == 2)
   {
      dilcopy("morph_viper@rebirth", self);
      goto end;
   }
   else if (morph_type == 3)
   {
      dilcopy("morph_phoenix@rebirth", self);
      goto end;
   }
   else if (morph_type == 4)
   {
      dilcopy("morph_dragon@rebirth", self);
      goto end;
   }
   else if (morph_type == 5)
   {
      dilcopy("morph_lion@rebirth", self);
      goto end;
   }
   else if (morph_type == 6)
   {
/*
      if (self.alignment < -349) */
         dilcopy("morph_ice@rebirth", self);
/*      else if (self.alignment > 349)
         dilcopy("morph_fire@rebirth", self);
      else
         dilcopy("morph_air@rebirth", self); */
      goto end;
   }
   else if (morph_type == 7)
   {
      dilcopy("morph_demon@rebirth", self);
      goto end;
   }
   else if (morph_type == 8)
   {
      dilcopy("morph_vampire@rebirth", self);
      goto end;
   }
   else if (morph_type == 9)
   {
      dilcopy("morph_panther@rebirth", self);
      goto end;
   }
   else if (morph_type == 10)
   {
      dilcopy("morph_basilisk@rebirth", self);
      goto end;
   }
   else if (morph_type == 11)
   {
      dilcopy("morph_hellhound@rebirth", self);
      goto end;
   }


:end:
   quit;
}
dilend /* morph */

dilbegin recall aware morph_charge(); /* Charge 6 mins per 12 hours */

var
   expd       : extraptr;
   i          : integer;
   t_int      : integer;
   slist      : stringlist;

code
{
:init:
   i := 0;
   heartbeat := PULSE_SEC * SECS_PER_MUD_HOUR ;

:ticker:
   wait(SFB_TICK, TRUE);
   i := i + 1;
   if (i >= 12) goto charge_it;
   goto ticker;

:charge_it:
   if ("$morphed" in self.extra)  /* Don't charge if morphed */
   {
      i := 11;
      goto ticker;
   }

   /* Increment where necessary */
if (self.extra.[F_REBIRTHS]!=null)
 {
   expd := F_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
   }
if (self.extra.[T_REBIRTHS]!=null)
 {
   expd := T_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
   }
if (self.extra.[H_REBIRTHS]!=null)
 {
   expd := H_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                       }
if (self.extra.[C_REBIRTHS]!=null)
 {
   expd := C_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
   }
if (self.extra.[R_REBIRTHS]!=null)
 {
   expd := R_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                            }
if (self.extra.[P_REBIRTHS]!=null)
 {
   expd := P_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                            }
if (self.extra.[S_REBIRTHS]!=null)
 {
   expd := S_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                            }
if (self.extra.[A_REBIRTHS]!=null)
 {
   expd := A_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
}
if (self.extra.[N_REBIRTHS]!=null)
 {
   expd := N_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                            }
if (self.extra.[D_REBIRTHS]!=null)
 {
   expd := D_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
}
if (self.extra.[DK_REBIRTHS]!=null)
 {
   expd := DK_REBIRTHS in self.extra;
    slist := getwords(expd.names.[1]);
     t_int := 5 * atoi(slist.[1]);
     slist.[0] := itoa(atoi(slist.[0]) + 2);
       if (atoi(slist.[0]) > t_int) slist.[0] := itoa(t_int);
   expd.names.[1] := slist.[0] +" "+ slist.[1];
                             }

   act("<div class=cpy>A bolt of lightning strikes you! You feel the gods restoring " +
       "some of your morphing power!</div>",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("<div class=cpyA bolt of lightning strikes $1n!</div>",
       A_SOMEONE, self, null, null, TO_NOTVICT);

   i := 0;

   goto ticker;
}
dilend /* morph_charge */

dilbegin guide(); /* Guide to rebirth */

var
   pc    : unitptr;

code
{
:init:
   heartbeat := PULSE_SEC * 8;

:start:
   wait(SFB_DONE, (command("say") and ("guide me" in argument) and
                   (activator.type == UNIT_ST_PC) and (activator.position
                    >= POSITION_RESTING)));
   pc := activator;
   secure(pc, lost_pc);

   if (pc.position == POSITION_FIGHTING)
   {
      act("Eternia says 'I can only guide you if you listen to me, and " +
          "fighting is not listening, friend.",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   if (REBIRTH_DATA in pc.quests) goto already_sac;

   act("Eternia says 'So you seek the knowledge of rebirth, friend $1n" +
       "'",
       A_SOMEONE, pc, null, null, TO_ALL);
   act("Eternia smiles knowingly.",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'The gods in their wisdom have seen fit to grant " +
       "the mortals of Valhalla a means to a life, in a sense, eternal " +
       "- though your life ends, another begins'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'It is the Rebirth. I am here to guide you and " +
       "answer your questions as best I can'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;

:explain:

   act("Eternia says 'Rebirth means you leave behind your mortal life " +
       "for another - you may become another race, sex, and alignment. "+
       "You begin again at level 1, with " +
       "enough experience to see you through five levels'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia continues 'However, to help you in your new life, you " +
       "retain some knowledge of your old - one quarter of each part of " +
       "your knowledge in spells, weapons and skills'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia smiles and continues 'You regain youth and can then start " +
       "on a new path in a new guild. The gods will grant you all of this'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'But I know you are asking yourself how do you " +
       "become worthy of this gift'",
       A_SOMEONE, pc, null, null, TO_ALL);
   heartbeat := PULSE_SEC;
   pause;
   heartbeat := PULSE_SEC*8;
   act("Eternia giggles girlishly. How unnerving!",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'To show your intention to rebirth, you gain favour " +
       "by sacrificing the heads of creatures of the world to the gods " +
       "in the shrine beyond the pool'",
       A_SOMEONE, pc, null, null, TO_ALL);
   heartbeat := PULSE_SEC;
   pause;
   act("Eternia points to the pool before you.",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   heartbeat := PULSE_SEC*8;
   act("Eternia says '$1n, you must enter the pool to reach " +
       "the Shrine of Destiny. It is not in this mortal reality. But " +
       "before you do that, I will continue with my advice'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'You gain favour in the amount of the level of the " +
       "creature whose head you sacrifice in the shrine - the higher " +
       "the level, the more favour you will be granted'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia continues by saying 'After your first sacrifice, you " +
       "have begun the quest of Rebirth. 'Rebirth' will show you how " +
       "much favour you have and how much you have left to gain " +
       "before you may leave this life'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
/*
   act("Eternia says 'Be warned however, those wishing to lose their " +
       "scar of violence must obtain more favour from the gods than " +
       "those who do not have it, or do not wish to lose it.'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'Those who have the scar are given the choice when " +
       "they have obtained enough favour of whether to rebirth with the " +
       "scar or continue to gain enough favour to rebirth and lose " +
       "the scar'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   act("Eternia says 'If you choose to continue gaining favour, be " +
       "warned - killing your fellow mortals is considered a violation " +
       "of the quest, and you will be heavily penalised, though you " +
       "can continue the quest. So only kill creatures, not your fellow " +
       "adventurers, if you wish to lose the scar'",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
*/
   act("Eternia says 'So the knowledge is now yours. Use it well, $1n" +
       "'",
       A_SOMEONE, pc, null, null, TO_ALL);
   act("Eternia kisses you lightly on the cheek.",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("Eternia kisses $1n lightly on the cheek.",
       A_SOMEONE, pc, null, null, TO_REST);
   heartbeat := PULSE_SEC;
   pause;
   act("Eternia says 'Good luck $1n. May the gods smile fortune upon " +
       "you.",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   heartbeat := PULSE_SEC*8;
   unsecure(pc);
   goto end;

:already_sac:
   act("Eternia says 'So you have begun the quest but seek the knowledge " +
       "again, $1n?",
       A_SOMEONE, pc, null, null, TO_ALL);
   heartbeat := PULSE_SEC;
   pause;
   heartbeat := PULSE_SEC*8;
   act("Eternia smiles saying 'Very well, I shall explain the wisdom of " +
       "the gods to you.",
       A_SOMEONE, pc, null, null, TO_ALL);
   pause;
   goto explain;

:lost_pc:
   unsecure(pc);
   act("Eternia sighs.",
       A_SOMEONE, self, null, null, TO_ALL);
   act("Eternia exclaims 'Oh the impetuousness of mortality.'",
       A_SOMEONE, self, null, null, TO_ALL);
   heartbeat := PULSE_SEC;
   pause;
   heartbeat := PULSE_SEC * 8;

:end:
   act("Eternia smiles and returns to watching the pool.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;
}
dilend /* guide */

/* The following dil is not going to be used as the book is being taken
   out soon. */

dilbegin recall aware rebirth_bob(); /* Copied on to all bob rebirthers */

var
   pc         : unitptr;    /* Victim */

   expd       : extraptr;   /* REBIRTH_DATA in self */

   i          : integer;    /* Need an integer */

   data_list  : stringlist; /* expd.names */
   new_list   : stringlist;

   tstr       : string;
   tstr2      : string;
   tot_num    : string;     /* I hate dil */
   demi_score : string;
   god_score  : string;
   fight_left : string;
   thief_left : string;
   heal_left  : string;
   conj_left  : string;
   palad_left : string;
   sorc_left  : string;
   ass_left   : string;
   necro_left : string;
   rang_left  : string;
   druid_left : string;
   knight_left : string;

code
{

:start:
   wait(SFB_PRE, (command(CMD_AUTO_DAMAGE) and
                  ((target.hp - power) < -8) and
                  (target.type == UNIT_ST_PC) and
                  (activator == self)));

   if ((isset(self.pcflags, PC_PK_RELAXED)) and ("$Rebirth_Bob" in
        self.quests))
   {
      act("<div class=cpr>You have invoked the fury of the gods by killing $3n while " +
          "on the rebirth quest!\nYou lose 100,000 rebirth points " +
          "for going against the gods!</div>",
          A_ALWAYS, self, null, target, TO_CHAR);
      act("A bolt of lightning shoots down from the skies " +
          "smiting $1n as $1e kills $3n!",
          A_SOMEONE, self, null, target, TO_NOTVICT);
      act("A bolt of lightning shoost down from the skies " +
          "smiting your killer as $1e kills you!",
          A_SOMEONE, self, null, target, TO_VICT);

      expd := REBIRTH_DATA in self.quests;

      data_list := expd.names;

      tot_num    := data_list.[1];
      fight_left := data_list.[2];
      thief_left := data_list.[3];
      heal_left  := data_list.[4];
      conj_left  := data_list.[5];
      palad_left := data_list.[6];
      sorc_left  := data_list.[7];
      ass_left   := data_list.[8];
      necro_left := data_list.[9];
      rang_left  := data_list.[10];
      druid_left := data_list.[11];
      knight_left := data_list.[12];
      demi_score := data_list.[13];
      god_score  := data_list.[14];

      i := atoi(god_score) - 100000;

      subextra(self.quests, REBIRTH_DATA);

      addstring(new_list, REBIRTH_DATA);
      addstring(new_list, tot_num);
      addstring(new_list, fight_left);
      addstring(new_list, thief_left);
      addstring(new_list, heal_left);
      addstring(new_list, conj_left);
      addstring(new_list, palad_left);
      addstring(new_list, sorc_left);
      addstring(new_list, ass_left);
      addstring(new_list, necro_left);
      addstring(new_list, rang_left);
      addstring(new_list, druid_left);
      addstring(new_list, knight_left);
      addstring(new_list, demi_score);
      addstring(new_list, itoa(i));

      addextra(self.quests, new_list, "BLANKETY BLANK");
   }
   else goto start;
}
dilend /* rebirth_bob */

dilbegin check_elig(); /* See if he's eligible */

var
   pc         : unitptr;
   tempu      : unitptr;

   god_score  : integer;
   t_int      : integer;
   check      : integer;
   i          : integer;

   tstr       : string;
   reject_str : string;

   expd       : extraptr;
   g_expd     : extraptr;

code
{
:init:
   heartbeat := 2;

:start:
   wait(SFB_CMD, (command("enter") and
 (findunit(activator, argument, FIND_UNIT_SURRO,null) == self)));
   block;
   pc := activator;
   secure(pc, lost_pc);

   if (pc.level > MORTAL_MAX_LEVEL)
   {
      act("You cannot rebirth! Only mortals can do that!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      act("The Flame rejects $1n as $1e attempts to enter it!",
          A_HIDEINV, pc, null, null, TO_REST);
      goto lost_pc;
   }

   if ("$morphed" in self.extra)
   {
      act("You cannot rebirth while you're morphed!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   dilcopy("check_elig2@rebirth", pc);

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* check_elig */

dilbegin recall aware check_elig2(); /* Continue */

var
   pc         : unitptr;
   bagu       : unitptr;
   tempu      : unitptr;
   link_u     : unitptr;
   t_u        : unitptr;
   temp_u     : unitptr;
   nxt        : unitptr;

   god_score  : integer;
   t_int      : integer;
   check      : integer;
   i          : integer;

   tstr       : string;
   reject_str : string;

   my_prompt  : string;
   data_list  : stringlist;

   expd       : extraptr;
   g_expd     : extraptr;
   expd2      : extraptr;

code
{
:init:
   heartbeat := 2;


   if ("$dead" in self.quests)
   {
      my_prompt := self.prompt;
      self.prompt := "Choose 1 - 11: ";
      act("The gods have " +
          "seen fit to grant you a free rebirth (wasn't that nice of " +
          "them?). However, you must choose which guild you would like " +
          "your morph power to come from, therefore please enter the " +
          "number of the guild at the prompt. The guilds are numbered " +
          "as follows: 1) Udgaard Fighter, 2) Udgaard Thief, 3) Udgaard " +
          "Healer, 4) Udgaard Conjurer, 5) Nymgaard Ranger, 6) " +
          "Midgaard Paladin, 7) Midgaard Sorcerer, 8) Khorsabad " +
          "Assassin, 9) Necromancer, 10) Nymgaard Druid, 11) Midgaard Knight.",
          A_ALWAYS, self, null, null, TO_CHAR);
:DO_AGAIN:
      wait(SFB_CMD, activator == self);
      block;

      tstr := cmdstr;

      if (tstr == "1")
         tstr := GUILD_UDG_FIGHTER;
      else if (tstr == "2")
         tstr := GUILD_UDG_THIEF;
      else if (tstr == "3")
         tstr := GUILD_UDG_CLERIC;
      else if (tstr == "4")
         tstr := GUILD_UDG_MAGE;
      else if (tstr == "5")
         tstr := GUILD_NYM_RANGER;
      else if (tstr == "6")
         tstr := GUILD_PALADIN;
      else if (tstr == "7")
         tstr := GUILD_SORCERER;
      else if (tstr == "8")
         tstr := GUILD_ASSASSIN;
      else if (tstr == "9")
         tstr := GUILD_NECROMANCER;
      else if (tstr == "10")
         tstr := GUILD_NYM_DRUID;
      else if (tstr == "11")
         tstr := GUILD_KNIGHT;
      else
      {
         self.prompt := "That is not a valid guild. Enter 1 - 11: ";
         goto DO_AGAIN;
      }
      self.prompt := my_prompt;
      subextra(self.quests, "$dead");
      addstring(data_list, "$dead_g");
      addstring(data_list, tstr);
      addextra(self.quests, data_list, "");
      goto fin_check;
   }

   my_prompt := self.prompt;
   self.prompt := ">";

   expd := SAC_POINTS in self.extra;

   god_score := atoi(expd.names.[1]);

   if (god_score < 250000)
   {
      act("The Gods deem you unworthy to rebirth!\nYou don't " +
          "have enough rebirth points!",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("The Flame rejects $1n as $1e attempts to enter it!",
          A_HIDEINV, self, null, null, TO_REST);
      self.prompt := my_prompt;
      goto lost_pc;
   }

   if (dilfind("no_kill@basis", self))
   {
      i := dildestroy("no_kill@basis", self);
      set(self.pcflags, PC_PK_RELAXED);
   }

:pre_check:

   if (self.exp < 4612500)
   {
      act("You do not have enough experience points for that! You " +
          "must have 300 levels worth of experience!",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("The Flame rejects $1n as $1e attempts to enter it!",
          A_HIDEINV, self, null, null, TO_REST);
      self.prompt := my_prompt;
      goto lost_pc;
   }

/* Checking guilds - check for 3 guilds. Then check for 40 levels in
   each

Names {"$Midgaard Paladin","47","$guild","quitter"}
"881291003"

*/

:g_check:

/* Changed on July 17th to accommadate the guild "$path" extra. */

   if ("$path" in self.quests)
   {
      g_expd := "$path" in self.quests;
      t_int := atoi(g_expd.names.[4]);
      if (t_int < 40)
      {
         reject_str := g_expd.names.[1] + ", the " + g_expd.names.[2] +
                       ", or the " + g_expd.names.[3] + "!";
         goto not_maxed;
      }
      t_int := atoi(g_expd.names.[5]);
      if (t_int < 40)
      {
         reject_str := g_expd.names.[2] + " or the " + g_expd.names.[3] + "!";
         goto not_maxed;
      }
      t_int := atoi(g_expd.names.[6]);
      if (t_int < 40)
      {
         reject_str := g_expd.names.[3] + "!";
         goto not_maxed;
      }
      check := 3;
      goto num_check;
   }

   check := 0;
   g_expd := ("$" + GUILD_UDG_FIGHTER) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Fighters Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_UDG_THIEF) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Thieves Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_UDG_CLERIC) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Healers Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_UDG_MAGE) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Conjurers Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_PALADIN) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Paladins Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_SORCERER) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Sorcerers Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_ASSASSIN) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Assassins Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_NECROMANCER) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Necromancers Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_NYM_RANGER) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Rangers Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

   g_expd := ("$" + GUILD_NYM_DRUID) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Druids Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }
   g_expd := ("$" + GUILD_KNIGHT) in self.quests;
   if (g_expd)
   {
      t_int := atoi(g_expd.names.[1]);
      if (t_int < 40)
      {
         reject_str := "Knights Guild!";
         goto not_maxed;
      }
      check := check + 1;
   }

:num_check:

   if (check < 3)
   {
      act("You have not completed the three guilds in your guild " +
          "path!",
          A_ALWAYS, self, null, null, TO_CHAR);
      act("The Flame rejects $1n as $1e attempts to enter it!",
          A_HIDEINV, self, null, null, TO_REST);
      goto lost_pc;
   }

:dictionary_check:

      sendtext("<div class=cpr>IMPORTANT:&[default]If you have aliased " +
          "any numbers in your dictionary or in your mud client " +
          "you will not be able to rebirth. Unalias the " +
          "aliases (you can do this now, at the prompt because " +
          "the dictionary catches the unalias command before " +
          "this program) or remove them from your mud client.\n", self);

/*   self.prompt := "When you're ready, type go and press return..."; */
   sendtext("\ne.g. for your dictionary, unalias 1 or unalias 2, etc.\n", self);
   sendtext ("When you're ready, type ' go  ' and press return...\n",self);
:dict_2:
   wait(SFB_CMD, (activator == self));
   block;
   if (not(command("go")))
   {
      act("Type go, silly!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto dict_2;
   }

   self.prompt := ">";

:fin_check:
:ok_now_go:
   act("You enter the flame and it consumes you!\nThis life is over " +
       "for you, but another is just beginning...",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("$1n enters the flames and vanishes from this existence!",
       A_SOMEONE, self, null, null, TO_REST);

   self.minv := 200;

   self.prompt := my_prompt;

   dilcopy("nanny_rebirth@rebirth", self);

   i := dildestroy("rebirth_bob@rebirth", self);

   link(self, findroom("waiting_room@rebirth"));
   goto lost_pc;

:put_em_back:
   self.prompt := my_prompt;
   act("You find yourself in Cypress Forest!",
       A_ALWAYS, self, null, null, TO_CHAR);
   link(self, findroom("reb_glade@rebirth"));
   exec("look", self);

:go_on:
   quit;

   goto lost_pc;

:not_maxed:
   self.prompt := my_prompt;
   act("You have not completed at least 40 levels in the " +
       reject_str,
       A_ALWAYS, self, null, null, TO_CHAR);
   act("The Flame rejects $1n as $1e attempts to enter it!",
       A_HIDEINV, self, null, null, TO_REST);
   goto lost_pc;

:not_three:
   self.prompt := my_prompt;
   act("You have not completed the guilds in your guild path.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("The Flame rejects $1n as $1e attempts to enter it!",
       A_HIDEINV, self, null, null, TO_REST);
   goto lost_pc;

:lost_pc:

   quit;
}
dilend /* check_elig2 */

#define FIGH_BIT 1
#define HEAL_BIT 2
#define CONJ_BIT 4
#define THIE_BIT 8
#define PALA_BIT 16
#define SORC_BIT 32
#define ASSA_BIT 64
#define NECR_BIT 128
#define RANG_BIT 256
#define DRUI_BIT 512
#define KNIG_BIT 1024


// WARNING MS2002
// This should call standard func in basis, the one that sets a char's abilities
// and more based on race. Code duplication will lead to disaster
// MS updated to run same player init code as in basis
//
dilbegin recall aware nanny_rebirth ();
external guild_choose ();
   upd_all_comp@competition(u:unitptr);
   upd_rebirth@competition(u:unitptr);
   pcinitabils@basis();

var
   pc          : unitptr;
   weapon      : unitptr;
   nxt         : unitptr;
   tempu       : unitptr;
   link_u      : unitptr;
   t_u         : unitptr;
   temp_u      : unitptr;
   i           : integer;
   j           : integer;
   l           : integer;
   picks       : integer;
   my_pcflags  : integer;
   s           : string;
   new_guild   : string;
   figh_choice : integer;
   heal_choice : integer;
   conj_choice : integer;
   thie_choice : integer;
   pala_choice : integer;
   sorc_choice : integer;
   assa_choice : integer;
   necr_choice : integer;
   rang_choice : integer;
   drui_choice : integer;
   dk_choice : integer;
   expd       : extraptr;   /* REBIRTH_DATA in self */
   expd2      : extraptr;
   broad      : string;
   slist      : stringlist;

code
{
   heartbeat := PULSE_SEC * 2;
   pause;


   /* Unequip all */
   weapon:=self.inside;
   while (weapon!=null){
      if (weapon.equip!=0){
         unequip(weapon);
      }
      weapon:=weapon.next;
	}

   /* Remove affects */

   /* This is almost a copy/paste from basis dispel_magic */
   :loop:
   if (isaff(self, ID_BLESS))
     subaff(self, ID_BLESS);
   else if (isaff(self, ID_UNHOLY_BLESSING))
     subaff(self, ID_UNHOLY_BLESSING);
   else if (isaff(self, ID_NBLESS))
     subaff(self, ID_NBLESS);
   else if (isaff(self, ID_RAGE))
     subaff(self, ID_RAGE);
   else if (isaff(self, ID_BERSERK))
     subaff(self, ID_BERSERK);
   else if (isaff(self, ID_DETECT_ALIGN))
     subaff(self, ID_DETECT_ALIGN);
   else if (isaff(self, ID_DETECT_INVISIBLE))
     subaff(self, ID_DETECT_INVISIBLE);
   else if (isaff(self, ID_DETECT_MAGIC))
     subaff(self, ID_DETECT_MAGIC);
   else if (isaff(self, ID_DETECT_POISON))
     subaff(self, ID_DETECT_POISON);
   else if (isaff(self, ID_DETECT_UNDEAD))
     subaff(self, ID_DETECT_UNDEAD);
   else if (isaff(self, ID_DETECT_CURSE))
     subaff(self, ID_DETECT_CURSE);
   else if (isaff(self, ID_DETECT_LIFE))
     subaff(self, ID_DETECT_LIFE);
   else if (isaff(self, ID_ENCHANT_WEAPON))
     subaff(self, ID_ENCHANT_WEAPON);
   else if (isaff(self, ID_ENCHANT_ARMOUR))
     subaff(self, ID_ENCHANT_ARMOUR);
   else if (isaff(self, ID_ABSORBTION))
     subaff(self, ID_ABSORBTION);
   else if (isaff(self, ID_INVISIBILITY))
     subaff(self, ID_INVISIBILITY);
   else if (isaff(self, ID_HOLD))
     subaff(self, ID_HOLD);
   else if (isaff(self, ID_CHARM))
     subaff(self, ID_CHARM);
   else if (isaff(self, ID_MAGIC_LIGHT))
     subaff(self, ID_MAGIC_LIGHT);
   else if (isaff(self, ID_MAGIC_DARK))
     subaff(self, ID_MAGIC_DARK);
   else if (isaff(self, ID_SPL_RAISE_MAG))
     subaff(self, ID_SPL_RAISE_MAG);
   else if (isaff(self, ID_SPL_RAISE_DIV))
     subaff(self, ID_SPL_RAISE_DIV);
   else if (isaff(self, ID_SPL_RAISE_STR))
     subaff(self, ID_SPL_RAISE_STR);
   else if (isaff(self, ID_SPL_RAISE_DEX))
     subaff(self, ID_SPL_RAISE_DEX);
   else if (isaff(self, ID_SPL_RAISE_CON))
     subaff(self, ID_SPL_RAISE_CON);
   else if (isaff(self, ID_SPL_RAISE_CHA))
     subaff(self, ID_SPL_RAISE_CHA);
   else if (isaff(self, ID_SPL_RAISE_BRA))
     subaff(self, ID_SPL_RAISE_BRA);
   else if (isaff(self, ID_SPL_RAISE_HPP))
     subaff(self, ID_SPL_RAISE_HPP);
   else if (isaff(self, ID_SPL_RAISE_DIVINE))
     subaff(self, ID_SPL_RAISE_DIVINE);
   else if (isaff(self, ID_SPL_RAISE_SUMMONING))
     subaff(self, ID_SPL_RAISE_SUMMONING);
   else if (isaff(self, ID_SPL_RAISE_MIND))
     subaff(self, ID_SPL_RAISE_MIND);
   else if (isaff(self, ID_SPL_RAISE_HEAT))
     subaff(self, ID_SPL_RAISE_HEAT);
   else if (isaff(self, ID_SPL_RAISE_COLD))
     subaff(self, ID_SPL_RAISE_COLD);
   else if (isaff(self, ID_SPL_RAISE_CELL))
     subaff(self, ID_SPL_RAISE_CELL);
   else if (isaff(self, ID_SPL_RAISE_INTERNAL))
     subaff(self, ID_SPL_RAISE_INTERNAL);
   else if (isaff(self, ID_SPL_RAISE_EXTERNAL))
     subaff(self, ID_SPL_RAISE_EXTERNAL);
   else if (isaff(self, ID_RAISE_MAG))
     subaff(self, ID_RAISE_MAG);
   else if (isaff(self, ID_RAISE_DIV))
     subaff(self, ID_RAISE_DIV);
   else if (isaff(self, ID_RAISE_STR))
     subaff(self, ID_RAISE_STR);
   else if (isaff(self, ID_RAISE_DEX))
     subaff(self, ID_RAISE_DEX);
   else if (isaff(self, ID_RAISE_CON))
     subaff(self, ID_RAISE_CON);
   else if (isaff(self, ID_RAISE_CHA))
     subaff(self, ID_RAISE_CHA);
   else if (isaff(self, ID_RAISE_BRA))
     subaff(self, ID_RAISE_BRA);
   else if (isaff(self, ID_RAISE_HPP))
     subaff(self, ID_RAISE_HPP);
   else if (isaff(self, ID_RAISE_DIVINE))
     subaff(self, ID_RAISE_DIVINE);
   else if (isaff(self, ID_RAISE_SUMMONING))
     subaff(self, ID_RAISE_SUMMONING);
   else if (isaff(self, ID_RAISE_MIND))
     subaff(self, ID_RAISE_MIND);
   else if (isaff(self, ID_RAISE_HEAT))
     subaff(self, ID_RAISE_HEAT);
   else if (isaff(self, ID_RAISE_COLD))
     subaff(self, ID_RAISE_COLD);
   else if (isaff(self, ID_RAISE_CELL))
     subaff(self, ID_RAISE_CELL);
   else if (isaff(self, ID_RAISE_INTERNAL))
     subaff(self, ID_RAISE_INTERNAL);
   else if (isaff(self, ID_RAISE_EXTERNAL))
     subaff(self, ID_RAISE_EXTERNAL);
   else if (isaff(self, ID_MIRE))
     subaff(self, ID_MIRE);
   else if (isaff(self, ID_CONDEMN))
     subaff(self, ID_CONDEMN);
   else if (isaff(self, ID_FOCUS))
     subaff(self, ID_FOCUS);
   else if (isaff(self, ID_POISON))
     subaff(self, ID_POISON);
   else if (isaff(self, ID_SPEED))
     subaff(self, ID_SPEED);
   else
	goto end_aff;


   goto loop;
   :end_aff:

   i := 0;

/* First reduce skills by 75% */

   while (i < LAST_SKILL)
   {
      self.skills[i] := self.skills[i] / 8;
      self.skills[i] := self.skills[i] * 2;
      i := i + 1;
   }

   i := 0;

/* Now spells */

   while (i < LAST_SPELL)   /* was 220 */
   {
      self.spells[i] := self.spells[i] / 4;
      i := i + 1;
   }

   i := 0;

/* Now weapons */

   while (i < LAST_WEAPON)  /* was 60 */
   {
      self.weapons[i] := self.weapons[i] / 4;
      i := i + 1;
   }

   expd2 := "$path" in self.quests;
   if (expd2 != null)
   {
      self.guild := expd2.names.[1];
      subextra(self.quests, "$path");
   }
   expd2 := null;

   expd2 := "$dead_g" in self.quests;
   if (expd2 != null)
   {
      self.guild := expd2.names.[1];
   }

   if (self.guild == GUILD_UDG_FIGHTER)
      l := 2;
   else if (self.guild == GUILD_UDG_THIEF)
      l := 3;
   else if (self.guild == GUILD_UDG_CLERIC)
      l := 4;
   else if (self.guild == GUILD_UDG_MAGE)
      l := 5;
   else if (self.guild == GUILD_PALADIN)
      l := 6;
   else if (self.guild == GUILD_SORCERER)
      l := 7;
   else if (self.guild == GUILD_ASSASSIN)
      l := 8;
   else if (self.guild == GUILD_NECROMANCER)
      l := 9;
   else if (self.guild == GUILD_NYM_RANGER)
      l := 10;
   else if (self.guild == GUILD_NYM_DRUID)
      l := 11;
   else if (self.guild == GUILD_KNIGHT)
      l := 12;



/* Remove me from guilds */

:remove_guilds:

   if ("$guild" in self.quests)
   {
      subextra(self.quests, "$guild");
      goto remove_guilds;
   }

   self.guild := "Rebirthing";

   if (dilfind("no_kill@basis", self))
   {
      i := dildestroy("no_kill@basis", self);
      set(self.pcflags, PC_PK_RELAXED);
   }

   if ((isset(self.pcflags, PC_PK_RELAXED)) and (not("$Rebirth_Bob" in
         self.quests)))
   {
      addextra(self.quests,{"$Re-Bob"},"");
      unset(self.pcflags, PC_PK_RELAXED);
   }

   /* Here we remove the inform pc flag from the person's pcflags - this stops
      spam, etc - the settings are retained and replaced at the end
      of the procecure. */

   my_pcflags := self.pcflags;
   if (isset(my_pcflags, PC_INFORM))
      unset(self.pcflags, PC_INFORM);

/* We worry about abilities later */
addextra(self.extra,{"$rebirth_prompt"},self.prompt);
i:=dildestroy("send_prompt@update",self);
dilcopy ("rebirth_prompt@update",self);

   self.prompt := ">";

   act("In a state of semi-consciousness, an ethereal voice " +
       "calls to you through the void...\n",
       A_ALWAYS, self, null, null, TO_CHAR);
   heartbeat := PULSE_SEC*4;
   wait(SFB_CMD | SFB_TICK, TRUE);
   block;
   heartbeat := PULSE_SEC;
   act("Life ends, and is born anew. You must now choose the beginning " +
       "of your new life, " + self.name + ". <div class=cpw>Remember your " +
       "choices will affect " +
       "later choices, e.g. your alignment affects what guilds you " +
       "can join.</div>\n",
       A_ALWAYS, self, null, null, TO_CHAR);

:get_gender:
   self.prompt := "Please select 1 or 2:";
   sendtext("\nPlease choose your new gender:\n" +
            "  <div class=cpw>1</div>) Male\n" +
            "  <div class=cpw>2</div>) Female\n", self);

   wait(SFB_CMD, (activator == self));
   block;
   if (not(command("1")) and not (command("2")))
   {
      act("That is not a valid gender!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_gender;
   }

   if (command("1"))
   {
      self.sex := SEX_MALE;
      act("You are now male.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_race;
   }

   else
   {
      self.sex := SEX_FEMALE;
      act("You are now female.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_race;
   }

:get_race:

   self.prompt := "Please select 1 - 11:";
   sendtext("\nPlease choose your race:\n"+
            "  <div class=cpw>1</div>) Human</div>            <div class=cpw> 7</div>) Half-Ogre \n"+
            "  <div class=cpw>2</div>) Elf</div>              <div class=cpw> 8</div>) Half-Elf\n"+
            "  <div class=cpw>3</div>) Dwarf</div>            <div class=cpw> 9</div>) Brownie\n"+
            "  <div class=cpw>4</div>) Halfing</div>          <div class=cpw>10</div>) Groll\n"+
            "  <div class=cpw>5</div>) Gnome</div>            <div class=cpw>11</div>) Dark-Elf (Evil)\n"+
            "  <div class=cpw>6</div>) Half-Orc\n", self);

   wait(SFB_CMD, (activator == self));
   block;

   if (atoi(cmdstr) == 1)
   {
      self.race := 0;
      act("You are now a human.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 2)
   {
      self.race := 1;
      act("You are now an elf.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 3)
   {
      self.race := 2;
      act("You are now a dwarf.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 4)
   {
      self.race := 3;
      act("You are now a halfling.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 5)
   {
      self.race := 4;
      act("You are now a gnome.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 6)
   {
      self.race := 5;
      act("You are now a half-orc.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 7)
   {
      self.race := 6;
      act("You are now a half-ogre.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 8)
   {
      self.race := 7;
      act("You are now a half-elf.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 9)
   {
      self.race := 8;
      act("You are now a brownie.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 10)
   {
      self.race := 9;
      act("You are now a groll.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else if (atoi(cmdstr) == 11)
   {
      self.race := 10;
      act("You are now a dark-elf.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_alignment;
   }

   else
   {
      act("That is not a valid race!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto get_race;
   }

:get_alignment:

/* As of July 17th, This has been put in guild_choose with guilds. */

   guild_choose();

:finish_off:
/*   self.guild := new_guild;

   new_guild := "$" + new_guild;

   data_list := null;
   addstring(data_list, new_guild);
   addstring(data_list, "0");
   addstring(data_list, "$guild");

   addextra(self.quests, data_list, itoa(realtime));
*/

   reset_level(self);  /* Reset my level to 1 */
   reset_race(self);   /* Reset my race attributes - age, costs, etc */
   reset_vlevel(self);

   pcinitabils@basis();

   if (self.race==RACE_HUMAN)
   {
      self.birth := realtime - (rnd(16, 19) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_DWARF)
   {
      self.birth := realtime - (rnd(60,85) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_ELF)
   {
      self.birth := realtime - (rnd(190,215) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_HALFLING)
   {
      self.birth := realtime - (rnd(39, 48) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_GNOME)
   {
      self.birth := realtime - (rnd(104, 137) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_HALF_OGRE)
   {
      self.birth := realtime - (rnd(20, 30) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_HALF_ORC)
   {
      self.birth := realtime - (rnd(19, 25) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_BROWNIE)
   {
      self.birth := realtime - (rnd(34, 48) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_HALF_ELF)
   {
      self.birth := realtime - (rnd(25, 40) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_GROLL)
   {
      self.birth := realtime - (rnd(9, 12) * SECS_PER_MUD_YEAR);
   }
   else if (self.race==RACE_DARK_ELF)
   {
      self.birth := realtime - (rnd(196, 226) * SECS_PER_MUD_YEAR);
   }

   /* Update morph data, etc */

      expd := PC_REBIRTHS in self.extra;

      if (expd == null)
          {
          slist := {PC_REBIRTHS};
          addstring (slist, "0");
          addextra (self.extra, slist, "Total Rebirths");
          expd := PC_REBIRTHS in self.extra;
          }

      i := 0;

      expd.names.[1] := itoa(atoi(expd.names.[1]) + 1);

      if (l == 2)
      {
       expd := F_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {F_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Fighter Rebirths");
         expd := F_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 3)
      {
       expd := T_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {T_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Thief Rebirths");
         expd := T_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 4)
      {
       expd := H_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {H_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Healer Rebirths");
         expd := H_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 5)
      {
       expd := C_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {C_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Conjurer Rebirths");
         expd := C_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 6)
      {
       expd := P_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {P_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Paladin Rebirths");
         expd := P_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 7)
      {
       expd := S_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {S_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Sorcerer Rebirths");
         expd := S_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 8)
      {
       expd := A_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {A_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Assassin Rebirths");
         expd := A_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 9)
      {
       expd := N_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {N_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Necromancer Rebirths");
         expd := N_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 10)
      {
       expd := R_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {R_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Ranger Rebirths");
         expd := R_REBIRTHS in self.extra;
        }
       goto setit;
      }
      if (l == 11)
      {
       expd := D_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {D_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Druid Rebirths");
         expd := D_REBIRTHS in self.extra;
        }
       goto setit;
      }
	   expd := DK_REBIRTHS in self.extra;
       if(expd == null)
        {
         slist := {DK_REBIRTHS};
         addstring(slist, "0 0");
         addextra(self.extra, slist, "Knight Rebirths");
         expd := DK_REBIRTHS in self.extra;
        }
       goto setit;

:setit:
         slist := getwords(expd.names.[1]);
         slist.[0] := itoa(atoi(slist.[0]) + 5);
         slist.[1] := itoa(atoi(slist.[1]) + 1);
         expd.names.[1] := slist.[0] +" "+ slist.[1];

         expd := SAC_POINTS in self.extra;
         expd.names.[1] := "0";

   expd2 := "$rebirth_prompt" in self.extra;
   self.prompt := expd2.descr;
   subextra(self.extra, "$rebirth_prompt");
i:=dildestroy("rebirth_prompt@update",self);
dilcopy ("send_prompt@update",self);


   act("&h",
       A_ALWAYS, self, null, null, TO_CHAR);

   act("\n\nThe gods have seen fit to let you keep your equipment from " +
       "your previous life in the hope that it will help you in this " +
       "new one.",
       A_ALWAYS, self, null, null, TO_CHAR);
   wait(SFB_CMD | SFB_TICK, TRUE);
   block;
   act("A great portal opens and you find yourself somewhere else!",
       A_ALWAYS, self, null, null, TO_CHAR);

   if (self.guild == GUILD_ASSASSIN)
      link(self, findroom("entrance@assassin"));
   else if (self.guild == GUILD_SORCERER)
      link(self, findroom("ent_guild@sorcerer"));
   else if (self.guild == GUILD_NYM_RANGER)
      link(self, findroom("for_gath1@ranger"));
   else if (self.guild == GUILD_UDG_FIGHTER)
      link(self, findroom("entrance@fightersguild"));
   else if (self.guild == GUILD_UDG_THIEF)
      link(self, findroom("entrance@thievesguild"));
   else if (self.guild == GUILD_UDG_CLERIC)
      link(self, findroom("entrance@clericguild"));
   else if (self.guild == GUILD_UDG_MAGE)
      link(self, findroom("entrance@mageguild"));
   else if (self.guild == GUILD_PALADIN)
      link(self, findroom("mon_yard@paladin_guild"));
   else if (self.guild == GUILD_NECROMANCER)
      link(self, findroom("church_ruin@necro_guild"));
   else if (self.guild == GUILD_KNIGHT)
      link(self, findroom("room_5@knight"));
   else if (self.guild == GUILD_NYM_DRUID)
      link(self, findroom("henge@druid"));

   if (self.outside.nameidx == "waiting_room")
      link(self, findroom("temple@udgaard"));

upd_rebirth@competition(self);
   i := 0 - self.exp;
   experience(i, self);
   
   experience(11250, self);
                                 upd_all_comp@competition(self);

   subextra (self.quests, "$dead_g");
self.max_hp:=3*self.abilities[ABIL_HP]+20;
   self.skill_points := 80;
   self.ability_points := 40;

:end:
   sendto("rebirth_done", self);

   /* cycle through wearable equipment and resize */
   set_weight(self, self.baseweight);

   tempu := self.inside;
   while(tempu)
   {
      if ((tempu.names.[0]=="storage container") and (tempu.minv>200))
      {
         set_weight_base(tempu, 0);
         set_weight(tempu, 0);
      }

      if (tempu.weight<0)
      {
         if (tempu.minv>=200)
            set_weight(tempu, 0);
         else
            set_weight(tempu, tempu.baseweight);
	   }
      set_weight(self, self.weight+tempu.weight);


     if((tempu.manipulate & (MANIPULATE_WEAR_FINGER | MANIPULATE_WEAR_NECK  |
                             MANIPULATE_WEAR_BODY   | MANIPULATE_WEAR_HEAD  |
                             MANIPULATE_WEAR_LEGS   | MANIPULATE_WEAR_FEET  |
                             MANIPULATE_WEAR_HANDS  | MANIPULATE_WEAR_ARMS  |
                             MANIPULATE_WEAR_SHIELD | MANIPULATE_WEAR_ABOUT |
                             MANIPULATE_WEAR_WAIST  | MANIPULATE_WEAR_WRIST |
                             MANIPULATE_WIELD       | MANIPULATE_WEAR_EAR   |
                             MANIPULATE_WEAR_BACK   | MANIPULATE_WEAR_CHEST |
                             MANIPULATE_WEAR_ANKLE)) == 0) goto nowayinhell;
     tempu.height := self.height;
:nowayinhell:
     tempu := tempu.next;
    }

:go_on:

   if (isset(my_pcflags, PC_INFORM))
      set(self.pcflags, PC_INFORM);
   if ("$Re-Bob" in self.quests)
   {
      dilcopy("rebob@rebirth", self);
      act("<div class=cpr>Please note that shortly after you reach level 50 you " +
          "will automatically be put back into the book of blood.\n",
          A_ALWAYS, self, null, null, TO_CHAR);
   }
   self.minv := 0; /* Make them visible to mortals again */
   act("$1n steps out of a portal and into the room.",
       A_SOMEONE, self, null, null, TO_REST);
   exec("look", self);
   if (not(dilfind("morph_charge@rebirth", self)))
      dilcopy("morph_charge@rebirth", self);
   destroy(tempu);

   self.hp := self.max_hp;
   self.endurance := self.max_endurance;
   self.mana := self.max_mana;

   set(self.charflags, CHAR_PROTECTED);
   self.crimes := 0;

   position_update(self);

  broad := "<div class=cpr>The grounds tremors and lightning streaks across the " +
  "heavens as the gods mark " + self.name + "'s rebirth.</div>";

  broad := textformat(broad);

  pc := self;

  while (pc.gprevious.type==UNIT_ST_PC)
     pc := pc.gprevious;

     while (pc.type==UNIT_ST_PC)
      {
     act(broad, A_ALWAYS, pc, null, null, TO_CHAR);
      pc:=pc.gnext;
      }

   tempu := load("guild_medallion@guild_paths");
    tempu.height := self.height;
   link(tempu, self);
   tempu := load("torch@midgaard");
   link(tempu,self);
   exec("wear medallion", self);
   exec("hold torch", self);
   exec("light torch", self);
   act("Don't forget to use your medallion to get around!",
       A_ALWAYS, self, null, null, TO_CHAR);
   quit;
}
dilend /* nanny_rebirth */

dilbegin aware guild_choose ();

var
   s         : string;

   g1        : integer;
   g2        : integer;
   g3        : integer;
   cat       : integer;

   data_list : stringlist;
   gug       : stringlist;
   ini       : stringlist;

code
{
   addstring(gug, "-");
   addstring(gug, "Udgaard Fighter");    /* 1 */
   addstring(gug, "Udgaard Thief");      /* 2 */
   addstring(gug, "Udgaard Healer");     /* 3 */
   addstring(gug, "Udgaard Conjurer");   /* 4 */
   addstring(gug, "Nymgaard Ranger");    /* 5 */
   addstring(gug, "Midgaard Paladin");   /* 6 */
   addstring(gug, "Midgaard Sorcerer");  /* 7 */
   addstring(gug, "Khorsabad Assassin"); /* 8 */
   addstring(gug, "Necromancer");        /* 9 */
   addstring(gug, "Nymgaard Druid");     /*10 */
   addstring(gug, "Midgaard Dark Knight");     /*11 */

   addstring(ini, "-");
   addstring(ini, "<div class=cpr>F</div>");    /* 1 */
   addstring(ini, "<div class=cpy>T</div>");    /* 2 */
   addstring(ini, "<div class=cpb>H</div>");    /* 3 */
   addstring(ini, "<div class=cpm>C</div>");    /* 4 */
   addstring(ini, "<div class=cpg>R</div>");    /* 5 */
   addstring(ini, "<div class=cpw>P</div>");    /* 6 */
   addstring(ini, "<div class=cpc>S</div>");    /* 7 */
   addstring(ini, "<div class=cy>A</div>");     /* 8 */
   addstring(ini, "<div class=cr>N</div>");     /* 9 */
   addstring(ini, "<div class=cg>D</div>");     /*10 */
   addstring(ini, "<div class=cr>DK</div>");     /* 11 */

:stage_1:

   self.prompt := "Type 'so be it' to continue: ";

   sendtext("\n<div class=cpw>GUILD PATH</div>\n" +
   "    You must choose the three " +
   "guilds you will join in this lifetime. Each of " +
   "the three guilds in this 'guild path' will have a common " +
   "thread linking them. For example, Fighters are linked to " +
   "Assassins, and Assassins are linked in turn to Thieves, so " +
   "a possible guild path would be Fighter/Assassin/Thief. " +
   "There are 81 possible combinations (your alignment choices " +
   "later may be affected by your path) and you will choose one of " +
   "these in a moment. When you finish rebirthing, you will " +
   "be able to practice in the first of the three guilds. Once " +
   "you reach level 40 again, you can practice in the first AND the " +
   "second guild. And once you reach level 80 you can practice " +
   "in all three simultaneously. If you wish to choose another " +
   "guild path, you will have to rebirth again." +
   "                     So now, let's choose YOUR path!\n\n", self);

   wait(SFB_CMD, (activator == self));
   block;

:stage_2:

   self.prompt := "Please select 1 - 10 or X to return to the last prompt: ";

   sendtext("\nPlease choose the parent guild (the first of the " +
            "three guilds which will make up your path):\n" +
            "      <div class=cpw>Guild Name          Alignment Options</div>\n" +
            "  <div class=cpw>1</div>)  Udgaard Fighter     (Good, Neutral, or Evil)\n" +
            "  <div class=cpw>2</div>)  Udgaard Thief       (Good, Neutral, or Evil)\n" +
            "  <div class=cpw>3</div>)  Udgaard Healer      (Good or Neutral)\n" +
            "  <div class=cpw>4</div>)  Udgaard Conjurer    (Good, Neutral, or Evil)\n" +
            "  <div class=cpw>5</div>)  Nymgaard Ranger     (Good or Neutral)\n" +
            "  <div class=cpw>6</div>)  Midgaard Paladin    (Good)\n" +
            "  <div class=cpw>7</div>)  Midgaard Sorcerer   (Good, Neutral, or Evil)\n" +
            "  <div class=cpw>8</div>)  Khorsabad Assassin  (Good, Neutral, or Evil)\n" +
            "  <div class=cpw>9</div>)  Necromancer         (Evil)\n" +
            "  <div class=cpw>10</div>) Nymgaard Druid      (Good, Neutral, or Evil)\n"+
            " <div class=cpw>11</div>)  Midgaard Dark Knight         (Evil)\n" ,
			self);

:stage_2a:
   wait(SFB_CMD, (activator == self));

   block;
   s := cmdstr;

   if (s == "X")
   {
      sendtext("Returning to previous menu.\n", self);
      goto stage_1;
   }
   else if (s == "1")
   {
/* FIGHTER */
      goto stage_3;
   }
   else if (s == "2")
   {
/* THIEF */
      goto stage_4;
   }
   else if (s == "3")
   {
/* HEALER */
      goto stage_5;
   }
   else if (s == "4")
   {
/* CONJURER */
      goto stage_6;
   }
   else if (s == "5")
   {
/* RANGER */
      goto stage_7;
   }
   else if (s == "6")
   {
/* PALADIN */
      goto stage_8;
   }
   else if (s == "7")
   {
/* SORCERER */
      goto stage_9;
   }
   else if (s == "8")
   {
/* ASSASSIN */
      goto stage_10;
   }
   else if (s == "9")
   {
/* NECROMANCER */
      goto stage_11;
   }
   else if (s == "10")
   {
/* DRUID */
      goto stage_12;
   }
   else if (s == "11")
   {
/* Dark Knight*/
      goto stage_13;
   }

   else
   {
      self.prompt := "No such guild is currently available to you. Please " +
               "select one of the guilds (1 - 11) or X: ";
      goto stage_2a;
   }

:stage_3:

   self.prompt := "Please select 1 - 15 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Fighter paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Udgaard Fighter    / Khorsabad Assassin / Udgaard Thief\n" +
   "  <div class=cpw>2</div>)  Udgaard Fighter    / Udgaard Conjurer   / Khorsabad Assassin\n" +
   "  <div class=cpw>3</div>)  Udgaard Fighter    / Midgaard Paladin   / Nymgaard Ranger\n" +
   "  <div class=cpw>4</div>)  Udgaard Fighter    / Midgaard Paladin   / Udgaard Healer\n" +
   "  <div class=cpw>5</div>)  Udgaard Fighter    / Midgaard Paladin   / Nymgaard Druid\n" +
   "  <div class=cpw>6</div>)  Udgaard Fighter    / Nymgaard Ranger    / Udgaard Healer\n" +
   "  <div class=cpw>7</div>)  Udgaard Fighter    / Nymgaard Ranger    / Nymgaard Druid\n" +
   "  <div class=cpw>8</div>)  Udgaard Fighter    / Nymgaard Ranger    / Udgaard Thief\n" +
   "  <div class=cpw>9</div>)  Udgaard Fighter    / Nymgaard Ranger    / Midgaard Paladin\n" +
   "  <div class=cpw>10</div>) Udgaard Fighter    / Udgaard Thief      / Nymgaard Ranger\n" +
   "  <div class=cpw>11</div>) Udgaard Fighter    / Udgaard Thief      / Khorsabad Assassin\n" +
   "  <div class=cpw>12</div>) Udgaard Fighter    / Udgaard Thief      / Udgaard Conjurer\n"
      +"  <div class=cpw>13</div>) Udgaard Fighter    / Nymgaard Ranger    / Midgaard Dark Knight\n"
      +"  <div class=cpw>14</div>) Udgaard Fighter    / Udgaard Thief      / Midgaard Dark Knight\n"
      +" <div class=cpw>15</div>) Udgaard Fighter     / Nymgaard Druid     / Midgaard Dark Knight\n",
     self);

:stage_3a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_30;

:stage_4:

   self.prompt :=  "Please select 1 - 11 or X to return to the last menu: ";
      sendtext("\nPlease choose one of the following Thief paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Udgaard Thief      / Khorsabad Assassin / Udgaard Fighter\n" +
   "  <div class=cpw>2</div>)  Udgaard Thief      / Khorsabad Assassin / Midgaard Sorcerer\n" +
   "  <div class=cpw>3</div>)  Udgaard Thief      / Udgaard Conjurer   / Khorsabad Assassin\n" +
   "  <div class=cpw>4</div>)  Udgaard Thief      / Udgaard Conjurer   / Midgaard Sorcerer\n" +
   "  <div class=cpw>5</div>)  Udgaard Thief      / Udgaard Fighter    / Khorsabad Assassin\n" +
   "  <div class=cpw>6</div>)  Udgaard Thief      / Udgaard Fighter    / Nymgaard Ranger\n" +
   "  <div class=cpw>7</div>)  Udgaard Thief      / Midgaard Sorcerer  / Udgaard Conjurer\n" +
   "  <div class=cpw>8</div>)  Udgaard Thief      / Nymgaard Ranger    / Udgaard Fighter\n" +
   "  <div class=cpw>9</div>)  Udgaard Thief      / Nymgaard Ranger    / Nymgaard Druid\n"
   	+" <div class=cpw>10</div>)  Udgaard Thief      / Nymgaard Ranger    / Midgaard Dark Knight\n"
	+" <div class=cpw>11</div>)  Udgaard Thief      /   Nymgaard Druid   / Midgaard Dark Knight\n",
    self);

:stage_4a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_40;

:stage_5:

   self.prompt := "Please select 1 - 8 or X to return to the last menu: ";
      sendtext("\nPlease choose one of the following Healer paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Udgaard Healer     / Udgaard Fighter    / Midgaard Paladin\n" +
   "  <div class=cpw>2</div>)  Udgaard Healer     / Udgaard Fighter    / Nymgaard Ranger\n" +
   "  <div class=cpw>3</div>)  Udgaard Healer     / Midgaard Paladin   / Udgaard Fighter\n" +
   "  <div class=cpw>4</div>)  Udgaard Healer     / Midgaard Paladin   / Nymgaard Druid\n" +
   "  <div class=cpw>5</div>)  Udgaard Healer     / Nymgaard Ranger    / Udgaard Fighter\n" +
   "  <div class=cpw>6</div>)  Udgaard Healer     / Nymgaard Ranger    / Nymgaard Druid\n" +
   "  <div class=cpw>7</div>)  Udgaard Healer     / Nymgaard Druid     / Nymgaard Ranger\n" +
   "  <div class=cpw>8</div>)  Udgaard Healer     / Nymgaard Druid     / Midgaard Paladin\n",
   self);

:stage_5a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_50;

:stage_6:

   self.prompt :=    "Please select 1 - 8 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Conjurer paths:\n" +
 "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
 "  <div class=cpw>1</div>)  Udgaard Conjurer   / Khorsabad Assassin / Udgaard Thief\n" +
 "  <div class=cpw>2</div>)  Udgaard Conjurer   / Khorsabad Assassin / Midgaard Sorcerer\n" +
 "  <div class=cpw>3</div>)  Udgaard Conjurer   / Midgaard Sorcerer  / Khorsabad Assassin\n" +
 "  <div class=cpw>4</div>)  Udgaard Conjurer   / Udgaard Thief      / Khorsabad Assassin\n" +
 "  <div class=cpw>5</div>)  Udgaard Conjurer   / Udgaard Thief      / Udgaard Fighter\n"
     +"  <div class=cpw>6</div>)  Udgaard Conjurer   / Midgaard Sorcerer  / Udgaard Fighter\n"
	+"  <div class=cpw>7</div>)  Udgaard Conjurer   / Udgaard Fighter    / Midgaard Sorcerer\n"
	+"  <div class=cpw>8</div>)  Udgaard Conjurer   / Midgaard Sorcerer  / Midgaard Dark Knight\n",
    self);

:stage_6a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_60;

:stage_7:

   self.prompt := "Please select 1 - 12 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Ranger paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Nymgaard Ranger    / Udgaard Healer     / Udgaard Fighter\n" +
   "  <div class=cpw>2</div>)  Nymgaard Ranger    / Udgaard Healer     / Midgaard Paladin\n" +
   "  <div class=cpw>3</div>)  Nymgaard Ranger    / Udgaard Healer     / Nymgaard Druid\n" +
   "  <div class=cpw>4</div>)  Nymgaard Ranger    / Udgaard Fighter    / Udgaard Healer\n" +
   "  <div class=cpw>5</div>)  Nymgaard Ranger    / Udgaard Fighter    / Midgaard Paladin\n" +
   "  <div class=cpw>6</div>)  Nymgaard Ranger    / Midgaard Paladin   / Udgaard Fighter\n" +
   "  <div class=cpw>7</div>)  Nymgaard Ranger    / Midgaard Paladin   / Nymgaard Druid\n" +
   "  <div class=cpw>8</div>)  Nymgaard Ranger    / Midgaard Paladin   / Udgaard Healer\n" +
   "  <div class=cpw>9</div>)  Nymgaard Ranger    / Nymgaard Druid     / Midgaard Paladin\n" +
   "  <div class=cpw>10</div>) Nymgaard Ranger    / Nymgaard Druid     / Udgaard Healer\n"
   	+"  <div class=cpw>11</div>) Nymgaard Ranger    / Nymgaard Druid     / Midgaard Dark Knight\n"
	+"  <div class=cpw>12</div>) Nymgaard Ranger    / Udgaard Fighter    / Midgaard Dark Knight\n",
   self);

:stage_7a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_70;

:stage_8:

   self.prompt := "Please select 1 - 9 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Paladin paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Midgaard Paladin   / Udgaard Fighter    / Udgaard Healer\n" +
   "  <div class=cpw>2</div>)  Midgaard Paladin   / Udgaard Fighter    / Nymgaard Ranger\n" +
   "  <div class=cpw>3</div>)  Midgaard Paladin   / Udgaard Healer     / Udgaard Fighter\n" +
   "  <div class=cpw>4</div>)  Midgaard Paladin   / Udgaard Healer     / Nymgaard Ranger\n" +
   "  <div class=cpw>5</div>)  Midgaard Paladin   / Udgaard Healer     / Nymgaard Druid\n" +
   "  <div class=cpw>6</div>)  Midgaard Paladin   / Nymgaard Ranger    / Udgaard Healer\n" +
   "  <div class=cpw>7</div>)  Midgaard Paladin   / Nymgaard Ranger    / Nymgaard Druid\n" +
   "  <div class=cpw>8</div>)  Midgaard Paladin   / Nymgaard Druid     / Udgaard Healer\n" +
   "  <div class=cpw>9</div>)  Midgaard Paladin   / Nymgaard Druid     / Nymgaard Ranger\n",
    self);

:stage_8a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_80;

:stage_9:

   self.prompt := "Please select 1 - 9 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Sorcerer paths:\n" +
   "       <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Midgaard Sorcerer  / Khorsabad Assassin / Udgaard Conjurer\n" +
   "  <div class=cpw>2</div>)  Midgaard Sorcerer  / Khorsabad Assassin / Udgaard Thief\n" +
   "  <div class=cpw>3</div>)  Midgaard Sorcerer  / Udgaard Conjurer   / Khorsabad Assassin\n" +
   "  <div class=cpw>4</div>)  Midgaard Sorcerer  / Udgaard Conjurer   / Udgaard Thief\n" +
   "  <div class=cpw>5</div>)  Midgaard Sorcerer  / Udgaard Thief      / Khorsabad Assassin\n" +
   "  <div class=cpw>6</div>)  Midgaard Sorcerer  / Udgaard Thief      / Udgaard Conjurer\n"
   +"  <div class=cpw>7</div>)  Midgaard Sorcerer  / Udgaard Fighter    / Udgaard Conjurer\n"
   +"  <div class=cpw>8</div>)  Midgaard Sorcerer  / Udgaard Conjurer   / Udgaard Fighter\n"
   +"  <div class=cpw>9</div>)  Midgaard Sorcerer  / Udgaard Conjurer   / Midgaard Dark Knight\n",
   self);

:stage_9a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_90;

:stage_10:

   self.prompt := "Please select 1 - 9 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Assassin paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Khorsabad Assassin / Udgaard Conjurer   / Midgaard Sorcerer\n" +
   "  <div class=cpw>2</div>)  Khorsabad Assassin / Udgaard Conjurer   / Udgaard Thief\n" +
   "  <div class=cpw>3</div>)  Khorsabad Assassin / Udgaard Fighter    / Udgaard Conjurer\n" +
   "  <div class=cpw>4</div>)  Khorsabad Assassin / Midgaard Sorcerer  / Udgaard Conjurer\n" +
   "  <div class=cpw>5</div>)  Khorsabad Assassin / Midgaard Sorcerer  / Udgaard Thief\n" +
   "  <div class=cpw>6</div>)  Khorsabad Assassin / Udgaard Thief      / Udgaard Conjurer\n" +
   "  <div class=cpw>7</div>)  Khorsabad Assassin / Udgaard Thief      / Udgaard Fighter\n" +
   "  <div class=cpw>8</div>)  Khorsabad Assassin / Udgaard Thief      / Nymgaard Ranger\n" +
   "  <div class=cpw>9</div>)  Khorsabad Assassin / Nymgaard Ranger    / Udgaard Thief\n",
   self);

:stage_10a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_100;

:stage_11:

   self.prompt := "Please select 1 - 8 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Necromancer paths:\n" +
   "      <div class=cpw>First Guild        / Second Guild       / Third Guild</div>\n" +
"  <div class=cpw>1</div>)  Necromancer        / Udgaard Fighter    / Khorsabad Assassin\n" +
"  <div class=cpw>2</div>)  Necromancer        / Udgaard Fighter    / Nymgaard Druid\n" +
"  <div class=cpw>3</div>)  Necromancer        / Nymgaard Druid     / Udgaard Fighter\n"
   +"  <div class=cpw>4</div>)  Necromancer        / Nymgaard Druid     / Udgaard Thief\n"
   +"  <div class=cpw>5</div>)  Necromancer        / Udgaard Fighter    / Udgaard Thief\n"
   +"  <div class=cpw>6</div>)  Necromancer        / Udgaard Fighter    / Midgaard Dark Knight\n"
   +"  <div class=cpw>7</div>)  Necromancer        / Nymgaard Druid     / Midgaard Dark Knight\n"
   +"  <div class=cpw>8</div>)  Necromancer        / Udgaard Thief  / Midgaard Dark Knight\n",
   self);

:stage_11a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_110;

:stage_12:

   self.prompt := "Please select 1 - 12 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Druid paths:\n" +
   "      <div class=cpw>First Guild          / Second Guild       / Third Guild</div>\n" +
   "  <div class=cpw>1</div>)  Nymgaard Druid    / Udgaard Healer     / Nymgaard Ranger\n" +
   "  <div class=cpw>2</div>)  Nymgaard Druid    / Udgaard Healer     / Midgaard Paladin\n" +
   "  <div class=cpw>3</div>)  Nymgaard Druid    / Udgaard Healer     / Udgaard Fighter\n" +
   "  <div class=cpw>4</div>)  Nymgaard Druid    / Nymgaard Ranger    / Udgaard Fighter\n" +
   "  <div class=cpw>5</div>)  Nymgaard Druid    / Nymgaard Ranger    / Udgaard Healer\n" +
   "  <div class=cpw>6</div>)  Nymgaard Druid    / Nymgaard Ranger    / Midgaard Paladin\n" +
   "  <div class=cpw>7</div>)  Nymgaard Druid    / Midgaard Paladin   / Udgaard Fighter\n" +
   "  <div class=cpw>8</div>)  Nymgaard Druid    / Midgaard Paladin   / Nymgaard Ranger\n" +
   "  <div class=cpw>9</div>)  Nymgaard Druid    / Midgaard Paladin   / Udgaard Healer\n" +
   "  <div class=cpw>10</div>) Nymgaard Druid    / Necromancer        / Udgaard Fighter\n"
         +" <div class=cpw>11</div>) Nymgaard Druid    x/  Necromancer        / Midgaard Dark Knight\n"
   +" <div class=cpw>12</div>) Nymgaard Druid    / Nymgaard Ranger    / Midgaard Dark Knight\n",
   self);

:stage_12a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_120;

   :stage_13:

   self.prompt := "Please select 1 - 13 or X to return to the last menu: ";

      sendtext("\nPlease choose one of the following Dark Knight paths:\n"
	     +"      <div class=cpw>First Guild              / Second Guild       / Third Guild</div>\n"
   +"  <div class=cpw>1</div>)  Midgaard Dark Knight  / Udgaard Fighter    / Nymgaard Ranger\n"
   +"  <div class=cpw>2</div>)  Midgaard Dark Knight  / Udgaard Fighter    / Nymgaard Druid\n"
       +"  <div class=cpw>3</div>)  Midgaard Dark Knight  / Udgaard Fighter    / Necromancer\n"
   +"  <div class=cpw>4</div>)  Midgaard Dark Knight  / Udgaard Thief      / Udgaard Fighter\n"
   +"  <div class=cpw>5</div>)  Midgaard Dark Knight  / Udgaard Thief      / Nymgaard Ranger\n"
   +"  <div class=cpw>6</div>)  Midgaard Dark Knight  / Udgaard Thief      / Nymgaard Druid\n"
   +"  <div class=cpw>7</div>)  Midgaard Dark Knight  / Udgaard Thief      / Necromancer\n"
   +"  <div class=cpw>8</div>)  Midgaard Dark Knight  / Nymgaard Druid     / Nymgaard Ranger\n"
   +"  <div class=cpw>9</div>)  Midgaard Dark Knight  / Nymgaard Druid     / Necromancer\n"
   +" <div class=cpw>10</div>)  Midgaard Dark Knight  / Nymgaard Ranger    / Nymgaard Druid\n"
   +" <div class=cpw>11</div>)  Midgaard Dark Knight  / Nymgaard Ranger    / Necromancer\n"
   +" <div class=cpw>12</div>)  Midgaard Dark Knight  / Necromancer        / Nymgaard Ranger\n"
   +" <div class=cpw>13</div>)  Midgaard Dark Knight  / Necromancer        / Nymgaard Druid\n",
   self);

:stage_13a:

   wait(SFB_CMD, (activator == self));
   block;

   s := cmdstr;

   goto stage_130;




:stage_30:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Fighter / Assassin / Thief.\n", self);

         g1 := 1;
         g2 := 8;
         g3 := 2;

         goto fin;
      }
      else if (s == "2")
      {
         sendtext("\nYou are now a Fighter / Conjurer / Assassin.\n", self);
         g1 := 1;
         g2 := 4;
         g3 := 8;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Fighter / Paladin / Ranger.\n", self);
         g1 := 1;
         g2 := 6;
         g3 := 5;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Fighter / Paladin / Healer.\n", self);
         g1 := 1;
         g2 := 6;
         g3 := 3;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Fighter / Paladin / Druid.\n", self);
         g1 := 1;
         g2 := 6;
         g3 := 10;

         goto fin;
      }
      else if (s == "6")
      {
         sendtext("\nYou are now a Fighter / Ranger / Healer.\n", self);
         g1 := 1;
         g2 := 5;
         g3 := 3;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Fighter / Ranger / Druid.\n", self);
         g1 := 1;
         g2 := 5;
         g3 := 10;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Fighter / Ranger / Thief.\n", self);
         g1 := 1;
         g2 := 5;
         g3 := 2;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Fighter / Ranger / Paladin.\n", self);
         g1 := 1;
         g2 := 5;
         g3 := 6;

         goto fin;
      }

      else if (s == "10")
      {
         sendtext("\nYou are now a Fighter / Thief / Ranger.\n", self);
         g1 := 1;
         g2 := 2;
         g3 := 5;

         goto fin;
      }

      else if (s == "11")
      {
         sendtext("\nYou are now a Fighter / Thief / Assassin.\n", self);
         g1 := 1;
         g2 := 2;
         g3 := 8;

         goto fin;
      }

      else if (s == "12")
      {
         sendtext("\nYou are now a Fighter / Thief / Conjurer.\n", self);
         g1 := 1;
         g2 := 2;
         g3 := 4;

         goto fin;
      }
      else if (s == "13")
      {
         sendtext("\nYou are now a Fighter / Ranger / Dark Knight.\n", self);
         g1 := 1;
         g2 := 5;
         g3 := 11;

		          goto fin;
      }
      else if (s == "14")
      {
         sendtext("\nYou are now a Fighter / Thief / Dark Knight\n", self);
         g1 := 1;
         g2 := 2;
         g3 := 11;

		          goto fin;
      }
	        else if (s == "15")
      {
         sendtext("\nYou are now a Fighter / Druid / Dark Knight.\n", self);
         g1 := 1;
         g2 := 10;
         g3 := 11;
         goto fin;
		 }

      else
      {
        self.prompt := "No such option. Please select 1 - 13 or X: ";
        goto stage_3a;
      }

:stage_40: /* The peleton is not far behind the tete de la course */

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Thief / Assassin / Fighter.\n", self);

         g1 := 2;
         g2 := 8;
         g3 := 1;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Thief / Assassin / Sorcerer.\n", self);

         g1 := 2;
         g2 := 8;
         g3 := 7;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Thief / Conjurer / Assassin.\n", self);

         g1 := 2;
         g2 := 4;
         g3 := 8;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Thief / Conjurer / Sorcerer.\n", self);

         g1 := 2;
         g2 := 4;
         g3 := 7;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Thief / Fighter / Assassin.\n", self);

         g1 := 2;
         g2 := 1;
         g3 := 8;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Thief / Fighter / Ranger.\n", self);

         g1 := 2;
         g2 := 1;
         g3 := 5;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Thief / Sorcerer / Conjurer.\n", self);

         g1 := 2;
         g2 := 7;
         g3 := 4;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Thief / Ranger / Fighter.\n", self);

         g1 := 2;
         g2 := 5;
         g3 := 1;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Thief / Ranger / Druid.\n", self);

         g1 := 2;
         g2 := 5;
         g3 := 10;

         goto fin;
      }
      else if (s == "10")
      {
         sendtext("\nYou are now a Thief / Ranger / Dark Knight.\n", self);

         g1 := 2;
         g2 := 5;
         g3 := 11;

		          goto fin;
      }
      else if (s == "11")
      {
         sendtext("\nYou are now a Thief / Druid / Dark Knight.\n", self);

         g1 := 2;
         g2 := 10;
         g3 := 11;

		          goto fin;
      }

      else
      {
        self.prompt := "No such option. Please select 1 - 11 or X: ";
        goto stage_4a;
      }

:stage_50:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Healer / Fighter / Paladin.\n", self);

         g1 := 3;
         g2 := 1;
         g3 := 6;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Healer / Fighter / Ranger.\n", self);

         g1 := 3;
         g2 := 1;
         g3 := 5;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Healer / Paladin / Fighter.\n", self);

         g1 := 3;
         g2 := 6;
         g3 := 1;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Healer / Paladin/ Druid.\n", self);

         g1 := 3;
         g2 := 6;
         g3 := 10;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Healer / Ranger / Fighter.\n", self);

         g1 := 3;
         g2 := 5;
         g3 := 1;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Healer / Ranger / Druid.\n", self);

         g1 := 3;
         g2 := 5;
         g3 := 10;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Healer / Druid / Ranger.\n", self);

         g1 := 3;
         g2 := 10;
         g3 := 5;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Healer / Druid / Paladin.\n", self);

         g1 := 3;
         g2 := 10;
         g3 := 6;

         goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 8 or X: ";
        goto stage_5a;
      }

:stage_60:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Conjurer / Assassin / Thief.\n", self);

         g1 := 4;
         g2 := 8;
         g3 := 2;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Conjurer / Assassin / Sorcerer.\n", self);

         g1 := 4;
         g2 := 8;
         g3 := 7;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Conjurer / Sorcerer / Assassin.\n", self);

         g1 := 4;
         g2 := 7;
         g3 := 8;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Conjurer / Thief / Assassin.\n", self);

         g1 := 4;
         g2 := 2;
         g3 := 8;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Conjurer / Thief / Fighter.\n", self);

         g1 := 4;
         g2 := 2;
         g3 := 1;

         goto fin;
      }
                              else if (s == "6")
      {
         sendtext("\nYou are now a Conjurer / Sorcerer / Fighter.\n", self);

         g1 := 4;
         g2 := 7;
         g3 := 1;

		          goto fin;
      }
      else if (s == "7")
      {
         sendtext("\nYou are now a Conjurer / Fighter / Sorcerer.\n", self);

         g1 := 4;
         g2 := 1;
         g3 := 7;

		          goto fin;
      }
      else if (s == "8")
      {
         sendtext("\nYou are now a Conjurer / Sorcerer / Dark Knight\n", self);

         g1 := 4;
         g2 := 7;
         g3 := 11;

		          goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 8 or X: ";
        goto stage_6a;
      }

:stage_70:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Ranger / Healer / Fighter.\n", self);

         g1 := 5;
         g2 := 3;
         g3 := 1;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Ranger / Healer / Paladin.\n", self);

         g1 := 5;
         g2 := 3;
         g3 := 6;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Ranger / Healer / Druid.\n", self);

         g1 := 5;
         g2 := 3;
         g3 := 10;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Ranger / Fighter / Healer.\n", self);

         g1 := 5;
         g2 := 1;
         g3 := 3;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Ranger / Fighter / Paladin.\n", self);

         g1 := 5;
         g2 := 1;
         g3 := 6;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Ranger / Paladin / Fighter.\n", self);

         g1 := 5;
         g2 := 6;
         g3 := 1;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Ranger / Paladin / Druid.\n", self);

         g1 := 5;
         g2 := 6;
         g3 := 10;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Ranger / Paladin / Healer.\n", self);

         g1 := 5;
         g2 := 6;
         g3 := 3;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Ranger / Druid / Paladin.\n", self);

         g1 := 5;
         g2 := 10;
         g3 := 6;

         goto fin;
      }

      else if (s == "10")
      {
         sendtext("\nYou are now a Ranger / Druid / Healer.\n", self);

         g1 := 5;
         g2 := 10;
         g3 := 3;

         goto fin;
      }
      else if (s == "11")
      {
         sendtext("\nYou are now a Ranger / Druid / Dark Knight.\n", self);

         g1 := 5;
         g2 := 10;
         g3 := 11;

		          goto fin;
      }
      else if (s == "12")
      {
         sendtext("\nYou are now a Ranger / Fighter / Dark Knight.\n",self);


         g1 := 5;
         g2 := 1;
         g3 := 11;
		          goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 12 or X: ";
        goto stage_7a;
      }

:stage_80:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Paladin / Fighter / Healer.\n", self);

         g1 := 6;
         g2 := 1;
         g3 := 3;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Paladin / Fighter / Ranger.\n", self);

         g1 := 6;
         g2 := 1;
         g3 := 5;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Paladin / Healer / Fighter.\n", self);

         g1 := 6;
         g2 := 3;
         g3 := 1;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Paladin / Healer / Ranger.\n", self);

         g1 := 6;
         g2 := 3;
         g3 := 5;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Paladin / Healer / Druid.\n", self);

         g1 := 6;
         g2 := 3;
         g3 := 10;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Paladin / Ranger / Healer.\n", self);

         g1 := 6;
         g2 := 5;
         g3 := 3;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Paladin / Ranger / Druid.\n", self);

         g1 := 6;
         g2 := 5;
         g3 := 10;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Paladin / Druid / Healer.\n", self);

         g1 := 6;
         g2 := 10;
         g3 := 3;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Paladin / Druid / Ranger.\n", self);

         g1 := 6;
         g2 := 10;
         g3 := 5;

         goto fin;
      }

      else
      {
        self.prompt := "No such option. Please select 1 - 9 or X: ";
        goto stage_8a;
      }

:stage_90:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Sorcerer / Assassin / Conjurer.\n", self);

         g1 := 7;
         g2 := 8;
         g3 := 4;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Sorcerer / Assassin / Thief.\n", self);

         g1 := 7;
         g2 := 8;
         g3 := 2;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Sorcerer / Conjurer / Assassin.\n", self);

         g1 := 7;
         g2 := 4;
         g3 := 8;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Sorcerer / Conjurer / Thief.\n", self);

         g1 := 7;
         g2 := 4;
         g3 := 2;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Sorcerer / Thief / Assassin.\n", self);

         g1 := 7;
         g2 := 2;
         g3 := 8;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Sorcerer / Thief / Conjurer.\n", self);

         g1 := 7;
         g2 := 2;
         g3 := 4;

         goto fin;
      }
                            else if (s == "7")
      {
         sendtext("\nYou are now a Sorcerer / Fighter / Conjurer.\n", self);

         g1 := 7;
         g2 := 1;
         g3 := 4;

		          goto fin;
      }
                                                        else if (s == "8")
      {
         sendtext("\nYou are now a Sorcerer / Conjurer / Fighter.\n", self);

         g1 := 7;
         g2 := 4;
         g3 := 1;

		          goto fin;
      }
                                                        else if (s == "9")
      {
         sendtext("\nYou are now a Sorcerer / Conjurer / Dark Knight.\n", self);

         g1 := 7;
         g2 := 4;
         g3 := 11;

		          goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 9 or X: ";
        goto stage_9a;
      }

:stage_100:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Assassin / Conjurer / Sorcerer.\n", self);

         g1 := 8;
         g2 := 4;
         g3 := 7;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Assassin / Conjurer / Thief.\n", self);

         g1 := 8;
         g2 := 4;
         g3 := 2;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Assassin / Fighter / Conjurer.\n", self);

         g1 := 8;
         g2 := 1;
         g3 := 4;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Assassin / Sorcerer / Conjurer.\n", self);

         g1 := 8;
         g2 := 7;
         g3 := 4;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Assassin / Sorcerer / Thief.\n", self);

         g1 := 8;
         g2 := 7;
         g3 := 2;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Assassin / Thief / Conjurer.\n", self);

         g1 := 8;
         g2 := 2;
         g3 := 4;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Assassin / Thief / Fighter.\n", self);

         g1 := 8;
         g2 := 2;
         g3 := 1;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Assassin / Thief / Ranger.\n", self);

         g1 := 8;
         g2 := 2;
         g3 := 5;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Assassin / Ranger / Thief.\n", self);

         g1 := 8;
         g2 := 5;
         g3 := 2;

         goto fin;
      }

      else
      {
        self.prompt := "No such option. Please select 1 - 9 or X: ";
        goto stage_10a;
      }

:stage_110:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Necromancer / Fighter / Assassin.\n",
self);

         g1 := 9;
         g2 := 1;
         g3 := 8;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Necromancer / Fighter / Druid.\n", self);

         g1 := 9;
         g2 := 1;
         g3 := 10;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Necromancer / Druid / Fighter.\n", self);

         g1 := 9;
         g2 := 10;
         g3 := 1;

         goto fin;
      }
      else if (s == "4")
      {
         sendtext("\nYou are now a Necromancer / Druid / Thief.\n", self);

         g1 := 9;
         g2 := 10;
         g3 := 2;
		          goto fin;
      }
      else if (s == "5")
      {
         sendtext("\nYou are now a Necromancer / Fighter / Thief.\n", self);

         g1 := 9;
         g2 := 1;
         g3 := 2;
		          goto fin;
      }
      else if (s == "6")
      {
         sendtext("\nYou are now a Necromancer / Fighter / Dark KnightFighter.\n", self);

         g1 := 9;
         g2 := 1;
         g3 := 11;

		          goto fin;
      }
      else if (s == "7")
      {
         sendtext("\nYou are now a Necromancer / Druid / Dark Knight.\n", self);

         g1 := 9;
         g2 := 10;
         g3 := 11;
		          goto fin;
      }
      else if (s == "8")
      {
         sendtext("\nYou are now a Necromancer / Thief / Dark Knight.\n",self);

         g1 := 9;
         g2 := 2;
         g3 := 11;
		          goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 8 or X: ";
        goto stage_11a;
      }

:stage_120:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {
         sendtext("\nYou are now a Druid / Healer / Ranger.\n", self);

         g1 := 10;
         g2 := 3;
         g3 := 5;

         goto fin;
      }

      else if (s == "2")
      {
         sendtext("\nYou are now a Druid / Healer / Paladin.\n", self);

         g1 := 10;
         g2 := 3;
         g3 := 6;

         goto fin;
      }

      else if (s == "3")
      {
         sendtext("\nYou are now a Druid / Healer / Fighter.\n", self);

         g1 := 10;
         g2 := 3;
         g3 := 1;

         goto fin;
      }

      else if (s == "4")
      {
         sendtext("\nYou are now a Druid / Ranger / Fighter.\n", self);

         g1 := 10;
         g2 := 5;
         g3 := 1;

         goto fin;
      }

      else if (s == "5")
      {
         sendtext("\nYou are now a Druid / Ranger / Healer.\n", self);

         g1 := 10;
         g2 := 5;
         g3 := 3;

         goto fin;
      }

      else if (s == "6")
      {
         sendtext("\nYou are now a Druid / Ranger / Paladin.\n", self);

         g1 := 10;
         g2 := 5;
         g3 := 6;

         goto fin;
      }

      else if (s == "7")
      {
         sendtext("\nYou are now a Druid / Paladin / Fighter.\n", self);

         g1 := 10;
         g2 := 6;
         g3 := 1;

         goto fin;
      }

      else if (s == "8")
      {
         sendtext("\nYou are now a Druid / Paladin / Ranger.\n", self);

         g1 := 10;
         g2 := 6;
         g3 := 5;

         goto fin;
      }

      else if (s == "9")
      {
         sendtext("\nYou are now a Druid / Paladin / Healer.\n", self);

         g1 := 10;
         g2 := 6;
         g3 := 3;

         goto fin;
      }

      else if (s == "10")
      {
         sendtext("\nYou are now a Druid / Necromancer / Fighter.\n", self);

         g1 := 10;
         g2 := 9;
         g3 := 1;

         goto fin;
      }
                              else if (s == "11")
      {
         sendtext("\nYou are now a Druid / Necromancer / Dark Knight.\n", self);

         g1 := 10;
         g2 := 9;
         g3 := 11;
		          goto fin;
      }
      else if (s == "12")
      {
         sendtext("\nYou are now a Druid / Ranger / Dark Knight.\n", self);

         g1 := 10;
         g2 := 5;
         g3 := 11;
		          goto fin;
      }
      else
      {
        self.prompt := "No such option. Please select 1 - 12 or X: ";
        goto stage_12a;
      }


:stage_130:

      if (s == "X")
      {
         sendtext("Returning to previous menu.\n", self);
         goto stage_2;
      }
      else if (s == "1")
      {

         sendtext("\nYou are now a Dark Knight / Fighter / Ranger.\n",self);
         g1 := 11;
         g2 := 1;
         g3 := 5;

		 		          goto fin;
      }
      else if (s == "2")
      {

         sendtext("\nYou are now a Dark Knight / Fighter / Druid.\n",self);
         g1 := 11;
         g2 := 1;
         g3 := 10;
		          goto fin;
				  }
      else if (s == "3")
      {

         sendtext("\nYou are now a Dark Knight / Fighter / Necromancer.\n",self);
         g1 := 11;
         g2 := 1;
         g3 := 9;
		          goto fin;
				  }
      else if (s == "4")
      {

         sendtext("\nYou are now a Dark Knight / Thief / Fighter.\n",self);
         g1 := 11;
         g2 := 2;
         g3 := 1;
		 		          goto fin;
      }
      else if (s == "5")
      {

         sendtext("\nYou are now a Dark Knight / Thief / Ranger.\n",self);
         g1 := 11;
         g2 := 2;
         g3 := 5;
		 		          goto fin;
		       }
      else if (s == "6")
      {

         sendtext("\nYou are now a Dark Knight / Thief / Druid.\n",self);
         g1 := 11;
         g2 := 2;
         g3 := 10;
		 		          goto fin;
						  }
      else if (s == "7")
      {

         sendtext("\nYou are now a Dark Knight / Thief / Necromancer\n",self);
         g1 := 11;
         g2 := 2;
         g3 := 9;
		 		          goto fin;
      }
      else if (s == "8")
      {

         sendtext("\nYou are now a Dark Knight / Druid / Ranger.\n",self);
         g1 := 11;
         g2 := 10;
         g3 := 5;
		 		          goto fin;
      }
      else if (s == "9")
      {

         sendtext("\nYou are now a Dark Knight / Druid / Necromancer.\n",self);
         g1 := 11;
         g2 := 10;
         g3 := 9;
		 		          goto fin;
      }
      else if (s == "10")
      {

         sendtext("\nYou are now a Dark Knight / Ranger / Druid.\n",self);
         g1 := 11;
         g2 := 5;
         g3 := 10;
		 		          goto fin;
      }
      else if (s == "11")
      {

         sendtext("\nYou are now a Dark Knight / Ranger / Necromancer.\n",self);
         g1 := 11;
         g2 := 5;
         g3 := 9;
		 		          goto fin;
      }
      else if (s == "12")
      {

         sendtext("\nYou are now a Dark Knight / Necromancer / Ranger.\n",self);
         g1 := 11;
         g2 := 9;
         g3 := 5;
		 		          goto fin;
      }
      else if (s == "13")
      {

         sendtext("\nYou are now a Dark Knight / Necromancer / Druid.\n",self);
         g1 := 11;
         g2 := 9;
         g3 := 10;
		          goto fin;
}

      else
      {
        self.prompt := "No such option. Please select 1 - 13 or X: ";
        goto stage_13a;
      }


:fin:

      self.prompt := ">";
      addstring(data_list, "$path");
      addstring(data_list, gug.[g1]);
      addstring(data_list, gug.[g2]);
      addstring(data_list, gug.[g3]);
      addstring(data_list, "1");
      addstring(data_list, "0");
      addstring(data_list, "0");
      addstring(data_list, "1");

      addextra(self.quests, data_list, ini.[g1] + " / " + ini.[g2] + " / " +
               ini.[g3] + "&[default]");

  /*    self.guild := ini.[g1] + " / " + ini.[g2] + " / " + ini.[g3] +
                 "&[default]";*/
      self.guild := gug.[g1];

      data_list := null;

      addstring(data_list, "$" + gug.[g1]);
      addstring(data_list, "1");
      addstring(data_list, "$guild");
      addextra(self.quests, data_list, itoa(realtime - 1000));

:GET_ALIGNMENT:

   if ((self.guild == "Udgaard Healer") or
       (self.guild == "Nymgaard Ranger"))
     cat := 1; /* Good and Neutral */

   else if (self.guild == "Midgaard Paladin")
     cat := 2;

   else if ((self.guild == "Necromancer") or (self.guild ==GUILD_KNIGHT))
     cat := 3;

   else
     cat := 4; /* Player's choice */

   if (cat == 1)
   {
     self.prompt := "Please select 1, 2 or Help: ";
     sendtext("\nPlease choose your personality:\n"+
              "  <div class=cpw>1</div>) A saint             (Good)\n"+
              "  <div class=cpw>2</div>) Who cares?          (Neutral)\n", self);
   }
   else if (cat == 2)
   {
     self.prompt := "Please select 1 or Help: ";
     sendtext("\nPlease choose your personality (Only 1 choice):\n"+
              "  <div class=cpw>1</div>) A saint             (Good)\n", self);
   }
   else if (cat == 3)
   {
     self.prompt := "Please select 3 or Help: ";
     sendtext("\nPlease choose your personality (Only 1 choice):\n"+
              "  <div class=cpw>3</div>) The devil's brother (Evil)\n", self);
   }
   else
   {
     self.prompt := "Please select 1, 2, 3 or Help: ";
     sendtext("\nPlease choose your personality:\n"+
              "  <div class=cpw>1</div>) A saint             (Good)\n"+
              "  <div class=cpw>2</div>) Who cares?          (Neutral)\n"+
              "  <div class=cpw>3</div>) The devil's brother (Evil)\n", self);
   }
:ASK_AGAIN:

   wait(SFB_CMD, activator == self);
   block;

   s := cmdstr;

   if ((s == "1") and (cat != 3))
   {
      sendtext("You are now a saint.\n\n", self);
      self.alignment := 850;
   }
   else if ((s == "2") and ((cat != 2) and (cat != 3)))
   {
      sendtext("Who cares about it anyway?\n\n", self);
      self.alignment := 0;
   }
   else if ((s == "3") and ((cat != 1) and (cat !=2)))
   {
      sendtext("So be it...\n\n", self);
      self.alignment := -850;
   }
   else
   {
      if (cat == 1)
        self.prompt := "No such personality, please select 1, 2 or Help: ";
      else if (cat == 2)
        self.prompt := "No such personality, please select 1 or Help: ";
      else if (cat == 3)
        self.prompt := "No such personality, please select 3 or Help: ";
      else
        self.prompt := "No such personality, please select 1, 2, 3 " +
                    "or Help: ";
      goto ASK_AGAIN;
   }

   if (not(dilfind("cmd_interpreter@commands", self)))
      dilcopy("cmd_interpreter@commands", self);

   return;
}
dilend /* guild_choose */

dilbegin rebob@rebirth(); /* Put me back in the BoB at level 50 */

code
{
   heartbeat := PULSE_SEC * 2000;

:start:
   wait(SFB_TICK, TRUE);
   if (self.level >= 50)
   {
      set(self.pcflags, PC_PK_RELAXED);
      subextra(self.quests, "$Re-Bob");
      act("You are now back in the book of blood at level 50, after " +
          "your rebirth.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto the_end;
   }
   else goto start;

:the_end:
   quit;
}
dilend /*rebob*/

/*
dilbegin aware no_commands();

code
{
   interrupt(SFB_MSG, ((activator == self) and ("rebirth_done" in argument)),
             end);
:start:
   wait(SFB_CMD, ((activator == self) and
(not(command("1") or command("2") or command("3") or command("4") or
command("5") or command("6") or command("7") or command("8") or
command("9") or command("10") or command("11"))) and
                  (activator.level < IMMORTAL_LEVEL)));
   block;
   act("That command is not available to you until you finish rebirthing.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto start;

:end:
   quit;
}
dilend */

dilbegin sacrifice(arg : string); /* Sacrifice a head */

var
   head       : unitptr;    /* Sacrifice it yeah yeah */
   temp       : unitptr;

   expd       : extraptr;   /* REBIRTH_DATA in self */

   i          : integer;    /* Need an integer */
   j          : integer;    /* Need an integer */
   k          : integer;    /* Need an integer */

   data_list  : stringlist; /* expd.names */
   new_list   : stringlist;

   tstr       : string;
   tstr2      : string;
   tot_num    : string;     /* I hate dil */
   demi_score : string;
   god_score  : string;
   fight_left : string;
   thief_left : string;
   heal_left  : string;
   conj_left  : string;
   palad_left : string;
   sorc_left  : string;
   ass_left   : string;
   necro_left : string;
   rang_left  : string;
   druid_left : string;
   knight_left :string;
   slist      : stringlist;

code
{
:init:
   heartbeat := PULSE_SEC*1;
   block;
/*
act("Sacrificing has been taken offline temporarily so we can ensure that "+
    "everyone's rebirth data will be intact while we work on some small "+
    "bugs.  Apologies for the inconvenience...",
     A_ALWAYS, self, null, null, TO_CHAR);
quit;
*/

   if (self.outside.nameidx != "shrine_1")
   {
      act("You cannot do that here. You must be in the shrine.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   if (arg == "")
     tstr := "head";
   else if (not(arg in "head"))
   {
      act("You may only sacrifice heads!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }
   else tstr := "head";

   head := findunit(self, tstr, FIND_UNIT_INVEN, null);

   if (head == null)
   {
      act("You cannot find it!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   if (head.objecttype != ITEM_TRASH)
   {
      act("That's not the right kind of head!",
          A_ALWAYS, self, null, null, TO_CHAR);
   }
  /*
   tstr := head.outside_descr;

   tstr2 := getword(tstr);
   tstr2 := getword(tstr);
   tstr2 := getword(tstr);
   tstr2 := getword(tstr);
   tstr := getword(tstr);

   temp := findunit(self, "corpse of " + tstr, FIND_UNIT_WORLD, null);

   if (temp.name == ("corpse of " + tstr))
*/
   if (head.value[2] == 1)
   {
      act("You cannot sacrifice the heads of players!" +
          "\nYou are granted no sacrifice points for that sacrifice!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   if (not(SAC_POINTS in self.extra))
   {
    expd := REBIRTH_DATA in self.quests;
     if(expd == null) goto newfish;

    data_list := expd.names;

     if(length(data_list) < 15)
      {
       act("<div class=cpr>You must contact an admin to restore your rebirth "+
           "data.&[default]",A_ALWAYS, self, null, null, TO_CHAR);
       quit;
      }
       tot_num    := data_list.[1];  /* THIS IS THE OLD REBIRTH DATA */
       fight_left := data_list.[2];
       thief_left := data_list.[3];
       heal_left  := data_list.[4];
       conj_left  := data_list.[5];
       palad_left := data_list.[6];
       sorc_left  := data_list.[7];
       ass_left   := data_list.[8];
       necro_left := data_list.[9];
       rang_left  := data_list.[10];
       druid_left := data_list.[11];
	   knight_left:= data_list.[12];
       demi_score := data_list.[13];
       god_score  := data_list.[14];

       slist := {PC_REBIRTHS};
       addstring(slist, tot_num);
       addextra(self.extra, slist, "Total Rebirths");

     if(fight_left != "0 0")
      {
       slist := {F_REBIRTHS};
       addstring(slist, fight_left);
       addextra(self.extra, slist, "Fighter Rebirths");
      }
     if(thief_left != "0 0")
      {
       slist := {T_REBIRTHS};
       addstring(slist, thief_left);
       addextra(self.extra, slist, "Thief Rebirths");
      }
     if(heal_left != "0 0")
      {
       slist := {H_REBIRTHS};
       addstring(slist, heal_left);
       addextra(self.extra, slist, "Healer Rebirths");
      }
     if(conj_left != "0 0")
      {
       slist := {C_REBIRTHS};
       addstring(slist, conj_left);
       addextra(self.extra, slist, "Conjurer Rebirths");
      }
     if(rang_left != "0 0")
      {
       slist := {R_REBIRTHS};
       addstring(slist, rang_left);
       addextra(self.extra, slist, "Ranger Rebirths");
      }
     if(palad_left != "0 0")
      {
       slist := {P_REBIRTHS};
       addstring(slist, palad_left);
       addextra(self.extra, slist, "Paladin Rebirths");
      }
     if(sorc_left != "0 0")
      {
       slist := {S_REBIRTHS};
       addstring(slist, sorc_left);
       addextra(self.extra, slist, "Sorcerer Rebirths");
      }
     if(ass_left != "0 0")
      {
       slist := {A_REBIRTHS};
       addstring(slist, ass_left);
       addextra(self.extra, slist, "Assassin Rebirths");
      }
     if(necro_left != "0 0")
      {
       slist := {N_REBIRTHS};
       addstring(slist, necro_left);
       addextra(self.extra, slist, "Necromancer Rebirths");
      }
     if(druid_left != "0 0")
      {
       slist := {D_REBIRTHS};
       addstring(slist, druid_left);
       addextra(self.extra, slist, "Druid Rebirths");
      }
     if(knight_left != "0 0")
      {
       slist := {DK_REBIRTHS};
       addstring(slist, knight_left);
       addextra(self.extra, slist, "Knight Rebirths");
      }

       slist := {DEMI_SCORE};
       addstring(slist, demi_score);
        addextra(self.extra, slist, "Demigod Score");
       slist := {SAC_POINTS};
       addstring(slist, god_score);
        addextra(self.extra, slist, "Sacrifice Points");

     subextra(self.quests, REBIRTH_DATA);
     goto adding;
   }
     goto adding;
:newfish:
       slist := {PC_REBIRTHS};
        addstring(slist, "0");
         addextra(self.extra, slist, "Total Rebirths");
       slist := {DEMI_SCORE};
        addstring(slist, "0");
         addextra(self.extra, slist, "Demigod Score");
       slist := {SAC_POINTS};
        addstring(slist, "0");
         addextra(self.extra, slist, "Sacrifice Points");

:adding:
    expd := SAC_POINTS in self.extra;
    i := atoi(expd.names.[1]);

   if ((i >= 250000) and (not("$Rebirth_Bob" in self.quests)))
   {
      act("You cannot sacrifice any more heads in this lifetime.",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   if ((head.value[3] <= 0) or (head.nameidx != "head"))
   {
      act("That head is bad! Sorry!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

:adding2:

   /*i := i + head.value[3]; */
  /*j := ((head.weight + head.value[3] * 3)/4); */

  j := head.weight;

  if (j == 1)
      {
      if (head.value[3] < 60)
       {
       j:=rnd(1,6);
	   }
	  else
	  j:=head.value[3]+ rnd(1,50);
      }

 if (j > 349)
   {
     k:= rnd(1,1000);
	if (k < 20)
    {
    j := head.weight + rnd(1,1000);
    }
   else
   j := head.weight + rnd(1,200);
   }



	 i := i + j;
   act("The flame wells up and consumes your sacrifice!" +
       "\nYou are granted " + itoa(j) + " points for that head." +
       "\nYou now have " + itoa(i) + " rebirth points.",
       A_ALWAYS, self, null, null, TO_CHAR);
   act("The flame wells up and accepts $1n's sacrifice!",
       A_SOMEONE, self, null, null, TO_REST);

   expd.names.[1] := itoa(i);
   destroy(head);

:end:
   quit;
}
dilend /* sacrifice */



dilbegin rebirth_stat (arg : string); /* type rebirth and get stat */

var
   expd       : extraptr;   /* REBIRTH_DATA in self */
   slist      : stringlist;
   reb_num    : integer;
   demi_score : integer;
   god_score  : integer;
   fight_left : integer;
   fight_num  : integer;
   thief_left : integer;
   thief_num  : integer;
   heal_left  : integer;
   heal_num   : integer;
   conj_left  : integer;
   conj_num   : integer;
   palad_left : integer;
   palad_num  : integer;
   sorc_left  : integer;
   sorc_num   : integer;
   ass_left   : integer;
   ass_num    : integer;
   necro_left : integer;
   necro_num  : integer;
   rang_left  : integer;
   rang_num   : integer;
   druid_left : integer;
   druid_num  : integer;
   knight_left : integer;
   knight_num  : integer;
code
{
   if (not(SAC_POINTS in self.extra))
   {
      act("You must make your first sacrifice to begin the quest " +
          "of rebirth. Seek out Eternia...",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   if (self.position < POSITION_SLEEPING)
   {
      act("You are Dead - isn't that enought to worry about!?",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

  expd := PC_REBIRTHS in self.extra;
   reb_num    := atoi(expd.names.[1]);
  expd := DEMI_SCORE in self.extra;
   demi_score := atoi(expd.names.[1]);
  expd := SAC_POINTS in self.extra;
   god_score  := atoi(expd.names.[1]);

:fighter:
  expd := F_REBIRTHS in self.extra;
   if(expd == null) goto thief;
  slist := getwords(expd.names.[1]);
   fight_left := atoi(slist.[0]);
   fight_num  := atoi(slist.[1]);
:thief:
  expd := T_REBIRTHS in self.extra;
   if(expd == null) goto healer;
  slist := getwords(expd.names.[1]);
   thief_left := atoi(slist.[0]);
   thief_num  := atoi(slist.[1]);
:healer:
  expd := H_REBIRTHS in self.extra;
   if(expd == null) goto conjurer;
  slist := getwords(expd.names.[1]);
   heal_left  := atoi(slist.[0]);
   heal_num   := atoi(slist.[1]);
:conjurer:
  expd := C_REBIRTHS in self.extra;
   if(expd == null) goto paladin;
  slist := getwords(expd.names.[1]);
   conj_left  := atoi(slist.[0]);
   conj_num   := atoi(slist.[1]);
:paladin:
  expd := P_REBIRTHS in self.extra;
   if(expd == null) goto sorcerer;
  slist := getwords(expd.names.[1]);
   palad_left := atoi(slist.[0]);
   palad_num  := atoi(slist.[1]);
:sorcerer:
  expd := S_REBIRTHS in self.extra;
   if(expd == null) goto assassin;
  slist := getwords(expd.names.[1]);
   sorc_left  := atoi(slist.[0]);
   sorc_num   := atoi(slist.[1]);
:assassin:
  expd := A_REBIRTHS in self.extra;
   if(expd == null) goto necromancer;
  slist := getwords(expd.names.[1]);
   ass_left   := atoi(slist.[0]);
   ass_num    := atoi(slist.[1]);
:necromancer:
  expd := N_REBIRTHS in self.extra;
   if(expd == null) goto ranger;
  slist := getwords(expd.names.[1]);
   necro_left := atoi(slist.[0]);
   necro_num  := atoi(slist.[1]);
:ranger:
  expd := R_REBIRTHS in self.extra;
   if(expd == null) goto druid;
  slist := getwords(expd.names.[1]);
   rang_left  := atoi(slist.[0]);
   rang_num   := atoi(slist.[1]);
:druid:
  expd := D_REBIRTHS in self.extra;
   if(expd == null) goto knight;
  slist := getwords(expd.names.[1]);
   druid_left := atoi(slist.[0]);
   druid_num  := atoi(slist.[1]);
:knight:
  expd := DK_REBIRTHS in self.extra;
   if(expd == null) goto outtime;
  slist := getwords(expd.names.[1]);
   knight_left := atoi(slist.[0]);
   knight_num  := atoi(slist.[1]);

:outtime:
   /* Output time */

   if ("morph" in arg) goto morph;
   else goto no_arg;

:no_arg:

   act(self.name + " " + self.title + " (" + self.guild + ")",
       A_ALWAYS, self, null, null, TO_CHAR);

if (god_score < 250000)
 {
   act("You have " + itoa(god_score) + " sacrifice points and you need " +
       itoa(250000 - god_score) + " more to rebirth.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto xpdisp;
 }

 if ((god_score >= 250000) and (god_score <= 500000))
   {
      act("You have " + itoa(god_score) + ", enough points to rebirth.",
          A_ALWAYS, self, null, null, TO_CHAR);
      if (("$Rebirth_Bob" in self.quests) and (god_score < 500000))
         act("You now need " + itoa(500000 - god_score) + " points to " +
             "lose your BoB scar when you rebirth.",
             A_ALWAYS, self, null, null, TO_CHAR);
      else if (("$Rebirth_Bob" in self.quests) and (god_score > 500000))
         act("You now have enough points (" + itoa(god_score) + ") to " +
             "lose your BoB scar when you rebirth.",
             A_ALWAYS, self, null, null, TO_CHAR);
   }

:xpdisp:
if (self.exp < 4612500)
   act("You have " + itoa(self.exp) + " experience points and you need " +
       itoa(4612500 - self.exp) + " more to rebirth.",
       A_ALWAYS, self, null, null, TO_CHAR);
else if (self.exp > 4612500)
   act("You have " + itoa(self.exp) + " experience points - enough to " +
       "rebirth.",
       A_ALWAYS, self, null, null, TO_CHAR);

   if (reb_num <= 0)
      act("You have never experienced rebirth.",
          A_ALWAYS, self, null, null, TO_CHAR);
   else if (reb_num == 1)
      act("You have experienced rebirth 1 time.",
          A_ALWAYS, self, null, null, TO_CHAR);
   else
      act("You have experienced rebirth " + itoa(reb_num) + " times.",
          A_ALWAYS, self, null, null, TO_CHAR);

   act("\nFor more information type 'rebirth morph'.",
       A_ALWAYS, self, null, null, TO_CHAR);
   goto end;

:morph:

   if (not(fight_num + thief_num + heal_num + conj_num + palad_num +
           sorc_num + ass_num + necro_num + rang_num + druid_num + knight_num))
   {
      act("You cannot morph into any creatures! You must rebirth " +
          "in order to do that!",
          A_ALWAYS, self, null, null, TO_CHAR);
      goto end;
   }

   act("You can morph into the following creatures:",
       A_ALWAYS, self, null, null, TO_CHAR);

   if (fight_num)
      act(itoa(fight_left) + " three minute charges left for " +
          "morphing into a Giant.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (thief_num)
      act(itoa(thief_left) + " three minute charges left for " +
          "morphing into a Viper.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (heal_num)
      act(itoa(heal_left) + " three minute charges left for " +
          "morphing into a Phoenix.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (conj_num)
      act(itoa(conj_left) + " three minute charges left for " +
          "morphing into a Dragon.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (palad_num)
      act(itoa(palad_left) + " three minute charges left for " +
          "morphing into a Lion.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (sorc_num)
      act(itoa(sorc_left) + " three minute charges left for " +
          "morphing into an Elemental.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (ass_num)
      act(itoa(ass_left) + " three minute charges left for " +
          "morphing into a Shadow Demon.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (necro_num)
      act(itoa(necro_left) + " three minute charges left for " +
          "morphing into a Vampire.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (rang_num)
      act(itoa(rang_left) + " three minute charges left for " +
          "morphing into a Panther.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (druid_num)
      act(itoa(druid_left) + " three minute charges left for " +
          "morphing into a Basilisk.",
          A_ALWAYS, self, null, null, TO_CHAR);

   if (knight_num)
      act(itoa(knight_left) + " three minute charges left for " +
          "morphing into a Hell Hound.",
          A_ALWAYS, self, null, null, TO_CHAR);

   goto end;

:end:
   quit;
}
dilend /* rebirth_stat */

dilbegin shrine_return(the_dir1 : string, the_dir2 : string);

var
   pc : unitptr;

code
{
:start:
   wait(SFB_CMD, command(the_dir1) or command("exits") or
                 command("directions") or command("doors") or
                 command("scan"));

   block;
   pc := activator;
   secure(pc, lost_pc);

   if (pc.position < POSITION_STANDING)
   {
      act("You need to be standing up to do that!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   if (command("exits") or command("directions") or command("doors")
       or command("scan"))
   {
      act("Obvious Exits:",
          A_ALWAYS, pc, null, null, TO_CHAR);
      act(the_dir1 + "  - An Island in the Nothingness.",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   if (pc.position == POSITION_FIGHTING)
   {
      act("You're too busy fighting!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }


   act("You enter the portal!",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n steps into the portal and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   link(pc, findroom("reb_room_3@rebirth"));
   act("You step out of the portal.",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n steps out of the " + the_dir2 + "!",
       A_SOMEONE, pc, null, null, TO_REST);
   exec("look", pc);

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* shrine_return */

dilbegin entrance_font(); /* Take me to the rebirth place honey */

var
   pc : unitptr;

code
{
:init:
   interrupt (SFB_CMD, (command("enter") and (activator.type==UNIT_ST_PC)),
              take_me);

:start:
   heartbeat := PULSE_SEC*2*rnd(15, 60);
   wait(SFB_TICK, TRUE);

   on rnd(0,3) goto got_0, got_1, got_2, got_3;

:got_0:
   act("The water shimmers gently in the light.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_1:
   act("Lapping gently against the side of the pool, the water seems to " +
       "call your soul to it.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_2:
   act("A ray of light shines off the rippling water, catching your eye.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_3:
   act("An unfelt breeze gently ripples over the water in the pool, " +
       "soothing your soul.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:take_me:
   block;
   pc := activator;
   secure(pc, lost_pc);
   if (pc.position < POSITION_STANDING)
   {
      act("You need to be standing up to do that!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }
   else if (pc.position == POSITION_FIGHTING)
   {
      act("You're too busy fighting!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }


   act("As you step into the Divine font of destiny, a tingling sensation " +
       "overcomes you and you pass out!",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n steps into the Divine font of destiny and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   link(pc, findroom("reb_room_1@rebirth"));
   act("You awake to find yourself somewhere else...",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n appears from a vortex in the air, which vanishes suddenly.",
       A_SOMEONE, pc, null, null, TO_REST);
   exec("look", pc);

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* entrance_font */

dilbegin exit_font(); /* Take me to the rebirth place honey */

var
   pc : unitptr;

code
{
:init:
   interrupt (SFB_CMD, (command("enter") and (activator.type==UNIT_ST_PC)),
              take_me);

:start:
   heartbeat := PULSE_SEC*2*rnd(15, 60);
   wait(SFB_TICK, TRUE);

   on rnd(0,3) goto got_0, got_1, got_2, got_3;

:got_0:
   act("The water shimmers gently in the light.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_1:
   act("Lapping gently against the side of the pool, the water seems to " +
       "call your soul to it.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_2:
   act("A ray of light shines off the rippling water, catching your eye.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:got_3:
   act("An unfelt breeze gently ripples over the water in the pool, " +
       "soothing your soul.",
       A_SOMEONE, self, null, null, TO_ALL);
   goto start;

:take_me:
   block;
   pc := activator;
   secure(pc, lost_pc);
   if (pc.position < POSITION_STANDING)
   {
      act("You need to be standing up to do that!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }
   else if (pc.position == POSITION_FIGHTING)
   {
      act("You're too busy fighting!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   act("As you step into the font, a tingling sensation " +
       "overcomes you and you pass out!",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n steps into the font and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   link(pc, findroom("reb_glade@rebirth"));
   act("You awake to find yourself somewhere else...",
       A_ALWAYS, pc, null, null, TO_CHAR);
   act("$1n appears from a vortex in the air, which vanishes suddenly.",
       A_SOMEONE, pc, null, null, TO_REST);
   exec("look", pc);

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* exit_font */

dilbegin rebirth_portals();

var
   pc :unitptr;

code
{
:start:
   wait(SFB_CMD,(command("west") or command("north") or
                 command("exits") or command("directions") or
                 command("doors") or command("scan")));
   pc:=activator;
   secure(pc, lost_pc);

   block;

   if (pc.position < POSITION_STANDING)
   {
      act("You need to be standing up to do that!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   if (command("exits") or command("directions") or command("doors")
       or command("scan"))
   {
      act("Obvious Exits:\n" +
          "West  - A Shimmering Blue Portal\n" +
          "North - A Shimmering White Portal",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   else if (pc.position == POSITION_FIGHTING)
   {
      act("You're too busy fighting!",
          A_ALWAYS, pc, null, null, TO_CHAR);
      goto lost_pc;
   }

   if (pc.position != POSITION_STANDING) goto start;

   if (command("west")) goto gods;
/*
   if (command("east")) goto demis;
*/

   if (command("north")) goto flame;

   goto lost_pc;

:gods:

   act("$1n enters the west portal and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You enter the west portal!",
       A_ALWAYS, pc, null, null ,TO_CHAR);

   link(pc,findroom("shrine_1@rebirth"));

   act("$1n steps out of the portal!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You step out of the portal.",
       A_ALWAYS, pc, null, null, TO_CHAR);

   exec("look", pc);

   goto lost_pc;

:demis:

   act("$1n enters the east portal and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You enter the east portal!",
       A_ALWAYS, pc, null, null ,TO_CHAR);

   link(pc,findroom("shrine_2@rebirth"));

   act("$1n steps out of the portal!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You step out of the portal.",
       A_ALWAYS, pc, null, null, TO_CHAR);

   exec("look", pc);

   goto lost_pc;

:flame:
/*
   if (not(REBIRTH_READY in pc.quests))
   {
      act("$1n attempts to enter the north portal but fails as $1e " +
          "bounces back!",
          A_HIDEINV, pc, null, null, TO_REST);
      act("You attempt to enter the north portal but it turns solid and " +
          "you bounce back!\n<div class=cpr>You are not ready for that yet!</div>",
          A_ALWAYS, pc, null, null ,TO_CHAR);
      goto lost_pc;
   }
*/

   act("$1n enters the north portal and vanishes!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You enter the north portal!",
       A_ALWAYS, pc, null, null ,TO_CHAR);

   link(pc,findroom("shrine_3@rebirth"));

   act("$1n steps out of the portal!",
       A_HIDEINV, pc, null, null, TO_REST);
   act("You step out of the portal.",
       A_ALWAYS, pc, null, null, TO_CHAR);

   exec("look", pc);

   goto lost_pc;


:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* rebirth_portals */

/* +++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++  R O O M S   S E C T I O N   ++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++*/
%rooms

/* Rooms for rebirth: reb_glade  : room for the font
                      reb_room_1 : the room after entering the font
                      reb_room_2 : along the corridor started at 1
                      reb_room_3 : the "plaza" leading to the 3 shrines
                      shrine_1   : Head sacrifice to gods
                      shrine_2   : Head sacrifice to demi-gods
                      shrine_3   : Rebirth room with pool of fire
                      waiting_room : where they go while rebirthing */

waiting_room
names {"waiting_room"}
title "Nothingness"
descr

"Surrounding and enveloping you, the nothingness is, but isn't there. Your
mortal mind struggles to comprehend the concept of being the only point of
reality in a universe of one. You exist out of time, out of place, your
faith is in the hands of the gods..."

extra {"nothingness","nothing"}
"You don't see it, you don't touch it, but your mind won't let you accept that
concept..."

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT

end /* waiting_room */

reb_glade
names {"glade","reb_glade"}
title "A Shady Green Glade in Cypress Forest"

descr
"The wind through the Cypress trees seems unnervingly-still. It's as if the
forest is waiting for something to happen. This glade appears quite different
to the rest of the forest, with an almost tangible sense of the preter-natural
in the air. The cypress trees have retreated to form a circle, and here and
there shafts of light break through into the treeless centre. This place has a
feelings of peace and tranquility to it."

extra {"trees","cypress trees"}
"They are quite beautiful, and, unlike the most of the trees in Cypress Forst,
they appear almost regal in stature."

movement SECT_FOREST

flags {UNIT_FL_NO_WEATHER, UNIT_FL_SACRED}

ALWAYS_LIGHT
south to ct_15@cypress descr "A Clearing in Cypress Woods";

end /* reb_glade */

reb_room_1
names {"corridor","reb1"}
title "A Corridor in the Shrine of Destiny"

descr
"The first thing that impresses itself upon you is that this corridor is
not on
the same plane of existence, let alone continent, as the place you have come
from. To either side of you a
set of polished white fluted corinthian columns rises, leading off into the
distance. The corridor itself is perhaps seven metres wide. The ground is made
of the same stone material as the columns, but instead of walls,
an etheral nothingness surrounds the structure in which you stand. Looking
over the edge reveals the same nothingness beneath. The only way you can
go is north, as the corridor leads straight in that direction."

extra {"columns", "fluted corinthian columns", "corinthian columns", "fluted
columns"}
"The columns rise up about four metres from the ground. They look very grand
and their divine appearence reinforces the possibility that this place
doesn't exist in the real world."

extra {"stone","ground"}
"Perfectly flat and unblemished, it appears to be like polished marble, but
it is too perfect to be real stone."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction."

extra {"$leave_s", "n"}
"You walk northward. The corridor behind you has vanished - only nothingness
remains!"

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT
north to reb_room_2@rebirth descr "Along the Corridor";
/*dilcopy death_room@function(60, 60, "Lingering here drains your life blood.");*/
end /* reb_room_1 */

reb_room_2
names {"corridor","reb2"}
title "Along a Corridor in the Shrine of Destiny"

descr
"Looking back, it doesn't look like you have gone further up the corridor -
it's like you never moved, but looking forward it becomes apparent that in
fact you have. This reality seems to change as you move through it. The
columns still flank you like a silent guard of honour, but ahead the end
of the corridor is visible at what seems to be a font like the one you
entered through."

extra {"columns", "fluted corinthian columns", "corinthian columns", "fluted
columns"}
"The columns rise up about four metres from the ground. They look very grand
and their divine appearence reinforces the possibility that this place
doesn't exist in the real world."

extra {"stone","ground"}
"Perfectly flat and unblemished, it appears to be like polished marble, but
it is too perfect to be real stone."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction."

extra {"$leave_s", "n"}
"You walk northward. Again the corridor behind you has vanished - only
nothingness remains!"

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT
north to reb_room_3@rebirth descr "The end of the corridor";
/*dilcopy death_room@function(60, 80, "Lingering here drains your life blood."); */
end /* reb_room_2 */

reb_room_3
names {"island","reb3"}
title "A Circular Meeting Place in the Shrine of Destiny"

descr
"Again the corridor to the south winks out of existence. You find yourself
in, or perhaps more precisely, on, an island in the nothingness. Two portals
stand on the edge of the island, one to the north and the other to the
west. Both look like a sheet of shining water standing like a doorway.
However, they are not the same: each shines with a different light. At the
centre of this island in the nothingness is another font like the one you
entered to get here. Shimmering in its water you can see that same glade
in Cypress Forest."

extra {"stone","ground"}
"Perfectly flat and unblemished, it appears to be like polished marble, but
it is too perfect to be real stone."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction."

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT

north to reb_room_3@rebirth descr "A swirling portal in the nothingness";
west to reb_room_3@rebirth descr "A swirling portal in the nothingness";
/*east to reb_room_3@rebirth descr "A swirling portal in the nothingness";*/

dilcopy rebirth_portals@rebirth(); /* Step this way */
/*dilcopy death_room@function(60, 80, "Lingering here drains your life blood.");*/
end /* reb_room_3 */

shrine_1
names {"Shrine of the Gods"}
title "The Eternal Shrine of the Gods"

descr
"Nothingness surrounds you, yet is solid underfoot. The portal through which
you entered stands to the east, shimmering in that brilliant blue colour. The
air is perfectly cool, but a great fire blazes in a massive plinth in front
of you. This is where the sacrifices are made."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction, and is
solid underfoot."

extra {"plinth"}
"It is made of that same white marble you have seen elsewhere in this
nothingness. Approximately three metres in diameter, it contains a brilliant
flame."

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT

east to shrine_1@rebirth descr "A swirling portal in the nothingness";

dilcopy shrine_return@rebirth("east","west"); /* Step this way */
/*dilcopy death_room@function(600, 60, "Lingering here drains your life blood.");*/
end /* shrine_1 */

shrine_2
names {"Shrine of the Demi-gods"}
title "The Shrine of the Demi-gods"

descr
"The air is deadly cold, yet ahead of you in the etheral darkness a
magnificent flame burns in a raised plinth. The portal through which
you entered stands to the west, shimmering in a brilliant green colour.
This is where the sacrifices are made."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction, and is
solid underfoot."

extra {"plinth"}
"It is made of that same white marble you have seen elsewhere in this
nothingness. Approximately three metres in diameter, it contains a brilliant
flame."

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT

west to shrine_2@rebirth descr "A swirling portal in the nothingness";

dilcopy shrine_return@rebirth("west","east"); /* Step this way */

end /* shrine_2 */

shrine_3
names {"oblivion"}
title "At the Fire of Oblivion"

descr
"A huge flame hangs in the air before you, burning like a column of
herecletian fire in the eerie nothingness which envelopes this reality.
A startling realisation overcomes you: the air is quite cool around you
and no heat is radiating from the supernatural flame. Even more strangely,
you feel a great urge to enter it! The shimmering white portal through
which you entered stands to the south."

extra {"ethereal nothingness","nothingness"}
"Though you can't make out any shapes in it, it appears to swirl at random and
to infinity. It's difficult to judge how far it is away from you, but it
looks as if it surrounds this 'bubble of reality' in every direction, and is
solid underfoot."

movement SECT_INSIDE

flags {UNIT_FL_NO_WEATHER, UNIT_FL_NO_TELEPORT, UNIT_FL_SACRED}

ALWAYS_LIGHT

south to shrine_3@rebirth descr "A swirling portal in the nothingness";

dilcopy shrine_return@rebirth("south","north"); /* Step this way */

end /* shrine_3 */

/* +++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++  O B J E C T S   S E C T I O N  +++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++ */
%objects

rebirth_bag
names {"bag of holding", "bag", "travbag"}
title "a bag of holding"
descr "a bag lies here."
extra {}
"This bag has a seemingly limitless capacity, it is obviously magical."
weight 10
cost 25 GOLD_PIECE
manipulate {MANIPULATE_TAKE, MANIPULATE_HOLD, MANIPULATE_ENTER}
CONTAINER_DEF(600)
end /* rebirth_bag */

/*
nanny_object
names {"rebirth object", "object"}
title "Rebirth object"
descr "You do not see this."

extra {}
""

type ITEM_OTHER

minv 200

manipulate{MANIPULATE_TAKE, MANIPULATE_HOLD}

weight 1

end */

eternia
names {"Eternia","girl","beautiful woman","woman"}
title "Eternia, voice of the gods"
descr "A beautiful woman sits patiently beside the pool."

extra {}
"Beautiful as the sun is golden, her eyes shine with a divine light. She is no
ordinary woman, but a child of the gods. She is the guide to those wishing to
leave this life for their next, for life is eternal, just as she is. Simply
say 'guide me' and she will share her knowledge with you."

type ITEM_OTHER

dilcopy guide@rebirth(); /* She speaks! */

end /* eternia */

plaque
names {"plaque","sign"}
title "a large plaque"
descr "A large plaque is here yearning to be read!"

extra {}
"The sign reads:
&l

   'You must sacrifice the creature heads in the shrine through
    the west portal until you gain enough favour to rebirth.
    Once you are ready to rebirth, you may enter the north portal.

    Good Luck!

    The Gods of Valhalla"

type ITEM_NOTE

end /* plaque */


plinth
names {"Great Plinth", "plinth"}
title "a Raised Plinth"
descr
"<div class=cpy>A raised plinth stands here in the nothingness, bearing a <div class=cpr>wondrous
Flame<div class=cpy>.</div>"

extra {}
"The plint if made from that same polished white marble which you have
encountered so many times before. It is a few metres across and carries
a frighteningly bright flame which burns with a divine fury. If you have
a sacrifice, then 'sacrifice'."

extra {"Flame"}
"The flame burns with supernatural fury. Staring into it provokes images of
incomprehensible things which border on the edge of consciousness and
insanity. You know this is where the 'sacrifice' is made."

type ITEM_OTHER

end /* plinth */

flame
names {"Flame of Oblivion", "flame", "oblivion"}
title "the Flame of Oblivion"
descr
"<div class=cpr>The Flame of Oblivion burns here.</div>"

extra{}
"It is almost too bright to look at, but you can feel no heat from it. As you
look at it, you feel the urge to walk into it, to ENTER it..."

type ITEM_OTHER

dilcopy check_elig@rebirth();

end /* flame */

west_portal_1
names {"Blue Portal", "portal"}
title "a shining blue portal"
descr
"<div class=cpc>To the west stands a shining blue portal.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* west_portal_1 */

west_portal_2
names {"Blue Portal", "portal"}
title "a shining blue portal"
descr
"<div class=cpc>A shining blue portal stands here.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* west_portal_2 */

east_portal_1
names {"Green Portal", "portal"}
title "a shining green portal"
descr
"<div class=cpg>To the east stands a shining green portal.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* east_portal_1 */

east_portal_2
names {"Green Portal", "portal"}
title "a shining green portal"
descr
"<div class=cpg>A shining green portal stands here.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* east_portal_2 */

north_portal_1
names {"White Portal", "portal"}
title "a shining white portal"
descr
"<div class=cpw>To the north stands a shining white portal.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* north_portal_1 */

north_portal_2
names {"White Portal", "portal"}
title "a shining white portal"
descr
"<div class=cpw>A shining white portal stands here.</div>"

extra{}
"It is like a film of water surrounded by an oval ring of a polished white
stone. It shimmers and shines, radiating a light of its own."

type ITEM_OTHER

end /* north_portal_2 */

rebirth_enter
names {"Divine Font of Destiny","pool","font","water","portal"}
title "the Divine Font of Destiny"
descr
"A raised circular pool of shimmering water lies at the centre of
the glade."

extra{}
"The pool seems to be white marble and in appearence at least, it is of one
piece, as if it was carved from a single block of marble. The edge is about
the height of your knee, and the pool is approximately three metres in
diameter, making it seem somewhat like a baptismal font. The water shimmers
gently in the light, and the feeling of a divine force at work tingles on the
edge of your mind. Perhaps you could enter the pool - it does look inviting."

extra {"water", "shimmering water"}
"The water appears bluish, but not in an unnatural sense. The light shimmers
softly and gently as the water is agitated by an unseen force, perhaps a
breeze,
but if so, you can't feel it. Though you wouldn't think it deep, it is hard to
judge how far down the water goes, though it does look very inviting."

extra {"marble"}
"Strangely, it appears to have been here a long time, but the marble itself
has
been untouched by the passage of time."

type ITEM_OTHER

dilcopy entrance_font@rebirth();

end /* rebirth_enter */

rebirth_leave
names {"Divine Font of Mortality","pool","font","water","portal"}
title "the Divine Font of Mortality"
descr
"A raised circular pool of shimmering water lies at the centre of
this island in the nothingness."

extra{}
"The pool seems to be white marble and in appearence at least, it is of one
piece, as if it was carved from a single block of marble. The edge is about
the height of your knee, and the pool is approximately three metres in
diameter, making it seem somewhat like a baptismal font. The water shimmers
gently in the light, and the feeling of a divine force at work tingles on the
edge of your mind. You see somewhere in Cypress Forest depicted in its waters.
Perhaps you could enter the pool - it does look inviting."

extra {"water", "shimmering water"}
"The water appears bluish, but not in an unnatural sense. The light shimmers
softly and gently as the water is agitated by an unseen force, perhaps a
breeze,
but if so, you can't feel it. Though you wouldn't think it deep, it is hard to
judge how far down the water goes, though it does look very inviting."

extra {"marble"}
"Strangely, it appears to have been here a long time, but the marble itself
has
been untouched by the passage of time."

type ITEM_OTHER

dilcopy exit_font@rebirth();

end /* rebirth_leave */

rebirth_object
names {"rebirth data object", "rebirth object", "data object", "object"}
title "a Rebirth data object"
descr
"Some silly admin left a Rebirth data object here."
extra{}
"<div class=cpw>To begin editing rebirth info, type <div class=cpy>'update <player>'</div>.  While
editor is active, type a guild name followed by the number of times the
player has rebirthed in that guild (example: <div class=cpw>'sorcerer 2'</div>).  In
addition, you can set the player's total number of rebirths, demigod score,
and total sacrifice points by substituting a guild name with either the
word <div class=cpw>TOTAL</div>, <div class=cpw>DEMI</div>, or <div class=cpw>POINTS</div>, respectively.  To finish
editing the player's values, use the command '<div class=cpw>DONE</div>'.  <div class=cpg>ALSO:  </div>
You can use this object to remove hidden extras (those beginning with a
dollar sign) from players.  Type <div class=cpy>'subex <player> <extra name>'</div> to
do so."
type ITEM_OTHER
manipulate {MANIPULATE_TAKE}
weight 1
minv 250
dilbegin admin_update();

var
   pc         : unitptr;
   pcc        : stringlist;
   arglist    : stringlist;
   rb         : string;
   points     : string;
   expd       : extraptr;
   data_list  : stringlist;
   new_list   : stringlist;
   tot_num    : string;
   fight_left : string;
   thief_left : string;
   heal_left  : string;
   conj_left  : string;
   palad_left : string;
   sorc_left  : string;
   ass_left   : string;
   necro_left : string;
   rang_left  : string;
   druid_left : string;
   knight_left : string;
   demi_score : string;
   god_score  : string;

code
{
:init:
   heartbeat := PULSE_SEC*10;

interrupt(SFB_CMD, ((command("done")) and (activator.level >= 253) and
                    (activator == self.outside)), done);

:start:
new_list:= null;
pcc:= null;

 wait(SFB_CMD, ((command("update")) and (activator.level >= 253)));
   block;
   if(activator != self.outside) goto start;
   arglist := getwords(argument);
   if(length(arglist) != 1)
    {
     act("Supply only the player's name.",
         A_ALWAYS, self.outside, null, null, TO_CHAR);
     goto start;
    }
   pc := findunit(self.outside, arglist.[0], FIND_UNIT_WORLD, null);
    if(pc == null)
     {
      act("No such player online.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
      goto start;
     }

addstring(pcc, pc.name);
 act("<div class=cpr>Online Rebirth data editor active.&[default]",
      A_ALWAYS, self.outside, null, null, TO_CHAR);

      tot_num    := "0";
      fight_left := "0 0";
      thief_left := "0 0";
      heal_left  := "0 0";
      conj_left  := "0 0";
      palad_left := "0 0";
      sorc_left  := "0 0";
      ass_left   := "0 0";
      necro_left := "0 0";
      rang_left  := "0 0";
      druid_left := "0 0";
	  knight_left := "0 0";
      demi_score := "0";
      god_score  := "0";

:mainmenu:
 wait(SFB_CMD, (((command("fighter")) or
                (command("thief")) or
                (command("healer")) or
                (command("conjurer")) or
                (command("ranger")) or
                (command("paladin")) or
                (command("sorcerer")) or
                (command("assassin")) or
                (command("necromancer")) or
                (command("druid")) or
				(command("knight")) or
                (command("total")) or
                (command("demi")) or
                (command("points"))) and (activator.level >= 253)));
 block;
  if(activator != self.outside) goto mainmenu;
   arglist := getwords(argument);
   if(length(arglist) != 1)
    {
     act("Supply only the field name and new data number.",
          A_ALWAYS, self.outside, null, null, TO_CHAR);
     goto mainmenu;
    }

 points := arglist.[0];

if(command("total"))
{
 tot_num := points;
 subextra(pc.extra, PC_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, PC_REBIRTHS);
 addstring(new_list, tot_num);
 addextra(pc.extra, new_list, PC_REBIRTHS);
 act("Total rebirths adjusted.", A_ALWAYS, self.outside, null, null, TO_CHAR);
}
if(command("fighter"))
{
 fight_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, F_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, F_REBIRTHS);
 addstring(new_list, fight_left);
 addextra(pc.extra, new_list, F_REBIRTHS);
 act("Fighter rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("thief"))
{
 thief_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, T_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, T_REBIRTHS);
 addstring(new_list, thief_left);
 addextra(pc.extra, new_list, T_REBIRTHS);
 act("Thief rebirths adjusted.", A_ALWAYS, self.outside, null, null, TO_CHAR);
}
if(command("healer"))
{
 heal_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, H_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, H_REBIRTHS);
 addstring(new_list, heal_left);
 addextra(pc.extra, new_list, H_REBIRTHS);
 act("Healer rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("conjurer"))
{
 conj_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, C_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, C_REBIRTHS);
 addstring(new_list, conj_left);
 addextra(pc.extra, new_list, C_REBIRTHS);
 act("Conjurer rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("paladin"))
{
 palad_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, P_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, P_REBIRTHS);
 addstring(new_list, palad_left);
 addextra(pc.extra, new_list, P_REBIRTHS);
 act("Paladin rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("sorcerer"))
{
 sorc_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, S_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, S_REBIRTHS);
 addstring(new_list, sorc_left);
 addextra(pc.extra, new_list, S_REBIRTHS);
 act("Sorcerer rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("assassin"))
{
 ass_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, A_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, A_REBIRTHS);
 addstring(new_list, ass_left);
 addextra(pc.extra, new_list, A_REBIRTHS);
 act("Assassin rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("necromancer"))
{
 necro_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, N_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, N_REBIRTHS);
 addstring(new_list, necro_left);
 addextra(pc.extra, new_list, N_REBIRTHS);
 act("Necromancer rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("ranger"))
{
 rang_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, R_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, R_REBIRTHS);
 addstring(new_list, rang_left);
 addextra(pc.extra, new_list, R_REBIRTHS);
 act("Ranger rebirths adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
if(command("druid"))
{
 druid_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, D_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, D_REBIRTHS);
 addstring(new_list, druid_left);
 addextra(pc.extra, new_list, D_REBIRTHS);
 act("Druid rebirths adjusted.", A_ALWAYS, self.outside, null, null, TO_CHAR);
}
if(command("knight"))
{
 knight_left := itoa(atoi(points) * 5)+" "+points;
 subextra(pc.extra, DK_REBIRTHS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, DK_REBIRTHS);
 addstring(new_list, knight_left);
 addextra(pc.extra, new_list, DK_REBIRTHS);
 act("Knight rebirths adjusted.", A_ALWAYS, self.outside, null, null, TO_CHAR);
}

if(command("demi"))
{
 demi_score := points;
 subextra(pc.extra, DEMI_SCORE);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, DEMI_SCORE);
 addstring(new_list, demi_score);
 addextra(pc.extra, new_list, DEMI_SCORE);
 act("Demigod score adjusted.", A_ALWAYS, self.outside, null, null, TO_CHAR);
}
if(command("points"))
{
 god_score := points;
 subextra(pc.extra, SAC_POINTS);

 while (new_list.[0] != "")
     substring (new_list, new_list.[0]);

 pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);

 addstring(new_list, SAC_POINTS);
 addstring(new_list, god_score);
 addextra(pc.extra, new_list, SAC_POINTS);
 act("Sacrifice points adjusted.", A_ALWAYS, self.outside, null, null,
TO_CHAR);
}
goto mainmenu;

:done:
block;
   pc := findunit(self.outside, pcc.[0], FIND_UNIT_WORLD, null);
    if(pc == null)
     {
      act("The player left before you could finish.",
          A_ALWAYS, self.outside, null, null, TO_CHAR);
      goto finished;
     }

/* subextra(pc.quests, REBIRTH_DATA);

   addstring(new_list, REBIRTH_DATA);
   addstring(new_list, tot_num);
   addstring(new_list, fight_left);
   addstring(new_list, thief_left);
   addstring(new_list, heal_left);
   addstring(new_list, conj_left);
   addstring(new_list, palad_left);
   addstring(new_list, sorc_left);
   addstring(new_list, ass_left);
   addstring(new_list, necro_left);
   addstring(new_list, rang_left);
   addstring(new_list, druid_left);
   addstring(new_list, demi_score);
   addstring(new_list, god_score);

   addextra(pc.quests, new_list, "BLANKETY BLANK");
*/

act("<div class=cpb>"+pc.name+"'s Rebirth data updated.&[default]",
     A_ALWAYS, self.outside, null, null, TO_CHAR);
log(self.outside.name+" updated "+pc.name+"'s Rebirth data.");

:finished:
act("<div class=cpr>Online Rebirth data editor deactivated.&[default]",
     A_ALWAYS, self.outside, null, null, TO_CHAR);
goto start;
}
dilend

dilbegin subex();

var
   pc         : unitptr;
   arglist    : stringlist;
   expd       : extraptr;
   exname     : string;
   x          : integer;
   l          : integer;
   m          : integer;

code
{
:init:
   heartbeat := PULSE_SEC*10;

:start:
 m := 0;
 wait(SFB_CMD, ((command("subex")) and (activator.level >= 253)));
  block;
  if(activator != self.outside) goto start;
  arglist := getwords(argument);
  l := length(arglist);
   if(l < 2)
     {
      act("Not enough arguments.", A_ALWAYS, self.outside, null, null,
           TO_CHAR);
      goto start;
     }
   pc := findunit(self.outside, arglist.[0], FIND_UNIT_WORLD, null);
    if(pc == null)
     {
      act("No such player online.", A_ALWAYS, self.outside, null, null,
           TO_CHAR);
      goto start;
     }
   exname := arglist.[1];

   m := 1;
   while(m < (l - 1))
    {
     m := m + 1;
     exname := exname +" "+ arglist.[m];
    }

   expd := exname in pc.extra;
    if(expd == null)
     {
      act("No such extra on "+pc.name+".", A_ALWAYS, self.outside, null, null,
           TO_CHAR);
      goto start;
     }
   subextra(pc.extra, exname);
      act("<div class=cpw>Extra removed.", A_ALWAYS, self.outside, null, null,
           TO_CHAR);
      log(self.outside.name+" removed "+pc.name+"'s "+exname+" extra.");
      goto start;
}
dilend
end
/*  The following dice added by Darg to aid in setting chars age after reroll */
/* The dice have the start age incorporated so once rolled that is there age. */
brownie_dice
names {"brownie age dice","dice"}
title "a pair of eight sided dice"
descr "A pair of eight sided brownie age dice lie here."
extra {}
"You see a pair of eight sided dice.  To use, simply have the die in your inventory and
ROLL. The total reflects the total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin brownie_age();
var
  pc : unitptr;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  i := rnd(1,8);
  j := rnd(1,8);
  k := 32 + i + j;
  link(self,pc.outside);
  act("You roll a pair of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a pair of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(i)+" and a "+itoa(j)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a pair of dice. "+
    "To use, simply have the pair of dice in your inventory "+
   "and ROLL.  The pair of dice is currently showing a "+itoa(i)+" and a "+
    itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

groll_dice
names {"groll age dice","dice","die"}
title "a single four sided die"
descr "A single four sided groll age die lies here."
extra {}
"You see a single four sided die.  To use, simply have the die in your inventory and
ROLL. The total reflects the total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin groll_age();
var
  pc : unitptr;
  i  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  i := rnd(1,4);
  k := 8 + i;
  link(self,pc.outside);
  act("You roll the die...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a die...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(i)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(i)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a single die. "+
    "To use, simply have the die in your inventory "+
   "and ROLL.  The die is currently showing a "+itoa(i)+" for a total
    of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

human_dice
names {"human age dice","dice","die"}
title "a single four sided die"
descr "A single four sided human age die lies here."
extra {}
"You see a single four sided die.  To use, simply have the die in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin human_age();
var
  pc : unitptr;
  i  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  i := rnd(1,4);
  k := 15 + i;
  link(self,pc.outside);
  act("You roll the die...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a die...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(i)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(i)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a single die. "+
    "To use, simply have the die in your inventory "+
   "and ROLL.  The die is currently showing a "+itoa(i)+" for a total
    of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

halforc_dice
names {"half orc age dice","dice","die"}
title "a single four sided die"
descr "A single four sided half orc age die lies here."
extra {}
"You see a single four sided die.  To use, simply have the die in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin halforc_age();
var
  pc : unitptr;
  i  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  i := rnd(1,4);
  k := 14 + i;
  link(self,pc.outside);
  act("You roll the die...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a die...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(i)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(i)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a single die. "+
    "To use, simply have the die in your inventory "+
   "and ROLL.  The die is currently showing a "+itoa(i)+" for a total
    of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

elf_dice
names {"elf age dice","dice","set"}
title "a set of 5, six sided dice"
descr "A set of 5, six sided elf age dice lie here."
extra {}
"You see a set of 5, six sided dice.  To use, simply have the set in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin elf_age();
var
  pc : unitptr;
  f  : integer;
  g  : integer;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
    f := rnd(1,6);
    g := rnd(1,6);
    h := rnd(1,6);
    i := rnd(1,6);
    j := rnd(1,6);
    k := 185 + f + g + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(f)+" and a "+itoa(g)+" and a "+itoa(h)
   +" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(f)+" and a "+itoa(g)+" and a "+itoa(h)+" and a "+itoa(i)
  +" and a "+itoa(j)+" has just been rolled by $1n for a "+"total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(f)+" and a "+itoa(g)+
   " and a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "
   +itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

dwarf_dice
names {"dwarf age dice","dice","set"}
title "a set of 5 , six sided dice"
descr "A set of 5, six sided dwarf age dice lie here."
extra {}
"You see a set of 5, six sided dice.  To use, simply have the set in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin dwarf_age();
var
  pc : unitptr;
  f  : integer;
  g  : integer;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  f := rnd(1,6);
  g := rnd(1,6);
  h := rnd(1,6);
  i := rnd(1,6);
  j := rnd(1,6);
  k := 55 + f + g + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(f)+" and a "+itoa(g)+" and a "+itoa(h)
  +" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(f)+" and a "+itoa(g)+" and a "+itoa(h)+" and a "+itoa(i)
  +" and a "+itoa(j)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(f)+" and a "+itoa(g)
   +" and a "+itoa(h)+" and a "+itoa(i)+" and a "+
    itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

halfling_dice
names {"halfling age dice","dice"}
title "a set of 3, four sided dice"
descr "A set of 3, four sided halfling age dice lie here."
extra {}
"You see a set of 3, four sided dice.  To use, simply have the set in your inventory and
ROLL."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin halfing_age();
var
  pc : unitptr;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  h := rnd(1,4);
  i := rnd(1,4);
  j := rnd(1,4);
  k := 36 + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(h)+" and a "+itoa(i)
   +" and a "+itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

darkelf_dice
names {"dark elf age dice","dice","set"}
title "a set of 6, six sided dice"
descr "A set of 6, six sided dark elf age dice lie here."
extra {}
"You see a set of 6, six sided dice.  To use, simply have the set in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin darkelf_age();
var
  pc : unitptr;
  e  : integer;
  f  : integer;
  g  : integer;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  e := rnd(1,6);
  f := rnd(1,6);
  g := rnd(1,6);
  h := rnd(1,6);
  i := rnd(1,6);
  j := rnd(1,6);
  k := 190 + e + f + g + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(e)+" and a "+itoa(f)+" and a "+itoa(g)
  +" and a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "
  +itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(e)+" and a "+itoa(f)+" and a "+itoa(g)+" and a "+itoa(h)
  +" and a "+itoa(i)+" and a "+itoa(j)+" has just been rolled by $1n for a "
  +"total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(e)+" and a "+itoa(f)
   +" and a "+itoa(g)+" and a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)
   +" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

gnome_dice
names {"gnome age dice","dice","set"}
title "a set of 3, twelve sided dice"
descr "A set of 3, twelve sided gnome age dice lie here."
extra {}
"You see a set of 3, twelve sided dice.  To use, simply have the set in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin gnome_age();
var
  pc : unitptr;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  h := rnd(1,12);
  i := rnd(1,12);
  j := rnd(1,12);
  k := 101 + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(h)+" and a "+itoa(i)
   +" and a "+itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

halfogre_dice
names {"half ogre age dice","dice"}
title "a pair of six sided dice"
descr "A pair of six sided brownie age dice lie here."
extra {}
"You see a pair of six sided dice.  To use, simply have the dice in your inventory and
ROLL."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin halfogre_age();
var
  pc : unitptr;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  i := rnd(1,6);
  j := rnd(1,6);
  k := 18 + i + j;
  link(self,pc.outside);
  act("You roll a pair of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a pair of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(i)+" and a "+itoa(j)+" for a total of "+
    itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(i)+" and a "+itoa(j)+" has just been rolled by $1n for a "+
    "total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a pair of dice. "+
    "To use, simply have the pair of dice in your inventory "+
   "and ROLL.  The pair of dice is currently showing a "+itoa(i)+" and a "+
    itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end

halfelf_dice
names {"half elf age dice","dice","set"}
title "a set of 3 , six sided dice"
descr "A set of 3, six sided half elf age dice lie here."
extra {}
"You see a set of 3, six sided dice.  To use, simply have the set in your inventory and
ROLL. The total reflects total age."
manipulate {MANIPULATE_TAKE}
type ITEM_OTHER
dilbegin halfelf_age();
var
  pc : unitptr;
  h  : integer;
  i  : integer;
  j  : integer;
  k  : integer;
code
{
  :start:
  wait(SFB_CMD,(( command("roll")) and
  (self.outside == activator)));
  block;
  pc := activator;
	secure (pc,losthim);
  h := rnd(1,6);
  i := rnd(1,6);
  j := rnd(1,6);
  k := 22 + h + i + j;
  link(self,pc.outside);
  act("You roll a set of dice...",A_SOMEONE,pc,null,null,TO_CHAR);
  act("$1n rolls a set of dice...",A_SOMEONE,pc,null,null,TO_REST);
  act("You just rolled a "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)
  +" for a total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_CHAR);
  act("A "+itoa(h)+" and a "+itoa(i)+" and a "+itoa(j)
  +" has just been rolled by $1n for a "
  +"total of "+itoa(k)+"!",A_SOMEONE,pc,null,null,TO_REST);
  self.extra.descr := "You see a set of dice. "+
    "To use, simply have the set of dice in your inventory "+
   "and ROLL.  The set of dice is currently showing a "+itoa(h)+" and a "+itoa(i)
   +itoa(j)+" for a total of "+itoa(k)+".";
  goto start;

:losthim:
unsecure (pc);
goto start;
}
dilend
end


/* +++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++  R E S E T   S E C T I O N  +++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++ */
%reset

/* Rebirth reset */

load rebirth_enter into reb_glade@rebirth max 1
load eternia into reb_glade@rebirth max 1

load rebirth_leave into reb_room_3@rebirth max 1

load plinth into shrine_1@rebirth max 2
load plinth into shrine_2@rebirth max 2
load flame into shrine_3@rebirth max 1

load north_portal_1 into reb_room_3@rebirth max 1
load north_portal_2 into shrine_3@rebirth max 1

/*load east_portal_1 into reb_room_3@rebirth max 1
load east_portal_2 into shrine_2@rebirth max 1*/

load west_portal_1 into reb_room_3@rebirth max 1
load west_portal_2 into shrine_1@rebirth max 1

load plaque into reb_room_3@rebirth max 1

%end
