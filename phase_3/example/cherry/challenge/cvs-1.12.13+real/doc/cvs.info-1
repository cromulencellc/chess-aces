This is cvs.info, produced by makeinfo version 4.8 from cvs.texinfo.

INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* CVS: (cvs).                   Concurrent Versions System
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* cvs: (cvs)CVS commands.       Concurrent Versions System
END-INFO-DIR-ENTRY


File: cvs.info,  Node: Top,  Next: Overview,  Up: (dir)

CVS--Concurrent Versions System v1.12.13
****************************************

This info manual describes how to use and administer CVS version
1.12.13.

Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
2002, 2003, 2004, 2005 Free Software Foundation, Inc.

Portions  
          Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Derek
          R. Price,
          Copyright (C) 2002, 2003, 2004, 2005 Ximbiot
          `http://ximbiot.com',
          Copyright (C) 1992, 1993, 1999 Signum Support AB,
          and Copyright (C) others.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

* Menu:

* Overview::                    An introduction to CVS
* Repository::                  Where all your sources are stored
* Starting a new project::      Starting a project with CVS
* Revisions::                   Numeric and symbolic names for revisions
* Branching and merging::       Diverging/rejoining branches of development
* Recursive behavior::          CVS descends directories
* Adding and removing::         Adding/removing/renaming files/directories
* History browsing::            Viewing the history of files in various ways

CVS and the Real World.
-----------------------
* Binary files::                CVS can handle binary files
* Multiple developers::         How CVS helps a group of developers
* Revision management::         Policy questions for revision management
* Keyword substitution::        CVS can include the revision inside the file
* Tracking sources::            Tracking third-party sources
* Builds::                      Issues related to CVS and builds
* Special Files::		Devices, links and other non-regular files

References.
-----------
* CVS commands::                CVS commands share some things
* Invoking CVS::                Quick reference to CVS commands
* Administrative files::        Reference manual for the Administrative files
* Environment variables::       All environment variables which affect CVS
* Compatibility::               Upgrading CVS versions
* Troubleshooting::             Some tips when nothing works
* Credits::                     Some of the contributors to this manual
* BUGS::                        Dealing with bugs in CVS or this manual
* Index::                       Index


File: cvs.info,  Node: Overview,  Next: Repository,  Prev: Top,  Up: Top

1 Overview
**********

This chapter is for people who have never used CVS, and perhaps have
never used version control software before.

   If you are already familiar with CVS and are just trying to learn a
particular feature or remember a certain command, you can probably skip
everything here.

* Menu:

* What is CVS?::                What you can do with CVS
* What is CVS not?::            Problems CVS doesn't try to solve
* A sample session::            A tour of basic CVS usage


File: cvs.info,  Node: What is CVS?,  Next: What is CVS not?,  Up: Overview

1.1 What is CVS?
================

CVS is a version control system.  Using it, you can record the history
of your source files.

   For example, bugs sometimes creep in when software is modified, and
you might not detect the bug until a long time after you make the
modification.  With CVS, you can easily retrieve old versions to see
exactly which change caused the bug.  This can sometimes be a big help.

   You could of course save every version of every file you have ever
created.  This would however waste an enormous amount of disk space.
CVS stores all the versions of a file in a single file in a clever way
that only stores the differences between versions.

   CVS also helps you if you are part of a group of people working on
the same project.  It is all too easy to overwrite each others' changes
unless you are extremely careful.  Some editors, like GNU Emacs, try to
make sure that two people never modify the same file at the same time.
Unfortunately, if someone is using another editor, that safeguard will
not work.  CVS solves this problem by insulating the different
developers from each other.  Every developer works in his own
directory, and CVS merges the work when each developer is done.

   CVS started out as a bunch of shell scripts written by Dick Grune,
posted to the newsgroup `comp.sources.unix' in the volume 6 release of
July, 1986.  While no actual code from these shell scripts is present
in the current version of CVS much of the CVS conflict resolution
algorithms come from them.

   In April, 1989, Brian Berliner designed and coded CVS.  Jeff Polk
later helped Brian with the design of the CVS module and vendor branch
support.

   You can get CVS in a variety of ways, including free download from
the Internet.  For more information on downloading CVS and other CVS
topics, see:

     `http://cvs.nongnu.org/'

   There is a mailing list, known as <info-cvs@nongnu.org>, devoted to
CVS.  To subscribe or unsubscribe write to
<info-cvs-request@nongnu.org>.  If you prefer a Usenet group, there is
a one-way mirror (posts to the email list are usually sent to the news
group, but not visa versa) of <info-cvs@nongnu.org> at
`news:gnu.cvs.help'.  The right Usenet group for posts is
`news:comp.software.config-mgmt' which is for CVS discussions (along
with other configuration management systems).  In the future, it might
be possible to create a `comp.software.config-mgmt.cvs', but probably
only if there is sufficient CVS traffic on
`news:comp.software.config-mgmt'.

   You can also subscribe to the <bug-cvs@nongnu.org> mailing list,
described in more detail in *Note BUGS::.  To subscribe send mail to
<bug-cvs-request@nongnu.org>.  There is a two-way Usenet mirror (posts
to the Usenet group are usually sent to the email list and visa versa)
of <bug-cvs@nongnu.org> named `news:gnu.cvs.bug'.


File: cvs.info,  Node: What is CVS not?,  Next: A sample session,  Prev: What is CVS?,  Up: Overview

1.2 What is CVS not?
====================

CVS can do a lot of things for you, but it does not try to be
everything for everyone.

CVS is not a build system.
     Though the structure of your repository and modules file interact
     with your build system (e.g. `Makefile's), they are essentially
     independent.

     CVS does not dictate how you build anything.  It merely stores
     files for retrieval in a tree structure you devise.

     CVS does not dictate how to use disk space in the checked out
     working directories.  If you write your `Makefile's or scripts in
     every directory so they have to know the relative positions of
     everything else, you wind up requiring the entire repository to be
     checked out.

     If you modularize your work, and construct a build system that
     will share files (via links, mounts, `VPATH' in `Makefile's,
     etc.), you can arrange your disk usage however you like.

     But you have to remember that _any_ such system is a lot of work
     to construct and maintain.  CVS does not address the issues
     involved.

     Of course, you should place the tools created to support such a
     build system (scripts, `Makefile's, etc) under CVS.

     Figuring out what files need to be rebuilt when something changes
     is, again, something to be handled outside the scope of CVS.  One
     traditional approach is to use `make' for building, and use some
     automated tool for generating the dependencies which `make' uses.

     See *Note Builds::, for more information on doing builds in
     conjunction with CVS.

CVS is not a substitute for management.
     Your managers and project leaders are expected to talk to you
     frequently enough to make certain you are aware of schedules,
     merge points, branch names and release dates.  If they don't, CVS
     can't help.

     CVS is an instrument for making sources dance to your tune.  But
     you are the piper and the composer.  No instrument plays itself or
     writes its own music.

CVS is not a substitute for developer communication.
     When faced with conflicts within a single file, most developers
     manage to resolve them without too much effort.  But a more
     general definition of "conflict" includes problems too difficult
     to solve without communication between developers.

     CVS cannot determine when simultaneous changes within a single
     file, or across a whole collection of files, will logically
     conflict with one another.  Its concept of a "conflict" is purely
     textual, arising when two changes to the same base file are near
     enough to spook the merge (i.e. `diff3') command.

     CVS does not claim to help at all in figuring out non-textual or
     distributed conflicts in program logic.

     For example: Say you change the arguments to function `X' defined
     in file `A'.  At the same time, someone edits file `B', adding new
     calls to function `X' using the old arguments.  You are outside
     the realm of CVS's competence.

     Acquire the habit of reading specs and talking to your peers.

CVS does not have change control
     Change control refers to a number of things.  First of all it can
     mean "bug-tracking", that is being able to keep a database of
     reported bugs and the status of each one (is it fixed?  in what
     release?  has the bug submitter agreed that it is fixed?).  For
     interfacing CVS to an external bug-tracking system, see the
     `rcsinfo' and `verifymsg' files (*note Administrative files::).

     Another aspect of change control is keeping track of the fact that
     changes to several files were in fact changed together as one
     logical change.  If you check in several files in a single `cvs
     commit' operation, CVS then forgets that those files were checked
     in together, and the fact that they have the same log message is
     the only thing tying them together.  Keeping a GNU style
     `ChangeLog' can help somewhat.

     Another aspect of change control, in some systems, is the ability
     to keep track of the status of each change.  Some changes have
     been written by a developer, others have been reviewed by a second
     developer, and so on.  Generally, the way to do this with CVS is to
     generate a diff (using `cvs diff' or `diff') and email it to
     someone who can then apply it using the `patch' utility.  This is
     very flexible, but depends on mechanisms outside CVS to make sure
     nothing falls through the cracks.

CVS is not an automated testing program
     It should be possible to enforce mandatory use of a test suite
     using the `commitinfo' file.  I haven't heard a lot about projects
     trying to do that or whether there are subtle gotchas, however.

CVS does not have a built-in process model
     Some systems provide ways to ensure that changes or releases go
     through various steps, with various approvals as needed.
     Generally, one can accomplish this with CVS but it might be a
     little more work.  In some cases you'll want to use the
     `commitinfo', `loginfo', `rcsinfo', or `verifymsg' files, to
     require that certain steps be performed before cvs will allow a
     checkin.  Also consider whether features such as branches and tags
     can be used to perform tasks such as doing work in a development
     tree and then merging certain changes over to a stable tree only
     once they have been proven.


File: cvs.info,  Node: A sample session,  Prev: What is CVS not?,  Up: Overview

1.3 A sample session
====================

As a way of introducing CVS, we'll go through a typical work-session
using CVS.  The first thing to understand is that CVS stores all files
in a centralized "repository" (*note Repository::); this section
assumes that a repository is set up.

   Suppose you are working on a simple compiler.  The source consists
of a handful of C files and a `Makefile'.  The compiler is called `tc'
(Trivial Compiler), and the repository is set up so that there is a
module called `tc'.

* Menu:

* Getting the source::          Creating a workspace
* Committing your changes::     Making your work available to others
* Cleaning up::                 Cleaning up
* Viewing differences::         Viewing differences


File: cvs.info,  Node: Getting the source,  Next: Committing your changes,  Up: A sample session

1.3.1 Getting the source
------------------------

The first thing you must do is to get your own working copy of the
source for `tc'.  For this, you use the `checkout' command:

     $ cvs checkout tc

This will create a new directory called `tc' and populate it with the
source files.

     $ cd tc
     $ ls
     CVS         Makefile    backend.c   driver.c    frontend.c  parser.c

   The `CVS' directory is used internally by CVS.  Normally, you should
not modify or remove any of the files in it.

   You start your favorite editor, hack away at `backend.c', and a
couple of hours later you have added an optimization pass to the
compiler.  A note to RCS and SCCS users: There is no need to lock the
files that you want to edit.  *Note Multiple developers::, for an
explanation.


File: cvs.info,  Node: Committing your changes,  Next: Cleaning up,  Prev: Getting the source,  Up: A sample session

1.3.2 Committing your changes
-----------------------------

When you have checked that the compiler is still compilable you decide
to make a new version of `backend.c'.  This will store your new
`backend.c' in the repository and make it available to anyone else who
is using that same repository.

     $ cvs commit backend.c

CVS starts an editor, to allow you to enter a log message.  You type in
"Added an optimization pass.", save the temporary file, and exit the
editor.

   The environment variable `$CVSEDITOR' determines which editor is
started.  If `$CVSEDITOR' is not set, then if the environment variable
`$EDITOR' is set, it will be used. If both `$CVSEDITOR' and `$EDITOR'
are not set then there is a default which will vary with your operating
system, for example `vi' for unix or `notepad' for Windows NT/95.

   In addition, CVS checks the `$VISUAL' environment variable.
Opinions vary on whether this behavior is desirable and whether future
releases of CVS should check `$VISUAL' or ignore it.  You will be OK
either way if you make sure that `$VISUAL' is either unset or set to
the same thing as `$EDITOR'.

   When CVS starts the editor, it includes a list of files which are
modified.  For the CVS client, this list is based on comparing the
modification time of the file against the modification time that the
file had when it was last gotten or updated.  Therefore, if a file's
modification time has changed but its contents have not, it will show
up as modified.  The simplest way to handle this is simply not to worry
about it--if you proceed with the commit CVS will detect that the
contents are not modified and treat it as an unmodified file.  The next
`update' will clue CVS in to the fact that the file is unmodified, and
it will reset its stored timestamp so that the file will not show up in
future editor sessions.

   If you want to avoid starting an editor you can specify the log
message on the command line using the `-m' flag instead, like this:

     $ cvs commit -m "Added an optimization pass" backend.c


File: cvs.info,  Node: Cleaning up,  Next: Viewing differences,  Prev: Committing your changes,  Up: A sample session

1.3.3 Cleaning up
-----------------

Before you turn to other tasks you decide to remove your working copy of
tc.  One acceptable way to do that is of course

     $ cd ..
     $ rm -r tc

but a better way is to use the `release' command (*note release::):

     $ cd ..
     $ cvs release -d tc
     M driver.c
     ? tc
     You have [1] altered files in this repository.
     Are you sure you want to release (and delete) directory `tc': n
     ** `release' aborted by user choice.

   The `release' command checks that all your modifications have been
committed.  If history logging is enabled it also makes a note in the
history file.  *Note history file::.

   When you use the `-d' flag with `release', it also removes your
working copy.

   In the example above, the `release' command wrote a couple of lines
of output.  `? tc' means that the file `tc' is unknown to CVS.  That is
nothing to worry about: `tc' is the executable compiler, and it should
not be stored in the repository.  *Note cvsignore::, for information
about how to make that warning go away.  *Note release output::, for a
complete explanation of all possible output from `release'.

   `M driver.c' is more serious.  It means that the file `driver.c' has
been modified since it was checked out.

   The `release' command always finishes by telling you how many
modified files you have in your working copy of the sources, and then
asks you for confirmation before deleting any files or making any note
in the history file.

   You decide to play it safe and answer `n <RET>' when `release' asks
for confirmation.


File: cvs.info,  Node: Viewing differences,  Prev: Cleaning up,  Up: A sample session

1.3.4 Viewing differences
-------------------------

You do not remember modifying `driver.c', so you want to see what has
happened to that file.

     $ cd tc
     $ cvs diff driver.c

   This command runs `diff' to compare the version of `driver.c' that
you checked out with your working copy.  When you see the output you
remember that you added a command line option that enabled the
optimization pass.  You check it in, and release the module.

     $ cvs commit -m "Added an optimization pass" driver.c
     Checking in driver.c;
     /usr/local/cvsroot/tc/driver.c,v  <--  driver.c
     new revision: 1.2; previous revision: 1.1
     done
     $ cd ..
     $ cvs release -d tc
     ? tc
     You have [0] altered files in this repository.
     Are you sure you want to release (and delete) directory `tc': y


File: cvs.info,  Node: Repository,  Next: Starting a new project,  Prev: Overview,  Up: Top

2 The Repository
****************

The CVS "repository" stores a complete copy of all the files and
directories which are under version control.

   Normally, you never access any of the files in the repository
directly.  Instead, you use CVS commands to get your own copy of the
files into a "working directory", and then work on that copy.  When
you've finished a set of changes, you check (or "commit") them back
into the repository.  The repository then contains the changes which
you have made, as well as recording exactly what you changed, when you
changed it, and other such information.  Note that the repository is
not a subdirectory of the working directory, or vice versa; they should
be in separate locations.

   CVS can access a repository by a variety of means.  It might be on
the local computer, or it might be on a computer across the room or
across the world.  To distinguish various ways to access a repository,
the repository name can start with an "access method".  For example,
the access method `:local:' means to access a repository directory, so
the repository `:local:/usr/local/cvsroot' means that the repository is
in `/usr/local/cvsroot' on the computer running CVS.  For information
on other access methods, see *Note Remote repositories::.

   If the access method is omitted, then if the repository starts with
`/', then `:local:' is assumed.  If it does not start with `/' then
either `:ext:' or `:server:' is assumed.  For example, if you have a
local repository in `/usr/local/cvsroot', you can use
`/usr/local/cvsroot' instead of `:local:/usr/local/cvsroot'.  But if
(under Windows NT, for example) your local repository is
`c:\src\cvsroot', then you must specify the access method, as in
`:local:c:/src/cvsroot'.

   The repository is split in two parts.  `$CVSROOT/CVSROOT' contains
administrative files for CVS.  The other directories contain the actual
user-defined modules.

* Menu:

* Specifying a repository::     Telling CVS where your repository is
* Repository storage::          The structure of the repository
* Working directory storage::   The structure of working directories
* Intro administrative files::  Defining modules
* Multiple repositories::       Multiple repositories
* Creating a repository::       Creating a repository
* Backing up::                  Backing up a repository
* Moving a repository::         Moving a repository
* Remote repositories::         Accessing repositories on remote machines
* Read-only access::            Granting read-only access to the repository
* Server temporary directory::  The server creates temporary directories


File: cvs.info,  Node: Specifying a repository,  Next: Repository storage,  Up: Repository

2.1 Telling CVS where your repository is
========================================

There are several ways to tell CVS where to find the repository.  You
can name the repository on the command line explicitly, with the `-d'
(for "directory") option:

     cvs -d /usr/local/cvsroot checkout yoyodyne/tc

   Or you can set the `$CVSROOT' environment variable to an absolute
path to the root of the repository, `/usr/local/cvsroot' in this
example.  To set `$CVSROOT', `csh' and `tcsh' users should have this
line in their `.cshrc' or `.tcshrc' files:

     setenv CVSROOT /usr/local/cvsroot

`sh' and `bash' users should instead have these lines in their
`.profile' or `.bashrc':

     CVSROOT=/usr/local/cvsroot
     export CVSROOT

   A repository specified with `-d' will override the `$CVSROOT'
environment variable.  Once you've checked a working copy out from the
repository, it will remember where its repository is (the information
is recorded in the `CVS/Root' file in the working copy).

   The `-d' option and the `CVS/Root' file both override the `$CVSROOT'
environment variable.  If `-d' option differs from `CVS/Root', the
former is used.  Of course, for proper operation they should be two
ways of referring to the same repository.


File: cvs.info,  Node: Repository storage,  Next: Working directory storage,  Prev: Specifying a repository,  Up: Repository

2.2 How data is stored in the repository
========================================

For most purposes it isn't important _how_ CVS stores information in
the repository.  In fact, the format has changed in the past, and is
likely to change in the future.  Since in almost all cases one accesses
the repository via CVS commands, such changes need not be disruptive.

   However, in some cases it may be necessary to understand how CVS
stores data in the repository, for example you might need to track down
CVS locks (*note Concurrency::) or you might need to deal with the file
permissions appropriate for the repository.

* Menu:

* Repository files::            What files are stored in the repository
* File permissions::            File permissions
* Windows permissions::         Issues specific to Windows
* Attic::                       Some files are stored in the Attic
* CVS in repository::           Additional information in CVS directory
* Locks::                       CVS locks control concurrent accesses
* CVSROOT storage::             A few things about CVSROOT are different


File: cvs.info,  Node: Repository files,  Next: File permissions,  Up: Repository storage

2.2.1 Where files are stored within the repository
--------------------------------------------------

The overall structure of the repository is a directory tree
corresponding to the directories in the working directory.  For
example, supposing the repository is in

     /usr/local/cvsroot

here is a possible directory tree (showing only the directories):

     /usr
      |
      +--local
      |   |
      |   +--cvsroot
      |   |    |
      |   |    +--CVSROOT
               |      (administrative files)
               |
               +--gnu
               |   |
               |   +--diff
               |   |   (source code to GNU diff)
               |   |
               |   +--rcs
               |   |   (source code to RCS)
               |   |
               |   +--cvs
               |       (source code to CVS)
               |
               +--yoyodyne
                   |
                   +--tc
                   |    |
                   |    +--man
                   |    |
                   |    +--testing
                   |
                   +--(other Yoyodyne software)

   With the directories are "history files" for each file under version
control.  The name of the history file is the name of the corresponding
file with `,v' appended to the end.  Here is what the repository for
the `yoyodyne/tc' directory might look like:
       `$CVSROOT'
         |
         +--yoyodyne
         |   |
         |   +--tc
         |   |   |
                 +--Makefile,v
                 +--backend.c,v
                 +--driver.c,v
                 +--frontend.c,v
                 +--parser.c,v
                 +--man
                 |    |
                 |    +--tc.1,v
                 |
                 +--testing
                      |
                      +--testpgm.t,v
                      +--test2.t,v

   The history files contain, among other things, enough information to
recreate any revision of the file, a log of all commit messages and the
user-name of the person who committed the revision.  The history files
are known as "RCS files", because the first program to store files in
that format was a version control system known as RCS.  For a full
description of the file format, see the `man' page `rcsfile(5)',
distributed with RCS, or the file `doc/RCSFILES' in the CVS source
distribution.  This file format has become very common--many systems
other than CVS or RCS can at least import history files in this format.

   The RCS files used in CVS differ in a few ways from the standard
format.  The biggest difference is magic branches; for more information
see *Note Magic branch numbers::.  Also in CVS the valid tag names are
a subset of what RCS accepts; for CVS's rules see *Note Tags::.


File: cvs.info,  Node: File permissions,  Next: Windows permissions,  Prev: Repository files,  Up: Repository storage

2.2.2 File permissions
----------------------

All `,v' files are created read-only, and you should not change the
permission of those files.  The directories inside the repository
should be writable by the persons that have permission to modify the
files in each directory.  This normally means that you must create a
UNIX group (see group(5)) consisting of the persons that are to edit
the files in a project, and set up the repository so that it is that
group that owns the directory.  (On some systems, you also need to set
the set-group-ID-on-execution bit on the repository directories (see
chmod(1)) so that newly-created files and directories get the group-ID
of the parent directory rather than that of the current process.)

   This means that you can only control access to files on a
per-directory basis.

   Note that users must also have write access to check out files,
because CVS needs to create lock files (*note Concurrency::).  You can
use LockDir in CVSROOT/config to put the lock files somewhere other
than in the repository if you want to allow read-only access to some
directories (*note config::).

   Also note that users must have write access to the
`CVSROOT/val-tags' file.  CVS uses it to keep track of what tags are
valid tag names (it is sometimes updated when tags are used, as well as
when they are created).

   Each RCS file will be owned by the user who last checked it in.
This has little significance; what really matters is who owns the
directories.

   CVS tries to set up reasonable file permissions for new directories
that are added inside the tree, but you must fix the permissions
manually when a new directory should have different permissions than its
parent directory.  If you set the `CVSUMASK' environment variable that
will control the file permissions which CVS uses in creating directories
and/or files in the repository.  `CVSUMASK' does not affect the file
permissions in the working directory; such files have the permissions
which are typical for newly created files, except that sometimes CVS
creates them read-only (see the sections on watches, *Note Setting a
watch::; -r, *Note Global options::; or `CVSREAD', *Note Environment
variables::).

   Note that using the client/server CVS (*note Remote repositories::),
there is no good way to set `CVSUMASK'; the setting on the client
machine has no effect.  If you are connecting with `rsh', you can set
`CVSUMASK' in `.bashrc' or `.cshrc', as described in the documentation
for your operating system.  This behavior might change in future
versions of CVS; do not rely on the setting of `CVSUMASK' on the client
having no effect.

   Using pserver, you will generally need stricter permissions on the
CVSROOT directory and directories above it in the tree; see *Note
Password authentication security::.

   Some operating systems have features which allow a particular
program to run with the ability to perform operations which the caller
of the program could not.  For example, the set user ID (setuid) or set
group ID (setgid) features of unix or the installed image feature of
VMS.  CVS was not written to use such features and therefore attempting
to install CVS in this fashion will provide protection against only
accidental lapses; anyone who is trying to circumvent the measure will
be able to do so, and depending on how you have set it up may gain
access to more than just CVS.  You may wish to instead consider
pserver.  It shares some of the same attributes, in terms of possibly
providing a false sense of security or opening security holes wider
than the ones you are trying to fix, so read the documentation on
pserver security carefully if you are considering this option (*Note
Password authentication security::).


File: cvs.info,  Node: Windows permissions,  Next: Attic,  Prev: File permissions,  Up: Repository storage

2.2.3 File Permission issues specific to Windows
------------------------------------------------

Some file permission issues are specific to Windows operating systems
(Windows 95, Windows NT, and presumably future operating systems in
this family.  Some of the following might apply to OS/2 but I'm not
sure).

   If you are using local CVS and the repository is on a networked file
system which is served by the Samba SMB server, some people have
reported problems with permissions.  Enabling WRITE=YES in the samba
configuration is said to fix/workaround it.  Disclaimer: I haven't
investigated enough to know the implications of enabling that option,
nor do I know whether there is something which CVS could be doing
differently in order to avoid the problem.  If you find something out,
please let us know as described in *Note BUGS::.


File: cvs.info,  Node: Attic,  Next: CVS in repository,  Prev: Windows permissions,  Up: Repository storage

2.2.4 The attic
---------------

You will notice that sometimes CVS stores an RCS file in the `Attic'.
For example, if the CVSROOT is `/usr/local/cvsroot' and we are talking
about the file `backend.c' in the directory `yoyodyne/tc', then the
file normally would be in

     /usr/local/cvsroot/yoyodyne/tc/backend.c,v

but if it goes in the attic, it would be in

     /usr/local/cvsroot/yoyodyne/tc/Attic/backend.c,v

instead.  It should not matter from a user point of view whether a file
is in the attic; CVS keeps track of this and looks in the attic when it
needs to.  But in case you want to know, the rule is that the RCS file
is stored in the attic if and only if the head revision on the trunk
has state `dead'.  A `dead' state means that file has been removed, or
never added, for that revision.  For example, if you add a file on a
branch, it will have a trunk revision in `dead' state, and a branch
revision in a non-`dead' state.


File: cvs.info,  Node: CVS in repository,  Next: Locks,  Prev: Attic,  Up: Repository storage

2.2.5 The CVS directory in the repository
-----------------------------------------

The `CVS' directory in each repository directory contains information
such as file attributes (in a file called `CVS/fileattr'.  In the
future additional files may be added to this directory, so
implementations should silently ignore additional files.

   This behavior is implemented only by CVS 1.7 and later; for details
see *Note Watches Compatibility::.

   The format of the `fileattr' file is a series of entries of the
following form (where `{' and `}' means the text between the braces can
be repeated zero or more times):

   ENT-TYPE FILENAME <tab> ATTRNAME = ATTRVAL   {; ATTRNAME = ATTRVAL}
<linefeed>

   ENT-TYPE is `F' for a file, in which case the entry specifies the
attributes for that file.

   ENT-TYPE is `D', and FILENAME empty, to specify default attributes
to be used for newly added files.

   Other ENT-TYPE are reserved for future expansion.  CVS 1.9 and older
will delete them any time it writes file attributes.  CVS 1.10 and
later will preserve them.

   Note that the order of the lines is not significant; a program
writing the fileattr file may rearrange them at its convenience.

   There is currently no way of quoting tabs or line feeds in the
filename, `=' in ATTRNAME, `;' in ATTRVAL, etc.  Note: some
implementations also don't handle a NUL character in any of the fields,
but implementations are encouraged to allow it.

   By convention, ATTRNAME starting with `_' is for an attribute given
special meaning by CVS; other ATTRNAMEs are for user-defined attributes
(or will be, once implementations start supporting user-defined
attributes).

   Built-in attributes:

`_watched'
     Present means the file is watched and should be checked out
     read-only.

`_watchers'
     Users with watches for this file.  Value is WATCHER > TYPE { ,
     WATCHER > TYPE } where WATCHER is a username, and TYPE is zero or
     more of edit,unedit,commit separated by `+' (that is, nothing if
     none; there is no "none" or "all" keyword).

`_editors'
     Users editing this file.  Value is EDITOR > VAL { , EDITOR > VAL }
     where EDITOR is a username, and VAL is TIME+HOSTNAME+PATHNAME,
     where TIME is when the `cvs edit' command (or equivalent) happened,
     and HOSTNAME and PATHNAME are for the working directory.

   Example:

     Ffile1 _watched=;_watchers=joe>edit,mary>commit
     Ffile2 _watched=;_editors=sue>8 Jan 1975+workstn1+/home/sue/cvs
     D _watched=

means that the file `file1' should be checked out read-only.
Furthermore, joe is watching for edits and mary is watching for
commits.  The file `file2' should be checked out read-only; sue started
editing it on 8 Jan 1975 in the directory `/home/sue/cvs' on the
machine `workstn1'.  Future files which are added should be checked out
read-only.  To represent this example here, we have shown a space after
`D', `Ffile1', and `Ffile2', but in fact there must be a single tab
character there and no spaces.


File: cvs.info,  Node: Locks,  Next: CVSROOT storage,  Prev: CVS in repository,  Up: Repository storage

2.2.6 CVS locks in the repository
---------------------------------

For an introduction to CVS locks focusing on user-visible behavior, see
*Note Concurrency::.  The following section is aimed at people who are
writing tools which want to access a CVS repository without interfering
with other tools accessing the same repository.  If you find yourself
confused by concepts described here, like "read lock", "write lock",
and "deadlock", you might consult the literature on operating systems
or databases.

   Any file in the repository with a name starting with `#cvs.rfl.' is
a read lock.  Any file in the repository with a name starting with
`#cvs.pfl' is a promotable read lock.  Any file in the repository with
a name starting with `#cvs.wfl' is a write lock.  Old versions of CVS
(before CVS 1.5) also created files with names starting with
`#cvs.tfl', but they are not discussed here.  The directory `#cvs.lock'
serves as a master lock.  That is, one must obtain this lock first
before creating any of the other locks.

   To obtain a read lock, first create the `#cvs.lock' directory.  This
operation must be atomic (which should be true for creating a directory
under most operating systems).  If it fails because the directory
already existed, wait for a while and try again.  After obtaining the
`#cvs.lock' lock, create a file whose name is `#cvs.rfl.' followed by
information of your choice (for example, hostname and process
identification number).  Then remove the `#cvs.lock' directory to
release the master lock.  Then proceed with reading the repository.
When you are done, remove the `#cvs.rfl' file to release the read lock.

   Promotable read locks are a concept you may not find in other
literature on concurrency.  They are used to allow a two (or more) pass
process to only lock a file for read on the first (read) pass(es), then
upgrade its read locks to write locks if necessary for a final pass,
still assured that the files have not changed since they were first
read.  CVS uses promotable read locks, for example, to prevent commit
and tag verification passes from interfering with other reading
processes.  It can then lock only a single directory at a time for
write during the write pass.

   To obtain a promotable read lock, first create the `#cvs.lock'
directory, as with a non-promotable read lock.  Then check that there
are no files that start with `#cvs.pfl'.  If there are, remove the
master `#cvs.lock' directory, wait awhile (CVS waits 30 seconds between
lock attempts), and try again.  If there are no other promotable locks,
go ahead and create a file whose name is `#cvs.pfl' followed by
information of your choice (for example, CVS uses its hostname and the
process identification number of the CVS server process creating the
lock).  If versions of CVS older than version 1.12.4 access your
repository directly (not via a CVS server of version 1.12.4 or later),
then you should also create a read lock since older versions of CVS
will ignore the promotable lock when attempting to create their own
write lock.  Then remove the master `#cvs.lock' directory in order to
allow other processes to obtain read locks.

   To obtain a write lock, first create the `#cvs.lock' directory, as
with read locks.  Then check that there are no files whose names start
with `#cvs.rfl.' and no files whose names start with `#cvs.pfl' that are
not owned by the process attempting to get the write lock.  If either
exist, remove `#cvs.lock', wait for a while, and try again.  If there
are no readers or promotable locks from other processes, then create a
file whose name is `#cvs.wfl' followed by information of your choice
(again, CVS uses the hostname and server process identification
number).  Remove your `#cvs.pfl' file if present.  Hang on to the
`#cvs.lock' lock.  Proceed with writing the repository.  When you are
done, first remove the `#cvs.wfl' file and then the `#cvs.lock'
directory. Note that unlike the `#cvs.rfl' file, the `#cvs.wfl' file is
just informational; it has no effect on the locking operation beyond
what is provided by holding on to the `#cvs.lock' lock itself.

   Note that each lock (write lock or read lock) only locks a single
directory in the repository, including `Attic' and `CVS' but not
including subdirectories which represent other directories under
version control.  To lock an entire tree, you need to lock each
directory (note that if you fail to obtain any lock you need, you must
release the whole tree before waiting and trying again, to avoid
deadlocks).

   Note also that CVS expects write locks to control access to
individual `foo,v' files.  RCS has a scheme where the `,foo,' file
serves as a lock, but CVS does not implement it and so taking out a CVS
write lock is recommended.  See the comments at rcs_internal_lockfile
in the CVS source code for further discussion/rationale.


File: cvs.info,  Node: CVSROOT storage,  Prev: Locks,  Up: Repository storage

2.2.7 How files are stored in the CVSROOT directory
---------------------------------------------------

The `$CVSROOT/CVSROOT' directory contains the various administrative
files.  In some ways this directory is just like any other directory in
the repository; it contains RCS files whose names end in `,v', and many
of the CVS commands operate on it the same way.  However, there are a
few differences.

   For each administrative file, in addition to the RCS file, there is
also a checked out copy of the file.  For example, there is an RCS file
`loginfo,v' and a file `loginfo' which contains the latest revision
contained in `loginfo,v'.  When you check in an administrative file,
CVS should print

     cvs commit: Rebuilding administrative file database

and update the checked out copy in `$CVSROOT/CVSROOT'.  If it does not,
there is something wrong (*note BUGS::).  To add your own files to the
files to be updated in this fashion, you can add them to the
`checkoutlist' administrative file (*note checkoutlist::).

   By default, the `modules' file behaves as described above.  If the
modules file is very large, storing it as a flat text file may make
looking up modules slow (I'm not sure whether this is as much of a
concern now as when CVS first evolved this feature; I haven't seen
benchmarks).  Therefore, by making appropriate edits to the CVS source
code one can store the modules file in a database which implements the
`ndbm' interface, such as Berkeley db or GDBM.  If this option is in
use, then the modules database will be stored in the files `modules.db',
`modules.pag', and/or `modules.dir'.

   For information on the meaning of the various administrative files,
see *Note Administrative files::.


File: cvs.info,  Node: Working directory storage,  Next: Intro administrative files,  Prev: Repository storage,  Up: Repository

2.3 How data is stored in the working directory
===============================================

While we are discussing CVS internals which may become visible from
time to time, we might as well talk about what CVS puts in the `CVS'
directories in the working directories.  As with the repository, CVS
handles this information and one can usually access it via CVS
commands.  But in some cases it may be useful to look at it, and other
programs, such as the `jCVS' graphical user interface or the `VC'
package for emacs, may need to look at it.  Such programs should follow
the recommendations in this section if they hope to be able to work
with other programs which use those files, including future versions of
the programs just mentioned and the command-line CVS client.

   The `CVS' directory contains several files.  Programs which are
reading this directory should silently ignore files which are in the
directory but which are not documented here, to allow for future
expansion.

   The files are stored according to the text file convention for the
system in question.  This means that working directories are not
portable between systems with differing conventions for storing text
files.  This is intentional, on the theory that the files being managed
by CVS probably will not be portable between such systems either.

`Root'
     This file contains the current CVS root, as described in *Note
     Specifying a repository::.

`Repository'
     This file contains the directory within the repository which the
     current directory corresponds with.  It can be either an absolute
     pathname or a relative pathname; CVS has had the ability to read
     either format since at least version 1.3 or so.  The relative
     pathname is relative to the root, and is the more sensible
     approach, but the absolute pathname is quite common and
     implementations should accept either.  For example, after the
     command

          cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc

     `Root' will contain

          :local:/usr/local/cvsroot

     and `Repository' will contain either

          /usr/local/cvsroot/yoyodyne/tc

     or

          yoyodyne/tc

     If the particular working directory does not correspond to a
     directory in the repository, then `Repository' should contain
     `CVSROOT/Emptydir'.  

`Entries'
     This file lists the files and directories in the working directory.
     The first character of each line indicates what sort of line it
     is.  If the character is unrecognized, programs reading the file
     should silently skip that line, to allow for future expansion.

     If the first character is `/', then the format is:

          /NAME/REVISION/TIMESTAMP[+CONFLICT]/OPTIONS/TAGDATE

     where `[' and `]' are not part of the entry, but instead indicate
     that the `+' and conflict marker are optional.  NAME is the name
     of the file within the directory.  REVISION is the revision that
     the file in the working derives from, or `0' for an added file, or
     `-' followed by a revision for a removed file.  TIMESTAMP is the
     timestamp of the file at the time that CVS created it; if the
     timestamp differs with the actual modification time of the file it
     means the file has been modified.  It is stored in the format used
     by the ISO C asctime() function (for example, `Sun Apr  7 01:29:26
     1996').  One may write a string which is not in that format, for
     example, `Result of merge', to indicate that the file should
     always be considered to be modified.  This is not a special case;
     to see whether a file is modified a program should take the
     timestamp of the file and simply do a string compare with
     TIMESTAMP.  If there was a conflict, CONFLICT can be set to the
     modification time of the file after the file has been written with
     conflict markers (*note Conflicts example::).  Thus if CONFLICT is
     subsequently the same as the actual modification time of the file
     it means that the user has obviously not resolved the conflict.
     OPTIONS contains sticky options (for example `-kb' for a binary
     file).  TAGDATE contains `T' followed by a tag name, or `D' for a
     date, followed by a sticky tag or date.  Note that if TIMESTAMP
     contains a pair of timestamps separated by a space, rather than a
     single timestamp, you are dealing with a version of CVS earlier
     than CVS 1.5 (not documented here).

     The timezone on the timestamp in CVS/Entries (local or universal)
     should be the same as the operating system stores for the
     timestamp of the file itself.  For example, on Unix the file's
     timestamp is in universal time (UT), so the timestamp in
     CVS/Entries should be too.  On VMS, the file's timestamp is in
     local time, so CVS on VMS should use local time.  This rule is so
     that files do not appear to be modified merely because the
     timezone changed (for example, to or from summer time).

     If the first character of a line in `Entries' is `D', then it
     indicates a subdirectory.  `D' on a line all by itself indicates
     that the program which wrote the `Entries' file does record
     subdirectories (therefore, if there is such a line and no other
     lines beginning with `D', one knows there are no subdirectories).
     Otherwise, the line looks like:

          D/NAME/FILLER1/FILLER2/FILLER3/FILLER4

     where NAME is the name of the subdirectory, and all the FILLER
     fields should be silently ignored, for future expansion.  Programs
     which modify `Entries' files should preserve these fields.

     The lines in the `Entries' file can be in any order.

`Entries.Log'
     This file does not record any information beyond that in
     `Entries', but it does provide a way to update the information
     without having to rewrite the entire `Entries' file, including the
     ability to preserve the information even if the program writing
     `Entries' and `Entries.Log' abruptly aborts.  Programs which are
     reading the `Entries' file should also check for `Entries.Log'.
     If the latter exists, they should read `Entries' and then apply
     the changes mentioned in `Entries.Log'.  After applying the
     changes, the recommended practice is to rewrite `Entries' and then
     delete `Entries.Log'.  The format of a line in `Entries.Log' is a
     single character command followed by a space followed by a line in
     the format specified for a line in `Entries'.  The single
     character command is `A' to indicate that the entry is being added,
     `R' to indicate that the entry is being removed, or any other
     character to indicate that the entire line in `Entries.Log' should
     be silently ignored (for future expansion).  If the second
     character of the line in `Entries.Log' is not a space, then it was
     written by an older version of CVS (not documented here).

     Programs which are writing rather than reading can safely ignore
     `Entries.Log' if they so choose.

`Entries.Backup'
     This is a temporary file.  Recommended usage is to write a new
     entries file to `Entries.Backup', and then to rename it
     (atomically, where possible) to `Entries'.

`Entries.Static'
     The only relevant thing about this file is whether it exists or
     not.  If it exists, then it means that only part of a directory
     was gotten and CVS will not create additional files in that
     directory.  To clear it, use the `update' command with the `-d'
     option, which will get the additional files and remove
     `Entries.Static'.

`Tag'
     This file contains per-directory sticky tags or dates.  The first
     character is `T' for a branch tag, `N' for a non-branch tag, or
     `D' for a date, or another character to mean the file should be
     silently ignored, for future expansion.  This character is
     followed by the tag or date.  Note that per-directory sticky tags
     or dates are used for things like applying to files which are
     newly added; they might not be the same as the sticky tags or
     dates on individual files.  For general information on sticky tags
     and dates, see *Note Sticky tags::.

`Notify'
     This file stores notifications (for example, for `edit' or
     `unedit') which have not yet been sent to the server.  Its format
     is not yet documented here.

`Notify.tmp'
     This file is to `Notify' as `Entries.Backup' is to `Entries'.
     That is, to write `Notify', first write the new contents to
     `Notify.tmp' and then (atomically where possible), rename it to
     `Notify'.

`Base'
     If watches are in use, then an `edit' command stores the original
     copy of the file in the `Base' directory.  This allows the
     `unedit' command to operate even if it is unable to communicate
     with the server.

`Baserev'
     The file lists the revision for each of the files in the `Base'
     directory.  The format is:

          BNAME/REV/EXPANSION

     where EXPANSION should be ignored, to allow for future expansion.

`Baserev.tmp'
     This file is to `Baserev' as `Entries.Backup' is to `Entries'.
     That is, to write `Baserev', first write the new contents to
     `Baserev.tmp' and then (atomically where possible), rename it to
     `Baserev'.

`Template'
     This file contains the template specified by the `rcsinfo' file
     (*note rcsinfo::).  It is only used by the client; the
     non-client/server CVS consults `rcsinfo' directly.


File: cvs.info,  Node: Intro administrative files,  Next: Multiple repositories,  Prev: Working directory storage,  Up: Repository

2.4 The administrative files
============================

The directory `$CVSROOT/CVSROOT' contains some "administrative files".
*Note Administrative files::, for a complete description.  You can use
CVS without any of these files, but some commands work better when at
least the `modules' file is properly set up.

   The most important of these files is the `modules' file.  It defines
all modules in the repository.  This is a sample `modules' file.

     CVSROOT         CVSROOT
     modules         CVSROOT modules
     cvs             gnu/cvs
     rcs             gnu/rcs
     diff            gnu/diff
     tc              yoyodyne/tc

   The `modules' file is line oriented.  In its simplest form each line
contains the name of the module, whitespace, and the directory where
the module resides.  The directory is a path relative to `$CVSROOT'.
The last four lines in the example above are examples of such lines.

   The line that defines the module called `modules' uses features that
are not explained here.  *Note modules::, for a full explanation of all
the available features.

2.4.1 Editing administrative files
----------------------------------

You edit the administrative files in the same way that you would edit
any other module.  Use `cvs checkout CVSROOT' to get a working copy,
edit it, and commit your changes in the normal way.

   It is possible to commit an erroneous administrative file.  You can
often fix the error and check in a new revision, but sometimes a
particularly bad error in the administrative file makes it impossible
to commit new revisions.


File: cvs.info,  Node: Multiple repositories,  Next: Creating a repository,  Prev: Intro administrative files,  Up: Repository

2.5 Multiple repositories
=========================

In some situations it is a good idea to have more than one repository,
for instance if you have two development groups that work on separate
projects without sharing any code.  All you have to do to have several
repositories is to specify the appropriate repository, using the
`CVSROOT' environment variable, the `-d' option to CVS, or (once you
have checked out a working directory) by simply allowing CVS to use the
repository that was used to check out the working directory (*note
Specifying a repository::).

   The big advantage of having multiple repositories is that they can
reside on different servers.  With CVS version 1.10, a single command
cannot recurse into directories from different repositories.  With
development versions of CVS, you can check out code from multiple
servers into your working directory.  CVS will recurse and handle all
the details of making connections to as many server machines as
necessary to perform the requested command.  Here is an example of how
to set up a working directory:

     cvs -d server1:/cvs co dir1
     cd dir1
     cvs -d server2:/root co sdir
     cvs update

   The `cvs co' commands set up the working directory, and then the
`cvs update' command will contact server2, to update the dir1/sdir
subdirectory, and server1, to update everything else.


File: cvs.info,  Node: Creating a repository,  Next: Backing up,  Prev: Multiple repositories,  Up: Repository

2.6 Creating a repository
=========================

This section describes how to set up a CVS repository for any sort of
access method.  After completing the setup described in this section,
you should be able to access your CVS repository immediately via the
local access method and several remote access methods.  For more
information on setting up remote access to the repository you create in
this section, please read the section on *Note Remote repositories::.

   To set up a CVS repository, first choose the machine and disk on
which you want to store the revision history of the source files.  CPU
and memory requirements are modest, so most machines should be
adequate.  For details see *Note Server requirements::.

   To estimate disk space requirements, if you are importing RCS files
from another system, the size of those files is the approximate initial
size of your repository, or if you are starting without any version
history, a rule of thumb is to allow for the server approximately three
times the size of the code to be under CVS for the repository (you will
eventually outgrow this, but not for a while).  On the machines on
which the developers will be working, you'll want disk space for
approximately one working directory for each developer (either the
entire tree or a portion of it, depending on what each developer uses).

   The repository should be accessible (directly or via a networked
file system) from all machines which want to use CVS in server or local
mode; the client machines need not have any access to it other than via
the CVS protocol.  It is not possible to use CVS to read from a
repository which one only has read access to; CVS needs to be able to
create lock files (*note Concurrency::).

   To create a repository, run the `cvs init' command.  It will set up
an empty repository in the CVS root specified in the usual way (*note
Repository::).  For example,

     cvs -d /usr/local/cvsroot init

   `cvs init' is careful to never overwrite any existing files in the
repository, so no harm is done if you run `cvs init' on an already
set-up repository.

   `cvs init' will enable history logging; if you don't want that,
remove the history file after running `cvs init'.  *Note history file::.


File: cvs.info,  Node: Backing up,  Next: Moving a repository,  Prev: Creating a repository,  Up: Repository

2.7 Backing up a repository
===========================

There is nothing particularly magical about the files in the
repository; for the most part it is possible to back them up just like
any other files.  However, there are a few issues to consider.

   The first is that to be paranoid, one should either not use CVS
during the backup, or have the backup program lock CVS while doing the
backup.  To not use CVS, you might forbid logins to machines which can
access the repository, turn off your CVS server, or similar mechanisms.
The details would depend on your operating system and how you have CVS
set up.  To lock CVS, you would create `#cvs.rfl' locks in each
repository directory.  See *Note Concurrency::, for more on CVS locks.
Having said all this, if you just back up without any of these
precautions, the results are unlikely to be particularly dire.
Restoring from backup, the repository might be in an inconsistent
state, but this would not be particularly hard to fix manually.

   When you restore a repository from backup, assuming that changes in
the repository were made after the time of the backup, working
directories which were not affected by the failure may refer to
revisions which no longer exist in the repository.  Trying to run CVS
in such directories will typically produce an error message.  One way
to get those changes back into the repository is as follows:

   * Get a new working directory.

   * Copy the files from the working directory from before the failure
     over to the new working directory (do not copy the contents of the
     `CVS' directories, of course).

   * Working in the new working directory, use commands such as `cvs
     update' and `cvs diff' to figure out what has changed, and then
     when you are ready, commit the changes into the repository.


File: cvs.info,  Node: Moving a repository,  Next: Remote repositories,  Prev: Backing up,  Up: Repository

2.8 Moving a repository
=======================

Just as backing up the files in the repository is pretty much like
backing up any other files, if you need to move a repository from one
place to another it is also pretty much like just moving any other
collection of files.

   The main thing to consider is that working directories point to the
repository.  The simplest way to deal with a moved repository is to
just get a fresh working directory after the move.  Of course, you'll
want to make sure that the old working directory had been checked in
before the move, or you figured out some other way to make sure that
you don't lose any changes.  If you really do want to reuse the existing
working directory, it should be possible with manual surgery on the
`CVS/Repository' files.  You can see *Note Working directory storage::,
for information on the `CVS/Repository' and `CVS/Root' files, but
unless you are sure you want to bother, it probably isn't worth it.


File: cvs.info,  Node: Remote repositories,  Next: Read-only access,  Prev: Moving a repository,  Up: Repository

2.9 Remote repositories
=======================

Your working copy of the sources can be on a different machine than the
repository.  Using CVS in this manner is known as "client/server"
operation.  You run CVS on a machine which can mount your working
directory, known as the "client", and tell it to communicate to a
machine which can mount the repository, known as the "server".
Generally, using a remote repository is just like using a local one,
except that the format of the repository name is:

     [:METHOD:][[USER][:PASSWORD]@]HOSTNAME[:[PORT]]/path/to/repository

   Specifying a password in the repository name is not recommended
during checkout, since this will cause CVS to store a cleartext copy of
the password in each created directory.  `cvs login' first instead
(*note Password authentication client::).

   The details of exactly what needs to be set up depend on how you are
connecting to the server.

* Menu:

* Server requirements::         Memory and other resources for servers
* The connection method::       Connection methods and method options
* Connecting via rsh::          Using the `rsh' program to connect
* Password authenticated::      Direct connections using passwords
* GSSAPI authenticated::        Direct connections using GSSAPI
* Kerberos authenticated::      Direct connections with Kerberos
* Connecting via fork::         Using a forked `cvs server' to connect
* Write proxies::               Distributing load across several CVS servers


File: cvs.info,  Node: Server requirements,  Next: The connection method,  Up: Remote repositories

2.9.1 Server requirements
-------------------------

The quick answer to what sort of machine is suitable as a server is
that requirements are modest--a server with 32M of memory or even less
can handle a fairly large source tree with a fair amount of activity.

   The real answer, of course, is more complicated.  Estimating the
known areas of large memory consumption should be sufficient to
estimate memory requirements.  There are two such areas documented
here; other memory consumption should be small by comparison (if you
find that is not the case, let us know, as described in *Note BUGS::,
so we can update this documentation).

   The first area of big memory consumption is large checkouts, when
using the CVS server.  The server consists of two processes for each
client that it is serving.  Memory consumption on the child process
should remain fairly small.  Memory consumption on the parent process,
particularly if the network connection to the client is slow, can be
expected to grow to slightly more than the size of the sources in a
single directory, or two megabytes, whichever is larger.

   Multiplying the size of each CVS server by the number of servers
which you expect to have active at one time should give an idea of
memory requirements for the server.  For the most part, the memory
consumed by the parent process probably can be swap space rather than
physical memory.

   The second area of large memory consumption is `diff', when checking
in large files.  This is required even for binary files.  The rule of
thumb is to allow about ten times the size of the largest file you will
want to check in, although five times may be adequate.  For example, if
you want to check in a file which is 10 megabytes, you should have 100
megabytes of memory on the machine doing the checkin (the server
machine for client/server, or the machine running CVS for
non-client/server).  This can be swap space rather than physical
memory.  Because the memory is only required briefly, there is no
particular need to allow memory for more than one such checkin at a
time.

   Resource consumption for the client is even more modest--any machine
with enough capacity to run the operating system in question should
have little trouble.

   For information on disk space requirements, see *Note Creating a
repository::.


File: cvs.info,  Node: The connection method,  Next: Connecting via rsh,  Prev: Server requirements,  Up: Remote repositories

2.9.2 The connection method
---------------------------

In its simplest form, the METHOD portion of the repository string
(*note Remote repositories::) may be one of `ext', `fork', `gserver',
`kserver', `local', `pserver', and, on some platforms, `server'.

   If METHOD is not specified, and the repository name starts with a
`/', then the default is `local'.  If METHOD is not specified, and the
repository name does not start with a `/', then the default is `ext' or
`server', depending on your platform; both the `ext' and `server'
methods are described in *Note Connecting via rsh::.

   The `ext', `fork', `gserver', and `pserver' connection methods all
accept optional method options, specified as part of the METHOD string,
like so:

     :METHOD[;OPTION=ARG...]:OTHER_CONNECTION_DATA

   CVS is not sensitive to the case of METHOD or OPTION, though it may
sometimes be sensitive to the case of ARG.  The possible method options
are as follows:

`proxy=HOSTNAME'
`proxyport=PORT'
     These two method options can be used to connect via an HTTP tunnel
     style web proxy.  HOSTNAME should be the name of the HTTP proxy
     server to connect through and PORT is the port number on the HTTP
     proxy server to connect via.  PORT defaults to 8080.

     *NOTE_ An HTTP proxy server is not the same as a CVS write proxy
     server - please see *Note Write proxies:: for more on CVS write
     proxies.*

     For example, to connect pserver via a web proxy listening on port
     8000 of www.myproxy.net, you would use a method of:

          :pserver;proxy=www.myproxy.net;proxyport=8000:PSERVER_CONNECTION_STRING

     *NOTE_ In the above example, PSERVER_CONNECTION_STRING is still
     required to connect and authenticate to the CVS server, as noted
     in the upcoming sections on password authentication, `gserver', and
     `kserver'.  The example above only demonstrates a modification to
     the METHOD portion of the repository name.*

     These options first appeared in CVS version 1.12.7 and are valid as
     modifcations to the `gserver' and `pserver' connection methods.

`CVS_RSH=PATH'
     This method option can be used with the `ext' method to specify
     the path the CVS client will use to find the remote shell used to
     contact the CVS server and takes precedence over any path
     specified in the `$CVS_RSH' environment variable (*note Connecting
     via rsh::).  For example, to connect to a CVS server via the local
     `/path/to/ssh/command' command, you could choose to specify the
     following PATH via the `CVS_RSH' method option:

          :ext;CVS_RSH=/path/to/ssh/command:EXT_CONNECTION_STRING

     This method option first appeared in CVS version 1.12.11 and is
     valid only as a modifcation to the `ext' connection method.

`CVS_SERVER=PATH'
     This method option can be used with the `ext' and `fork' methods to
     specify the path CVS will use to find the CVS executable on the
     CVS server and takes precedence over any path specified in the
     `$CVS_SERVER' environment variable (*note Connecting via rsh::).
     For example, to select the remote `/path/to/cvs/command'
     executable as your CVS server application on the CVS server
     machine, you could choose to specify the following PATH via the
     `CVS_SERVER' method option:

          :ext;CVS_SERVER=/path/to/cvs/command:EXT_CONNECTION_STRING

     or, to select an executable named `cvs-1.12.11', assuming it is in
     your `$PATH' on the CVS server:

          :ext;CVS_SERVER=cvs-1.12.11:EXT_CONNECTION_STRING

     This method option first appeared in CVS version 1.12.11 and is
     valid as a modifcation to both the `ext' and `fork' connection
     methods.

`Redirect=BOOLEAN-STATE'
     The `Redirect' method option determines whether the CVS client will
     allow a CVS server to redirect it to a different CVS server,
     usually for write requests, as in a write proxy setup.

     A BOOLEAN-STATE of any value acceptable for boolean
     `CVSROOT/config' file options is acceptable here (*note config::).
     For example, `on', `off', `true', and `false' are all valid
     values for BOOLEAN-STATE.  BOOLEAN-STATE for the `Redirect' method
     option defaults to `on'.

     This option will have no effect when talking to any non-secondary
     CVS server.  For more on write proxies and secondary servers,
     please see *Note Write proxies::.

     This method option first appeared in CVS version 1.12.11 and is
     valid only as a modifcation to the `ext' connection method.

   As a further example, to combine both the `CVS_RSH' and `CVS_SERVER'
options, a method specification like the following would work:

     :ext;CVS_RSH=/path/to/ssh/command;CVS_SERVER=/path/to/cvs/command:

   This means that you would not need to have the `CVS_SERVER' or
`CVS_RSH' environment variables set correctly.  See *Note Connecting
via rsh::, for more details on these environment variables.


File: cvs.info,  Node: Connecting via rsh,  Next: Password authenticated,  Prev: The connection method,  Up: Remote repositories

2.9.3 Connecting with rsh
-------------------------

CVS uses the `rsh' protocol to perform these operations, so the remote
user host needs to have a `.rhosts' file which grants access to the
local user. Note that the program that CVS uses for this purpose may be
specified using the `--with-rsh' flag to configure.

   For example, suppose you are the user `mozart' on the local machine
`toe.example.com', and the server machine is `faun.example.org'.  On
faun, put the following line into the file `.rhosts' in `bach''s home
directory:

     toe.example.com  mozart

Then test that `rsh' is working with

     rsh -l bach faun.example.org 'echo $PATH'

   Next you have to make sure that `rsh' will be able to find the
server.  Make sure that the path which `rsh' printed in the above
example includes the directory containing a program named `cvs' which
is the server.  You need to set the path in `.bashrc', `.cshrc', etc.,
not `.login' or `.profile'.  Alternately, you can set the environment
variable `CVS_SERVER' on the client machine to the filename of the
server you want to use, for example `/usr/local/bin/cvs-1.6'.  For the
`ext' and `fork' methods, you may also specify CVS_SERVER as an otpion
in the CVSROOT so that you may use different servers for differnt
roots. See *Note Remote repositories:: for more details.

   There is no need to edit `inetd.conf' or start a CVS server daemon.

   There are two access methods that you use in `CVSROOT' for rsh.
`:server:' specifies an internal rsh client, which is supported only by
some CVS ports.  `:ext:' specifies an external rsh program.  By default
this is `rsh' (unless otherwise specified by the `--with-rsh' flag to
configure) but you may set the `CVS_RSH' environment variable to invoke
another program which can access the remote server (for example,
`remsh' on HP-UX 9 because `rsh' is something different).  It must be a
program which can transmit data to and from the server without modifying
it; for example the Windows NT `rsh' is not suitable since it by
default translates between CRLF and LF.  The OS/2 CVS port has a hack
to pass `-b' to `rsh' to get around this, but since this could
potentially cause problems for programs other than the standard `rsh',
it may change in the future.  If you set `CVS_RSH' to `SSH' or some
other rsh replacement, the instructions in the rest of this section
concerning `.rhosts' and so on are likely to be inapplicable; consult
the documentation for your rsh replacement.

   You may choose to specify the CVS_RSH option as a method option in
the CVSROOT string to allow you to use different connection tools for
different roots (*note The connection method::).  For example, allowing
some roots to use `CVS_RSH=remsh' and some to use `CVS_RSH=ssh' for the
`ext' method.  See also the *Note Remote repositories:: for more
details.

   Continuing our example, supposing you want to access the module
`foo' in the repository `/usr/local/cvsroot/', on machine
`faun.example.org', you are ready to go:

     cvs -d :ext:bach@faun.example.org:/usr/local/cvsroot checkout foo

(The `bach@' can be omitted if the username is the same on both the
local and remote hosts.)


File: cvs.info,  Node: Password authenticated,  Next: GSSAPI authenticated,  Prev: Connecting via rsh,  Up: Remote repositories

2.9.4 Direct connection with password authentication
----------------------------------------------------

The CVS client can also connect to the server using a password
protocol.  This is particularly useful if using `rsh' is not feasible
(for example, the server is behind a firewall), and Kerberos also is
not available.

   To use this method, it is necessary to make some adjustments on both
the server and client sides.

* Menu:

* Password authentication server::     Setting up the server
* Password authentication client::     Using the client
* Password authentication security::   What this method does and does not do


File: cvs.info,  Node: Password authentication server,  Next: Password authentication client,  Up: Password authenticated

2.9.4.1 Setting up the server for password authentication
.........................................................

First of all, you probably want to tighten the permissions on the
`$CVSROOT' and `$CVSROOT/CVSROOT' directories.  See *Note Password
authentication security::, for more details.

   On the server side, the file `/etc/inetd.conf' needs to be edited so
`inetd' knows to run the command `cvs pserver' when it receives a
connection on the right port.  By default, the port number is 2401; it
would be different if your client were compiled with `CVS_AUTH_PORT'
defined to something else, though.  This can also be specified in the
CVSROOT variable (*note Remote repositories::) or overridden with the
CVS_CLIENT_PORT environment variable (*note Environment variables::).

   If your `inetd' allows raw port numbers in `/etc/inetd.conf', then
the following (all on a single line in `inetd.conf') should be
sufficient:

     2401  stream  tcp  nowait  root  /usr/local/bin/cvs
     cvs -f --allow-root=/usr/cvsroot pserver

(You could also use the `-T' option to specify a temporary directory.)

   The `--allow-root' option specifies the allowable CVSROOT directory.
Clients which attempt to use a different CVSROOT directory will not be
allowed to connect.  If there is more than one CVSROOT directory which
you want to allow, repeat the option.  (Unfortunately, many versions of
`inetd' have very small limits on the number of arguments and/or the
total length of the command.  The usual solution to this problem is to
have `inetd' run a shell script which then invokes CVS with the
necessary arguments.)

   If your `inetd' wants a symbolic service name instead of a raw port
number, then put this in `/etc/services':

     cvspserver      2401/tcp

and put `cvspserver' instead of `2401' in `inetd.conf'.

   If your system uses `xinetd' instead of `inetd', the procedure is
slightly different.  Create a file called `/etc/xinetd.d/cvspserver'
containing the following:

     service cvspserver
     {
        port        = 2401
        socket_type = stream
        protocol    = tcp
        wait        = no
        user        = root
        passenv     = PATH
        server      = /usr/local/bin/cvs
        server_args = -f --allow-root=/usr/cvsroot pserver
     }

(If `cvspserver' is defined in `/etc/services', you can omit the `port'
line.)

   Once the above is taken care of, restart your `inetd', or do
whatever is necessary to force it to reread its initialization files.

   If you are having trouble setting this up, see *Note Connection::.

   Because the client stores and transmits passwords in cleartext
(almost--see *Note Password authentication security::, for details), a
separate CVS password file is generally used, so people don't compromise
their regular passwords when they access the repository.  This file is
`$CVSROOT/CVSROOT/passwd' (*note Intro administrative files::).  It
uses a colon-separated format, similar to `/etc/passwd' on Unix systems,
except that it has fewer fields: CVS username, optional password, and
an optional system username for CVS to run as if authentication
succeeds.  Here is an example `passwd' file with five entries:

     anonymous:
     bach:ULtgRLXo7NRxs
     spwang:1sOp854gDF3DY
     melissa:tGX1fS8sun6rY:pubcvs
     qproj:XR4EZcEs0szik:pubcvs

(The passwords are encrypted according to the standard Unix `crypt()'
function, so it is possible to paste in passwords directly from regular
Unix `/etc/passwd' files.)

   The first line in the example will grant access to any CVS client
attempting to authenticate as user `anonymous', no matter what password
they use, including an empty password.  (This is typical for sites
granting anonymous read-only access; for information on how to do the
"read-only" part, see *Note Read-only access::.)

   The second and third lines will grant access to `bach' and `spwang'
if they supply their respective plaintext passwords.

   The fourth line will grant access to `melissa', if she supplies the
correct password, but her CVS operations will actually run on the
server side under the system user `pubcvs'.  Thus, there need not be
any system user named `melissa', but there _must_ be one named `pubcvs'.

   The fifth line shows that system user identities can be shared: any
client who successfully authenticates as `qproj' will actually run as
`pubcvs', just as `melissa' does.  That way you could create a single,
shared system user for each project in your repository, and give each
developer their own line in the `$CVSROOT/CVSROOT/passwd' file.  The CVS
username on each line would be different, but the system username would
be the same.  The reason to have different CVS usernames is that CVS
will log their actions under those names: when `melissa' commits a
change to a project, the checkin is recorded in the project's history
under the name `melissa', not `pubcvs'.  And the reason to have them
share a system username is so that you can arrange permissions in the
relevant area of the repository such that only that account has
write-permission there.

   If the system-user field is present, all password-authenticated CVS
commands run as that user; if no system user is specified, CVS simply
takes the CVS username as the system username and runs commands as that
user.  In either case, if there is no such user on the system, then the
CVS operation will fail (regardless of whether the client supplied a
valid password).

   The password and system-user fields can both be omitted (and if the
system-user field is omitted, then also omit the colon that would have
separated it from the encrypted password).  For example, this would be a
valid `$CVSROOT/CVSROOT/passwd' file:

     anonymous::pubcvs
     fish:rKa5jzULzmhOo:kfogel
     sussman:1sOp854gDF3DY

When the password field is omitted or empty, then the client's
authentication attempt will succeed with any password, including the
empty string.  However, the colon after the CVS username is always
necessary, even if the password is empty.

   CVS can also fall back to use system authentication.  When
authenticating a password, the server first checks for the user in the
`$CVSROOT/CVSROOT/passwd' file.  If it finds the user, it will use that
entry for authentication as described above.  But if it does not find
the user, or if the CVS `passwd' file does not exist, then the server
can try to authenticate the username and password using the operating
system's user-lookup routines (this "fallback" behavior can be disabled
by setting `SystemAuth=no' in the CVS `config' file, *note config::).

   The default fallback behavior is to look in `/etc/passwd' for this
system user unless your system has PAM (Pluggable Authentication
Modules) and your CVS server executable was configured to use it at
compile time (using `./configure --enable-pam' - see the INSTALL file
for more).  In this case, PAM will be consulted instead.  This means
that CVS can be configured to use any password authentication source
PAM can be configured to use (possibilities include a simple UNIX
password, NIS, LDAP, and others) in its global configuration file
(usually `/etc/pam.conf' or possibly `/etc/pam.d/cvs').  See your PAM
documentation for more details on PAM configuration.

   Note that PAM is an experimental feature in CVS and feedback is
encouraged.  Please send a mail to one of the CVS mailing lists
(`info-cvs@nongnu.org' or `bug-cvs@nongnu.org') if you use the CVS PAM
support.

   *WARNING: Using PAM gives the system administrator much more
flexibility about how CVS users are authenticated but no more security
than other methods.  See below for more.*

   CVS needs an "auth", "account" and "session" module in the PAM
configuration file. A typical PAM configuration would therefore have
the following lines in `/etc/pam.conf' to emulate the standard CVS
system `/etc/passwd' authentication:

     cvs	auth	    required	pam_unix.so
     cvs	account	    required	pam_unix.so
     cvs	session	    required	pam_unix.so

   The the equivalent `/etc/pam.d/cvs' would contain

     auth	    required	pam_unix.so
     account	    required	pam_unix.so
     session	    required	pam_unix.so

   Some systems require a full path to the module so that `pam_unix.so'
(Linux) would become something like
`/usr/lib/security/$ISA/pam_unix.so.1' (Sun Solaris).  See the
`contrib/pam' subdirectory of the CVS source distribution for further
example configurations.

   The PAM service name given above as "cvs" is just the service name
in the default configuration and can be set using `./configure
--with-hardcoded-pam-service-name=<pam-service-name>' before compiling.
CVS can also be configured to use whatever name it is invoked as as
its PAM service name using `./configure
--without-hardcoded-pam-service-name', but this feature should not be
used if you may not have control of the name CVS will be invoked as.

   Be aware, also, that falling back to system authentication might be
a security risk: CVS operations would then be authenticated with that
user's regular login password, and the password flies across the
network in plaintext.  See *Note Password authentication security:: for
more on this.  This may be more of a problem with PAM authentication
because it is likely that the source of the system password is some
central authentication service like LDAP which is also used to
authenticate other services.

   On the other hand, PAM makes it very easy to change your password
regularly.  If they are given the option of a one-password system for
all of their activities, users are often more willing to change their
password on a regular basis.

   In the non-PAM configuration where the password is stored in the
`CVSROOT/passwd' file, it is difficult to change passwords on a regular
basis since only administrative users (or in some cases processes that
act as an administrative user) are typically given access to modify
this file.  Either there needs to be some hand-crafted web page or
set-uid program to update the file, or the update needs to be done by
submitting a request to an administrator to perform the duty by hand.
In the first case, having to remember to update a separate password on
a periodic basis can be difficult.  In the second case, the manual
nature of the change will typically mean that the password will not be
changed unless it is absolutely necessary.

   Note that PAM administrators should probably avoid configuring
one-time-passwords (OTP) for CVS authentication/authorization.  If OTPs
are desired, the administrator may wish to encourage the use of one of
the other Client/Server access methods.  See the section on *note
Remote repositories:: for a list of other methods.

   Right now, the only way to put a password in the CVS `passwd' file
is to paste it there from somewhere else.  Someday, there may be a `cvs
passwd' command.

   Unlike many of the files in `$CVSROOT/CVSROOT', it is normal to edit
the `passwd' file in-place, rather than via CVS.  This is because of the
possible security risks of having the `passwd' file checked out to
people's working copies.  If you do want to include the `passwd' file
in checkouts of `$CVSROOT/CVSROOT', see *Note checkoutlist::.


File: cvs.info,  Node: Password authentication client,  Next: Password authentication security,  Prev: Password authentication server,  Up: Password authenticated

2.9.4.2 Using the client with password authentication
.....................................................

To run a CVS command on a remote repository via the
password-authenticating server, one specifies the `pserver' protocol,
optional username, repository host, an optional port number, and path
to the repository.  For example:

     cvs -d :pserver:faun.example.org:/usr/local/cvsroot checkout someproj

or

     CVSROOT=:pserver:bach@faun.example.org:2401/usr/local/cvsroot
     cvs checkout someproj

   However, unless you're connecting to a public-access repository
(i.e., one where that username doesn't require a password), you'll need
to supply a password or "log in" first.  Logging in verifies your
password with the repository and stores it in a file.  It's done with
the `login' command, which will prompt you interactively for the
password if you didn't supply one as part of $CVSROOT:

     cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot login
     CVS password:

or

     cvs -d :pserver:bach:p4ss30rd@faun.example.org:/usr/local/cvsroot login

   After you enter the password, CVS verifies it with the server.  If
the verification succeeds, then that combination of username, host,
repository, and password is permanently recorded, so future
transactions with that repository won't require you to run `cvs login'.
(If verification fails, CVS will exit complaining that the password
was incorrect, and nothing will be recorded.)

   The records are stored, by default, in the file `$HOME/.cvspass'.
That file's format is human-readable, and to a degree human-editable,
but note that the passwords are not stored in cleartext--they are
trivially encoded to protect them from "innocent" compromise (i.e.,
inadvertent viewing by a system administrator or other non-malicious
person).

   You can change the default location of this file by setting the
`CVS_PASSFILE' environment variable.  If you use this variable, make
sure you set it _before_ `cvs login' is run.  If you were to set it
after running `cvs login', then later CVS commands would be unable to
look up the password for transmission to the server.

   Once you have logged in, all CVS commands using that remote
repository and username will authenticate with the stored password.
So, for example

     cvs -d :pserver:bach@faun.example.org:/usr/local/cvsroot checkout foo

should just work (unless the password changes on the server side, in
which case you'll have to re-run `cvs login').

   Note that if the `:pserver:' were not present in the repository
specification, CVS would assume it should use `rsh' to connect with the
server instead (*note Connecting via rsh::).

   Of course, once you have a working copy checked out and are running
CVS commands from within it, there is no longer any need to specify the
repository explicitly, because CVS can deduce the repository from the
working copy's `CVS' subdirectory.

   The password for a given remote repository can be removed from the
`CVS_PASSFILE' by using the `cvs logout' command.


File: cvs.info,  Node: Password authentication security,  Prev: Password authentication client,  Up: Password authenticated

2.9.4.3 Security considerations with password authentication
............................................................

The passwords are stored on the client side in a trivial encoding of
the cleartext, and transmitted in the same encoding.  The encoding is
done only to prevent inadvertent password compromises (i.e., a system
administrator accidentally looking at the file), and will not prevent
even a naive attacker from gaining the password.

   The separate CVS password file (*note Password authentication
server::) allows people to use a different password for repository
access than for login access.  On the other hand, once a user has
non-read-only access to the repository, she can execute programs on the
server system through a variety of means.  Thus, repository access
implies fairly broad system access as well.  It might be possible to
modify CVS to prevent that, but no one has done so as of this writing.

   Note that because the `$CVSROOT/CVSROOT' directory contains `passwd'
and other files which are used to check security, you must control the
permissions on this directory as tightly as the permissions on `/etc'.
The same applies to the `$CVSROOT' directory itself and any directory
above it in the tree.  Anyone who has write access to such a directory
will have the ability to become any user on the system.  Note that
these permissions are typically tighter than you would use if you are
not using pserver.

   In summary, anyone who gets the password gets repository access
(which may imply some measure of general system access as well).  The
password is available to anyone who can sniff network packets or read a
protected (i.e., user read-only) file.  If you want real security, get
Kerberos.


File: cvs.info,  Node: GSSAPI authenticated,  Next: Kerberos authenticated,  Prev: Password authenticated,  Up: Remote repositories

2.9.5 Direct connection with GSSAPI
-----------------------------------

GSSAPI is a generic interface to network security systems such as
Kerberos 5.  If you have a working GSSAPI library, you can have CVS
connect via a direct TCP connection, authenticating with GSSAPI.

   To do this, CVS needs to be compiled with GSSAPI support; when
configuring CVS it tries to detect whether GSSAPI libraries using
Kerberos version 5 are present.  You can also use the `--with-gssapi'
flag to configure.

   The connection is authenticated using GSSAPI, but the message stream
is _not_ authenticated by default.  You must use the `-a' global option
to request stream authentication.

   The data transmitted is _not_ encrypted by default.  Encryption
support must be compiled into both the client and the server; use the
`--enable-encrypt' configure option to turn it on.  You must then use
the `-x' global option to request encryption.

   GSSAPI connections are handled on the server side by the same server
which handles the password authentication server; see *Note Password
authentication server::.  If you are using a GSSAPI mechanism such as
Kerberos which provides for strong authentication, you will probably
want to disable the ability to authenticate via cleartext passwords.
To do so, create an empty `CVSROOT/passwd' password file, and set
`SystemAuth=no' in the config file (*note config::).

   The GSSAPI server uses a principal name of cvs/HOSTNAME, where
HOSTNAME is the canonical name of the server host.  You will have to
set this up as required by your GSSAPI mechanism.

   To connect using GSSAPI, use the `:gserver:' method.  For example,

     cvs -d :gserver:faun.example.org:/usr/local/cvsroot checkout foo


File: cvs.info,  Node: Kerberos authenticated,  Next: Connecting via fork,  Prev: GSSAPI authenticated,  Up: Remote repositories

2.9.6 Direct connection with Kerberos
-------------------------------------

The easiest way to use Kerberos is to use the Kerberos `rsh', as
described in *Note Connecting via rsh::.  The main disadvantage of
using rsh is that all the data needs to pass through additional
programs, so it may be slower.  So if you have Kerberos installed you
can connect via a direct TCP connection, authenticating with Kerberos.

   This section concerns the Kerberos network security system, version
4.  Kerberos version 5 is supported via the GSSAPI generic network
security interface, as described in the previous section.

   To do this, CVS needs to be compiled with Kerberos support; when
configuring CVS it tries to detect whether Kerberos is present or you
can use the `--with-krb4' flag to configure.

   The data transmitted is _not_ encrypted by default.  Encryption
support must be compiled into both the client and server; use the
`--enable-encryption' configure option to turn it on.  You must then
use the `-x' global option to request encryption.

   The CVS client will attempt to connect to port 1999 by default.

   When you want to use CVS, get a ticket in the usual way (generally
`kinit'); it must be a ticket which allows you to log into the server
machine.  Then you are ready to go:

     cvs -d :kserver:faun.example.org:/usr/local/cvsroot checkout foo

   Previous versions of CVS would fall back to a connection via rsh;
this version will not do so.


File: cvs.info,  Node: Connecting via fork,  Next: Write proxies,  Prev: Kerberos authenticated,  Up: Remote repositories

2.9.7 Connecting with fork
--------------------------

This access method allows you to connect to a repository on your local
disk via the remote protocol.  In other words it does pretty much the
same thing as `:local:', but various quirks, bugs and the like are
those of the remote CVS rather than the local CVS.

   For day-to-day operations you might prefer either `:local:' or
`:fork:', depending on your preferences.  Of course `:fork:' comes in
particularly handy in testing or debugging `cvs' and the remote
protocol.  Specifically, we avoid all of the network-related
setup/configuration, timeouts, and authentication inherent in the other
remote access methods but still create a connection which uses the
remote protocol.

   To connect using the `fork' method, use `:fork:' and the pathname to
your local repository.  For example:

     cvs -d :fork:/usr/local/cvsroot checkout foo

   As with `:ext:', the server is called `cvs' by default, or the value
of the `CVS_SERVER' environment variable.


File: cvs.info,  Node: Write proxies,  Prev: Connecting via fork,  Up: Remote repositories

2.9.8 Distributing load across several CVS servers
--------------------------------------------------

CVS can be configured to distribute usage across several CVS servers.
This is accomplished by means of one or more "write proxies", or
"secondary servers", for a single "primary server".

   When a CVS client accesses a secondary server and only sends read
requests, then the secondary server handles the entire request.  If the
client sends any write requests, however, the secondary server asks the
client to redirect its write request to the primary server, if the
client supports redirect requests, and otherwise becomes a transparent
proxy for the primary server, which actually handles the write request.

   In this manner, any number of read-only secondary servers may be
configured as write proxies for the primary server, effectively
distributing the load from all read operations between the secondary
servers and restricting the load on the primary server to write
operations and pushing changes to the secondaries.

   Primary servers will not automatically push changes to secondaries.
This must be configured via `loginfo', `postadmin', `posttag', &
`postwatch' scripts (*note Trigger Scripts::) like the following:

     ALL	rsync -gopr -essh ./ secondary:/cvsroot/%p &

   You would probably actually want to lock directories for write on
the secondary and for read on the primary before running the `rsync' in
the above example, but describing such a setup is beyond the scope of
this document.

   A secondary advantage of a write proxy setup is that users pointing
at the secondary server can still execute fast read operations while on
a network that connects to the primary over a slow link or even one
where the link to the primary is periodically broken.  Only write
operations will require the network link to the primary.

   To configure write proxies, the primary must be specified with the
`PrimaryServer' option in `CVSROOT/config' (*note config::).  For the
transparent proxy mode to work, all secondary servers must also be
running the same version of the CVS server, or at least one that
provides the same list of supported requests to the client as the
primary server.  This is not necessary for redirection.

   Once a primary server is configured, secondary servers may be
configured by:

  1. Duplicating the primary repository at the new location.

  2. Setting up the `loginfo', `postadmin', `posttag', and `postwatch'
     files on the primary to propagate writes to the new secondary.

  3. Configure remote access to the secondary(ies) as you would
     configure access to any other CVS server (*note Remote
     repositories::).

  4. Ensuring that `--allow-root=SECONDARY-CVSROOT' is passed to *all*
     incovations of the secondary server if the path to the CVS
     repository directory is different on the two servers and you wish
     to support clients that do not handle the `Redirect' resopnse (CVS
     1.12.9 and earlier clients do not handle the `Redirect' response).

     Please note, again, that writethrough proxy suport requires
     `--allow-root=SECONDARY-CVSROOT' to be specified for *all*
     incovations of the secondary server, not just `pserver'
     invocations.  This may require a wrapper script for the CVS
     executable on your server machine.


File: cvs.info,  Node: Read-only access,  Next: Server temporary directory,  Prev: Remote repositories,  Up: Repository

2.10 Read-only repository access
================================

It is possible to grant read-only repository access to people using the
password-authenticated server (*note Password authenticated::).  (The
other access methods do not have explicit support for read-only users
because those methods all assume login access to the repository machine
anyway, and therefore the user can do whatever local file permissions
allow her to do.)

   A user who has read-only access can do only those CVS operations
which do not modify the repository, except for certain "administrative"
files (such as lock files and the history file).  It may be desirable
to use this feature in conjunction with user-aliasing (*note Password
authentication server::).

   Unlike with previous versions of CVS, read-only users should be able
merely to read the repository, and not to execute programs on the
server or otherwise gain unexpected levels of access.  Or to be more
accurate, the _known_ holes have been plugged.  Because this feature is
new and has not received a comprehensive security audit, you should use
whatever level of caution seems warranted given your attitude concerning
security.

   There are two ways to specify read-only access for a user: by
inclusion, and by exclusion.

   "Inclusion" means listing that user specifically in the
`$CVSROOT/CVSROOT/readers' file, which is simply a newline-separated
list of users.  Here is a sample `readers' file:

     melissa
     splotnik
     jrandom

(Don't forget the newline after the last user.)

   "Exclusion" means explicitly listing everyone who has _write_
access--if the file

     $CVSROOT/CVSROOT/writers

exists, then only those users listed in it have write access, and
everyone else has read-only access (of course, even the read-only users
still need to be listed in the CVS `passwd' file).  The `writers' file
has the same format as the `readers' file.

   Note: if your CVS `passwd' file maps cvs users onto system users
(*note Password authentication server::), make sure you deny or grant
read-only access using the _cvs_ usernames, not the system usernames.
That is, the `readers' and `writers' files contain cvs usernames, which
may or may not be the same as system usernames.

   Here is a complete description of the server's behavior in deciding
whether to grant read-only or read-write access:

   If `readers' exists, and this user is listed in it, then she gets
read-only access.  Or if `writers' exists, and this user is NOT listed
in it, then she also gets read-only access (this is true even if
`readers' exists but she is not listed there).  Otherwise, she gets
full read-write access.

   Of course there is a conflict if the user is listed in both files.
This is resolved in the more conservative way, it being better to
protect the repository too much than too little: such a user gets
read-only access.


File: cvs.info,  Node: Server temporary directory,  Prev: Read-only access,  Up: Repository

2.11 Temporary directories for the server
=========================================

While running, the CVS server creates temporary directories.  They are
named

     cvs-servPID

where PID is the process identification number of the server.  They are
located in the directory specified by the `-T' global option (*note
Global options::), the `TMPDIR' environment variable (*note Environment
variables::), or, failing that, `/tmp'.

   In most cases the server will remove the temporary directory when it
is done, whether it finishes normally or abnormally.  However, there
are a few cases in which the server does not or cannot remove the
temporary directory, for example:

   * If the server aborts due to an internal server error, it may
     preserve the directory to aid in debugging

   * If the server is killed in a way that it has no way of cleaning up
     (most notably, `kill -KILL' on unix).

   * If the system shuts down without an orderly shutdown, which tells
     the server to clean up.

   In cases such as this, you will need to manually remove the
`cvs-servPID' directories.  As long as there is no server running with
process identification number PID, it is safe to do so.


File: cvs.info,  Node: Starting a new project,  Next: Revisions,  Prev: Repository,  Up: Top

3 Starting a project with CVS
*****************************

Because renaming files and moving them between directories is somewhat
inconvenient, the first thing you do when you start a new project
should be to think through your file organization.  It is not impossible
to rename or move files, but it does increase the potential for
confusion and CVS does have some quirks particularly in the area of
renaming directories.  *Note Moving files::.

   What to do next depends on the situation at hand.

* Menu:

* Setting up the files::        Getting the files into the repository
* Defining the module::         How to make a module of the files


File: cvs.info,  Node: Setting up the files,  Next: Defining the module,  Up: Starting a new project

3.1 Setting up the files
========================

The first step is to create the files inside the repository.  This can
be done in a couple of different ways.

* Menu:

* From files::                  This method is useful with old projects
                                where files already exists.
* From other version control systems::  Old projects where you want to
                                        preserve history from another system.
* From scratch::                Creating a directory tree from scratch.


File: cvs.info,  Node: From files,  Next: From other version control systems,  Up: Setting up the files

3.1.1 Creating a directory tree from a number of files
------------------------------------------------------

When you begin using CVS, you will probably already have several
projects that can be put under CVS control.  In these cases the easiest
way is to use the `import' command.  An example is probably the easiest
way to explain how to use it.  If the files you want to install in CVS
reside in `WDIR', and you want them to appear in the repository as
`$CVSROOT/yoyodyne/RDIR', you can do this:

     $ cd WDIR
     $ cvs import -m "Imported sources" yoyodyne/RDIR yoyo start

   Unless you supply a log message with the `-m' flag, CVS starts an
editor and prompts for a message.  The string `yoyo' is a "vendor tag",
and `start' is a "release tag".  They may fill no purpose in this
context, but since CVS requires them they must be present.  *Note
Tracking sources::, for more information about them.

   You can now verify that it worked, and remove your original source
directory.

     $ cd ..
     $ cvs checkout yoyodyne/RDIR       # Explanation below
     $ diff -r WDIR yoyodyne/RDIR
     $ rm -r WDIR

Erasing the original sources is a good idea, to make sure that you do
not accidentally edit them in WDIR, bypassing CVS.  Of course, it would
be wise to make sure that you have a backup of the sources before you
remove them.

   The `checkout' command can either take a module name as argument (as
it has done in all previous examples) or a path name relative to
`$CVSROOT', as it did in the example above.

   It is a good idea to check that the permissions CVS sets on the
directories inside `$CVSROOT' are reasonable, and that they belong to
the proper groups.  *Note File permissions::.

   If some of the files you want to import are binary, you may want to
use the wrappers features to specify which files are binary and which
are not.  *Note Wrappers::.


File: cvs.info,  Node: From other version control systems,  Next: From scratch,  Prev: From files,  Up: Setting up the files

3.1.2 Creating Files From Other Version Control Systems
-------------------------------------------------------

If you have a project which you are maintaining with another version
control system, such as RCS, you may wish to put the files from that
project into CVS, and preserve the revision history of the files.

From RCS
     If you have been using RCS, find the RCS files--usually a file
     named `foo.c' will have its RCS file in `RCS/foo.c,v' (but it
     could be other places; consult the RCS documentation for details).
     Then create the appropriate directories in CVS if they do not
     already exist.  Then copy the files into the appropriate
     directories in the CVS repository (the name in the repository must
     be the name of the source file with `,v' added; the files go
     directly in the appropriate directory of the repository, not in an
     `RCS' subdirectory).  This is one of the few times when it is a
     good idea to access the CVS repository directly, rather than using
     CVS commands.  Then you are ready to check out a new working
     directory.

     The RCS file should not be locked when you move it into CVS; if it
     is, CVS will have trouble letting you operate on it.

From another version control system
     Many version control systems have the ability to export RCS files
     in the standard format.  If yours does, export the RCS files and
     then follow the above instructions.

     Failing that, probably your best bet is to write a script that
     will check out the files one revision at a time using the command
     line interface to the other system, and then check the revisions
     into CVS.  The `sccs2rcs' script mentioned below may be a useful
     example to follow.

From SCCS
     There is a script in the `contrib' directory of the CVS source
     distribution called `sccs2rcs' which converts SCCS files to RCS
     files.  Note: you must run it on a machine which has both SCCS and
     RCS installed, and like everything else in contrib it is
     unsupported (your mileage may vary).

From PVCS
     There is a script in the `contrib' directory of the CVS source
     distribution called `pvcs_to_rcs' which converts PVCS archives to
     RCS files.  You must run it on a machine which has both PVCS and
     RCS installed, and like everything else in contrib it is
     unsupported (your mileage may vary).  See the comments in the
     script for details.


File: cvs.info,  Node: From scratch,  Prev: From other version control systems,  Up: Setting up the files

3.1.3 Creating a directory tree from scratch
--------------------------------------------

For a new project, the easiest thing to do is probably to create an
empty directory structure, like this:

     $ mkdir tc
     $ mkdir tc/man
     $ mkdir tc/testing

   After that, you use the `import' command to create the corresponding
(empty) directory structure inside the repository:

     $ cd tc
     $ cvs import -m "Created directory structure" yoyodyne/DIR yoyo start

   This will add yoyodyne/DIR as a directory under `$CVSROOT'.

   Use `checkout' to get the new project.  Then, use `add' to add files
(and new directories) as needed.

     $ cd ..
     $ cvs co yoyodyne/DIR

   Check that the permissions CVS sets on the directories inside
`$CVSROOT' are reasonable.


File: cvs.info,  Node: Defining the module,  Prev: Setting up the files,  Up: Starting a new project

3.2 Defining the module
=======================

The next step is to define the module in the `modules' file.  This is
not strictly necessary, but modules can be convenient in grouping
together related files and directories.

   In simple cases these steps are sufficient to define a module.

  1. Get a working copy of the modules file.

          $ cvs checkout CVSROOT/modules
          $ cd CVSROOT

  2. Edit the file and insert a line that defines the module.  *Note
     Intro administrative files::, for an introduction.  *Note
     modules::, for a full description of the modules file.  You can
     use the following line to define the module `tc':

          tc   yoyodyne/tc

  3. Commit your changes to the modules file.

          $ cvs commit -m "Added the tc module." modules

  4. Release the modules module.

          $ cd ..
          $ cvs release -d CVSROOT


File: cvs.info,  Node: Revisions,  Next: Branching and merging,  Prev: Starting a new project,  Up: Top

4 Revisions
***********

For many uses of CVS, one doesn't need to worry too much about revision
numbers; CVS assigns numbers such as `1.1', `1.2', and so on, and that
is all one needs to know.  However, some people prefer to have more
knowledge and control concerning how CVS assigns revision numbers.

   If one wants to keep track of a set of revisions involving more than
one file, such as which revisions went into a particular release, one
uses a "tag", which is a symbolic revision which can be assigned to a
numeric revision in each file.

* Menu:

* Revision numbers::            The meaning of a revision number
* Versions revisions releases::  Terminology used in this manual
* Assigning revisions::         Assigning revisions
* Tags::                        Tags--Symbolic revisions
* Tagging the working directory::  The cvs tag command
* Tagging by date/tag::         The cvs rtag command
* Modifying tags::              Adding, renaming, and deleting tags
* Tagging add/remove::          Tags with adding and removing files
* Sticky tags::                 Certain tags are persistent


File: cvs.info,  Node: Revision numbers,  Next: Versions revisions releases,  Up: Revisions

4.1 Revision numbers
====================

Each version of a file has a unique "revision number".  Revision
numbers look like `1.1', `1.2', `1.3.2.2' or even `1.3.2.2.4.5'.  A
revision number always has an even number of period-separated decimal
integers.  By default revision 1.1 is the first revision of a file.
Each successive revision is given a new number by increasing the
rightmost number by one.  The following figure displays a few
revisions, with newer revisions to the right.

            +-----+    +-----+    +-----+    +-----+    +-----+
            ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
            +-----+    +-----+    +-----+    +-----+    +-----+

   It is also possible to end up with numbers containing more than one
period, for example `1.3.2.2'.  Such revisions represent revisions on
branches (*note Branching and merging::); such revision numbers are
explained in detail in *Note Branches and revisions::.


File: cvs.info,  Node: Versions revisions releases,  Next: Assigning revisions,  Prev: Revision numbers,  Up: Revisions

4.2 Versions, revisions and releases
====================================

A file can have several versions, as described above.  Likewise, a
software product can have several versions.  A software product is
often given a version number such as `4.1.1'.

   Versions in the first sense are called "revisions" in this document,
and versions in the second sense are called "releases".  To avoid
confusion, the word "version" is almost never used in this document.


File: cvs.info,  Node: Assigning revisions,  Next: Tags,  Prev: Versions revisions releases,  Up: Revisions

4.3 Assigning revisions
=======================

By default, CVS will assign numeric revisions by leaving the first
number the same and incrementing the second number.  For example,
`1.1', `1.2', `1.3', etc.

   When adding a new file, the second number will always be one and the
first number will equal the highest first number of any file in that
directory.  For example, the current directory contains files whose
highest numbered revisions are `1.7', `3.1', and `4.12', then an added
file will be given the numeric revision `4.1'.  (When using
client/server CVS, only files that are actually sent to the server are
considered.)

   Normally there is no reason to care about the revision numbers--it
is easier to treat them as internal numbers that CVS maintains, and tags
provide a better way to distinguish between things like release 1
versus release 2 of your product (*note Tags::).  However, if you want
to set the numeric revisions, the `-r' option to `cvs commit' can do
that.  The `-r' option implies the `-f' option, in the sense that it
causes the files to be committed even if they are not modified.

   For example, to bring all your files up to revision 3.0 (including
those that haven't changed), you might invoke:

     $ cvs commit -r 3.0

   Note that the number you specify with `-r' must be larger than any
existing revision number.  That is, if revision 3.0 exists, you cannot
`cvs commit -r 1.3'.  If you want to maintain several releases in
parallel, you need to use a branch (*note Branching and merging::).


File: cvs.info,  Node: Tags,  Next: Tagging the working directory,  Prev: Assigning revisions,  Up: Revisions

4.4 Tags-Symbolic revisions
===========================

The revision numbers live a life of their own.  They need not have
anything at all to do with the release numbers of your software
product.  Depending on how you use CVS the revision numbers might
change several times between two releases.  As an example, some of the
source files that make up RCS 5.6 have the following revision numbers: 

     ci.c            5.21
     co.c            5.9
     ident.c         5.3
     rcs.c           5.12
     rcsbase.h       5.11
     rcsdiff.c       5.10
     rcsedit.c       5.11
     rcsfcmp.c       5.9
     rcsgen.c        5.10
     rcslex.c        5.11
     rcsmap.c        5.2
     rcsutil.c       5.10

   You can use the `tag' command to give a symbolic name to a certain
revision of a file.  You can use the `-v' flag to the `status' command
to see all tags that a file has, and which revision numbers they
represent.  Tag names must start with an uppercase or lowercase letter
and can contain uppercase and lowercase letters, digits, `-', and `_'.
The two tag names `BASE' and `HEAD' are reserved for use by CVS.  It is
expected that future names which are special to CVS will be specially
named, for example by starting with `.', rather than being named
analogously to `BASE' and `HEAD', to avoid conflicts with actual tag
names.

   You'll want to choose some convention for naming tags, based on
information such as the name of the program and the version number of
the release.  For example, one might take the name of the program,
immediately followed by the version number with `.' changed to `-', so
that CVS 1.9 would be tagged with the name `cvs1-9'.  If you choose a
consistent convention, then you won't constantly be guessing whether a
tag is `cvs-1-9' or `cvs1_9' or what.  You might even want to consider
enforcing your convention in the `taginfo' file (*note taginfo::).

   The following example shows how you can add a tag to a file.  The
commands must be issued inside your working directory.  That is, you
should issue the command in the directory where `backend.c' resides.

     $ cvs tag rel-0-4 backend.c
     T backend.c
     $ cvs status -v backend.c
     ===================================================================
     File: backend.c         Status: Up-to-date

         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         (none)
         Sticky Date:        (none)
         Sticky Options:     (none)

         Existing Tags:
             rel-0-4                     (revision: 1.4)

   For a complete summary of the syntax of `cvs tag', including the
various options, see *Note Invoking CVS::.

   There is seldom reason to tag a file in isolation.  A more common
use is to tag all the files that constitute a module with the same tag
at strategic points in the development life-cycle, such as when a
release is made.

     $ cvs tag rel-1-0 .
     cvs tag: Tagging .
     T Makefile
     T backend.c
     T driver.c
     T frontend.c
     T parser.c

(When you give CVS a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  *Note Recursive behavior::.)

   The `checkout' command has a flag, `-r', that lets you check out a
certain revision of a module.  This flag makes it easy to retrieve the
sources that make up release 1.0 of the module `tc' at any time in the
future:

     $ cvs checkout -r rel-1-0 tc

This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.

   You can also check out a module as it was on any branch at any given
date.  *Note checkout options::.  When specifying `-r' or `-D' to any
of these commands, you will need beware of sticky tags; see *Note
Sticky tags::.

   When you tag more than one file with the same tag you can think
about the tag as "a curve drawn through a matrix of filename vs.
revision number."  Say we have 5 files with the following revisions:

             file1   file2   file3   file4   file5

             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6

   At some time in the past, the `*' versions were tagged.  You can
think of the tag as a handle attached to the curve drawn through the
tagged revisions.  When you pull on the handle, you get all the tagged
revisions.  Another way to look at it is that you "sight" through a set
of revisions that is "flat" along the tagged revisions, like this:

             file1   file2   file3   file4   file5

                             1.1
                             1.2
                     1.1     1.3                       _
             1.1     1.2     1.4     1.1              /
             1.2*----1.3*----1.5*----1.2*----1.1*    (--- <--- Look here
             1.3             1.6     1.3              \_
             1.4                     1.4
                                     1.5


File: cvs.info,  Node: Tagging the working directory,  Next: Tagging by date/tag,  Prev: Tags,  Up: Revisions

4.5 Specifying what to tag from the working directory
=====================================================

The example in the previous section demonstrates one of the most common
ways to choose which revisions to tag.  Namely, running the `cvs tag'
command without arguments causes CVS to select the revisions which are
checked out in the current working directory.  For example, if the copy
of `backend.c' in working directory was checked out from revision 1.4,
then CVS will tag revision 1.4.  Note that the tag is applied
immediately to revision 1.4 in the repository; tagging is not like
modifying a file, or other operations in which one first modifies the
working directory and then runs `cvs commit' to transfer that
modification to the repository.

   One potentially surprising aspect of the fact that `cvs tag'
operates on the repository is that you are tagging the checked-in
revisions, which may differ from locally modified files in your working
directory.  If you want to avoid doing this by mistake, specify the
`-c' option to `cvs tag'.  If there are any locally modified files, CVS
will abort with an error before it tags any files:

     $ cvs tag -c rel-0-4
     cvs tag: backend.c is locally modified
     cvs [tag aborted]: correct the above errors first!


File: cvs.info,  Node: Tagging by date/tag,  Next: Modifying tags,  Prev: Tagging the working directory,  Up: Revisions

4.6 Specifying what to tag by date or revision
==============================================

The `cvs rtag' command tags the repository as of a certain date or time
(or can be used to tag the latest revision).  `rtag' works directly on
the repository contents (it requires no prior checkout and does not
look for a working directory).

   The following options specify which date or revision to tag.  See
*Note Common options::, for a complete description of them.

`-D DATE'
     Tag the most recent revision no later than DATE.

`-f'
     Only useful with the `-D' or `-r' flags.  If no matching revision
     is found, use the most recent revision (instead of ignoring the
     file).

`-r TAG[:DATE]'
     Tag the revision already tagged with TAG or, when DATE is specified
     and TAG is a branch tag, the version from the branch TAG as it
     existed on DATE.  See *Note Common options::.

   The `cvs tag' command also allows one to specify files by revision
or date, using the same `-r', `-D', and `-f' options.  However, this
feature is probably not what you want.  The reason is that `cvs tag'
chooses which files to tag based on the files that exist in the working
directory, rather than the files which existed as of the given tag/date.
Therefore, you are generally better off using `cvs rtag'.  The
exceptions might be cases like:

     cvs tag -r 1.4 stable backend.c


File: cvs.info,  Node: Modifying tags,  Next: Tagging add/remove,  Prev: Tagging by date/tag,  Up: Revisions

4.7 Deleting, moving, and renaming tags
=======================================

Normally one does not modify tags.  They exist in order to record the
history of the repository and so deleting them or changing their
meaning would, generally, not be what you want.

   However, there might be cases in which one uses a tag temporarily or
accidentally puts one in the wrong place.  Therefore, one might delete,
move, or rename a tag.

*WARNING: the commands in this section are dangerous; they permanently
discard historical information and it can be difficult or impossible to
recover from errors.  If you are a CVS administrator, you may consider
restricting these commands with the `taginfo' file (*note taginfo::).*

   To delete a tag, specify the `-d' option to either `cvs tag' or `cvs
rtag'.  For example:

     cvs rtag -d rel-0-4 tc

deletes the non-branch tag `rel-0-4' from the module `tc'.  In the
event that branch tags are encountered within the repository with the
given name, a warning message will be issued and the branch tag will
not be deleted.  If you are absolutely certain you know what you are
doing, the `-B' option may be specified to allow deletion of branch
tags.  In that case, any non-branch tags encountered will trigger
warnings and will not be deleted.

*WARNING: Moving branch tags is very dangerous!  If you think you need
the `-B' option, think again and ask your CVS administrator about it
(if that isn't you).  There is almost certainly another way to
accomplish what you want to accomplish.*

   When we say "move" a tag, we mean to make the same name point to
different revisions.  For example, the `stable' tag may currently point
to revision 1.4 of `backend.c' and perhaps we want to make it point to
revision 1.6.  To move a non-branch tag, specify the `-F' option to
either `cvs tag' or `cvs rtag'.  For example, the task just mentioned
might be accomplished as:

     cvs tag -r 1.6 -F stable backend.c

If any branch tags are encountered in the repository with the given
name, a warning is issued and the branch tag is not disturbed.  If you
are absolutely certain you wish to move the branch tag, the `-B' option
may be specified.  In that case, non-branch tags encountered with the
given name are ignored with a warning message.

*WARNING: Moving branch tags is very dangerous!  If you think you need
the `-B' option, think again and ask your CVS administrator about it
(if that isn't you).  There is almost certainly another way to
accomplish what you want to accomplish.*

   When we say "rename" a tag, we mean to make a different name point
to the same revisions as the old tag.  For example, one may have
misspelled the tag name and want to correct it (hopefully before others
are relying on the old spelling).  To rename a tag, first create a new
tag using the `-r' option to `cvs rtag', and then delete the old name.
(Caution: this method will not work with branch tags.)  This leaves the
new tag on exactly the same files as the old tag.  For example:

     cvs rtag -r old-name-0-4 rel-0-4 tc
     cvs rtag -d old-name-0-4 tc


File: cvs.info,  Node: Tagging add/remove,  Next: Sticky tags,  Prev: Modifying tags,  Up: Revisions

4.8 Tagging and adding and removing files
=========================================

The subject of exactly how tagging interacts with adding and removing
files is somewhat obscure; for the most part CVS will keep track of
whether files exist or not without too much fussing.  By default, tags
are applied to only files which have a revision corresponding to what
is being tagged.  Files which did not exist yet, or which were already
removed, simply omit the tag, and CVS knows to treat the absence of a
tag as meaning that the file didn't exist as of that tag.

   However, this can lose a small amount of information.  For example,
suppose a file was added and then removed.  Then, if the tag is missing
for that file, there is no way to know whether the tag refers to the
time before the file was added, or the time after it was removed.  If
you specify the `-r' option to `cvs rtag', then CVS tags the files
which have been removed, and thereby avoids this problem.  For example,
one might specify `-r HEAD' to tag the head.

   On the subject of adding and removing files, the `cvs rtag' command
has a `-a' option which means to clear the tag from removed files that
would not otherwise be tagged.  For example, one might specify this
option in conjunction with `-F' when moving a tag.  If one moved a tag
without `-a', then the tag in the removed files might still refer to
the old revision, rather than reflecting the fact that the file had
been removed.  I don't think this is necessary if `-r' is specified, as
noted above.


File: cvs.info,  Node: Sticky tags,  Prev: Tagging add/remove,  Up: Revisions

4.9 Sticky tags
===============

Sometimes a working copy's revision has extra data associated with it,
for example it might be on a branch (*note Branching and merging::), or
restricted to versions prior to a certain date by `checkout -D' or
`update -D'.  Because this data persists - that is, it applies to
subsequent commands in the working copy - we refer to it as "sticky".

   Most of the time, stickiness is an obscure aspect of CVS that you
don't need to think about.  However, even if you don't want to use the
feature, you may need to know _something_ about sticky tags (for
example, how to avoid them!).

   You can use the `status' command to see if any sticky tags or dates
are set:

     $ cvs status driver.c
     ===================================================================
     File: driver.c          Status: Up-to-date

         Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
         RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)

   The sticky tags will remain on your working files until you delete
them with `cvs update -A'.  The `-A' option merges local changes into
the version of the file from the head of the trunk, removing any sticky
tags, dates, or options.  See *Note update:: for more on the operation
of `cvs update'.

   The most common use of sticky tags is to identify which branch one
is working on, as described in *Note Accessing branches::.  However,
non-branch sticky tags have uses as well.  For example, suppose that
you want to avoid updating your working directory, to isolate yourself
from possibly destabilizing changes other people are making.  You can,
of course, just refrain from running `cvs update'.  But if you want to
avoid updating only a portion of a larger tree, then sticky tags can
help.  If you check out a certain revision (such as 1.4) it will become
sticky.  Subsequent `cvs update' commands will not retrieve the latest
revision until you reset the tag with `cvs update -A'.  Likewise, use
of the `-D' option to `update' or `checkout' sets a "sticky date",
which, similarly, causes that date to be used for future retrievals.

   People often want to retrieve an old version of a file without
setting a sticky tag.  This can be done with the `-p' option to
`checkout' or `update', which sends the contents of the file to
standard output.  For example:
     $ cvs update -p -r 1.1 file1 >file1
     ===================================================================
     Checking out file1
     RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
     VERS: 1.1
     ***************
     $

   However, this isn't the easiest way, if you are asking how to undo a
previous checkin (in this example, put `file1' back to the way it was
as of revision 1.1).  In that case you are better off using the `-j'
option to `update'; for further discussion see *Note Merging two
revisions::.


File: cvs.info,  Node: Branching and merging,  Next: Recursive behavior,  Prev: Revisions,  Up: Top

5 Branching and merging
***********************

CVS allows you to isolate changes onto a separate line of development,
known as a "branch".  When you change files on a branch, those changes
do not appear on the main trunk or other branches.

   Later you can move changes from one branch to another branch (or the
main trunk) by "merging".  Merging involves first running `cvs update
-j', to merge the changes into the working directory.  You can then
commit that revision, and thus effectively copy the changes onto
another branch.

* Menu:

* Branches motivation::         What branches are good for
* Creating a branch::           Creating a branch
* Accessing branches::          Checking out and updating branches
* Branches and revisions::      Branches are reflected in revision numbers
* Magic branch numbers::        Magic branch numbers
* Merging a branch::            Merging an entire branch
* Merging more than once::      Merging from a branch several times
* Merging two revisions::       Merging differences between two revisions
* Merging adds and removals::   What if files are added or removed?
* Merging and keywords::        Avoiding conflicts due to keyword substitution


File: cvs.info,  Node: Branches motivation,  Next: Creating a branch,  Up: Branching and merging

5.1 What branches are good for
==============================

Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.
After a while your customers start to complain about a fatal bug.  You
check out release 1.0 (*note Tags::) and find the bug (which turns out
to have a trivial fix).  However, the current revision of the sources
are in a state of flux and are not expected to be stable for at least
another month.  There is no way to make a bug fix release based on the
newest sources.

   The thing to do in a situation like this is to create a "branch" on
the revision trees for all the files that make up release 1.0 of tc.
You can then make modifications to the branch without disturbing the
main trunk.  When the modifications are finished you can elect to
either incorporate them on the main trunk, or leave them on the branch.


File: cvs.info,  Node: Creating a branch,  Next: Accessing branches,  Prev: Branches motivation,  Up: Branching and merging

5.2 Creating a branch
=====================

You can create a branch with `tag -b'; for example, assuming you're in
a working copy:

     $ cvs tag -b rel-1-0-patches

   This splits off a branch based on the current revisions in the
working copy, assigning that branch the name `rel-1-0-patches'.

   It is important to understand that branches get created in the
repository, not in the working copy.  Creating a branch based on
current revisions, as the above example does, will _not_ automatically
switch the working copy to be on the new branch.  For information on how
to do that, see *Note Accessing branches::.

   You can also create a branch without reference to any working copy,
by using `rtag':

     $ cvs rtag -b -r rel-1-0 rel-1-0-patches tc

   `-r rel-1-0' says that this branch should be rooted at the revision
that corresponds to the tag `rel-1-0'.  It need not be the most recent
revision - it's often useful to split a branch off an old revision (for
example, when fixing a bug in a past release otherwise known to be
stable).

   As with `tag', the `-b' flag tells `rtag' to create a branch (rather
than just a symbolic revision name).  Note that the numeric revision
number that matches `rel-1-0' will probably be different from file to
file.

   So, the full effect of the command is to create a new branch - named
`rel-1-0-patches' - in module `tc', rooted in the revision tree at the
point tagged by `rel-1-0'.


File: cvs.info,  Node: Accessing branches,  Next: Branches and revisions,  Prev: Creating a branch,  Up: Branching and merging

5.3 Accessing branches
======================

You can retrieve a branch in one of two ways: by checking it out fresh
from the repository, or by switching an existing working copy over to
the branch.

   To check out a branch from the repository, invoke `checkout' with
the `-r' flag, followed by the tag name of the branch (*note Creating a
branch::):

     $ cvs checkout -r rel-1-0-patches tc

   Or, if you already have a working copy, you can switch it to a given
branch with `update -r':

     $ cvs update -r rel-1-0-patches tc

or equivalently:

     $ cd tc
     $ cvs update -r rel-1-0-patches

   It does not matter if the working copy was originally on the main
trunk or on some other branch - the above command will switch it to the
named branch.  And similarly to a regular `update' command, `update -r'
merges any changes you have made, notifying you of conflicts where they
occur.

   Once you have a working copy tied to a particular branch, it remains
there until you tell it otherwise.  This means that changes checked in
from the working copy will add new revisions on that branch, while
leaving the main trunk and other branches unaffected.

   To find out what branch a working copy is on, you can use the
`status' command.  In its output, look for the field named `Sticky tag'
(*note Sticky tags::) - that's CVS's way of telling you the branch, if
any, of the current working files:

     $ cvs status -v driver.c backend.c
     ===================================================================
     File: driver.c          Status: Up-to-date

         Version:            1.7     Sat Dec  5 18:25:54 1992
         RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)

         Existing Tags:
             rel-1-0-patches             (branch: 1.7.2)
             rel-1-0                     (revision: 1.7)

     ===================================================================
     File: backend.c         Status: Up-to-date

         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
         Sticky Date:        (none)
         Sticky Options:     (none)

         Existing Tags:
             rel-1-0-patches             (branch: 1.4.2)
             rel-1-0                     (revision: 1.4)
             rel-0-4                     (revision: 1.4)

   Don't be confused by the fact that the branch numbers for each file
are different (`1.7.2' and `1.4.2' respectively).  The branch tag is the
same, `rel-1-0-patches', and the files are indeed on the same branch.
The numbers simply reflect the point in each file's revision history at
which the branch was made.  In the above example, one can deduce that
`driver.c' had been through more changes than `backend.c' before this
branch was created.

   See *Note Branches and revisions:: for details about how branch
numbers are constructed.


File: cvs.info,  Node: Branches and revisions,  Next: Magic branch numbers,  Prev: Accessing branches,  Up: Branching and merging

5.4 Branches and revisions
==========================

Ordinarily, a file's revision history is a linear series of increments
(*note Revision numbers::):

            +-----+    +-----+    +-----+    +-----+    +-----+
            ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
            +-----+    +-----+    +-----+    +-----+    +-----+

   However, CVS is not limited to linear development.  The "revision
tree" can be split into "branches", where each branch is a
self-maintained line of development.  Changes made on one branch can
easily be moved back to the main trunk.

   Each branch has a "branch number", consisting of an odd number of
period-separated decimal integers.  The branch number is created by
appending an integer to the revision number where the corresponding
branch forked off.  Having branch numbers allows more than one branch
to be forked off from a certain revision.

   All revisions on a branch have revision numbers formed by appending
an ordinal number to the branch number.  The following figure
illustrates branching with an example.

                                                           +-------------+
                                Branch 1.2.2.3.2 ->        ! 1.2.2.3.2.1 !
                                                         / +-------------+
                                                        /
                                                       /
                      +---------+    +---------+    +---------+
     Branch 1.2.2 -> _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    / +---------+    +---------+    +---------+
                   /
                  /
     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+    +---------+
     Branch 1.2.4 -> +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                         +---------+    +---------+    +---------+

   The exact details of how the branch number is constructed is not
something you normally need to be concerned about, but here is how it
works: When CVS creates a branch number it picks the first unused even
integer, starting with 2.  So when you want to create a branch from
revision 6.4 it will be numbered 6.4.2.  All branch numbers ending in a
zero (such as 6.4.0) are used internally by CVS (*note Magic branch
numbers::).  The branch 1.1.1 has a special meaning.  *Note Tracking
sources::.


File: cvs.info,  Node: Magic branch numbers,  Next: Merging a branch,  Prev: Branches and revisions,  Up: Branching and merging

5.5 Magic branch numbers
========================

This section describes a CVS feature called "magic branches".  For most
purposes, you need not worry about magic branches; CVS handles them for
you.  However, they are visible to you in certain circumstances, so it
may be useful to have some idea of how it works.

   Externally, branch numbers consist of an odd number of dot-separated
decimal integers.  *Note Revision numbers::.  That is not the whole
truth, however.  For efficiency reasons CVS sometimes inserts an extra 0
in the second rightmost position (1.2.4 becomes 1.2.0.4, 8.9.10.11.12
becomes 8.9.10.11.0.12 and so on).

   CVS does a pretty good job at hiding these so called magic branches,
but in a few places the hiding is incomplete:

   * The magic branch number appears in the output from `cvs log'.

   * You cannot specify a symbolic branch name to `cvs admin'.


   You can use the `admin' command to reassign a symbolic name to a
branch the way RCS expects it to be.  If `R4patches' is assigned to the
branch 1.4.2 (magic branch number 1.4.0.2) in file `numbers.c' you can
do this:

     $ cvs admin -NR4patches:1.4.2 numbers.c

   It only works if at least one revision is already committed on the
branch.  Be very careful so that you do not assign the tag to the wrong
number.  (There is no way to see how the tag was assigned yesterday).


File: cvs.info,  Node: Merging a branch,  Next: Merging more than once,  Prev: Magic branch numbers,  Up: Branching and merging

5.6 Merging an entire branch
============================

You can merge changes made on a branch into your working copy by giving
the `-j BRANCHNAME' flag to the `update' subcommand.  With one `-j
BRANCHNAME' option it merges the changes made between the greatest
common ancestor (GCA) of the branch and the destination revision (in
the simple case below the GCA is the point where the branch forked) and
the newest revision on that branch into your working copy.

   The `-j' stands for "join".

   Consider this revision tree:

     +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

The branch 1.2.2 has been given the tag (symbolic name) `R1fix'.  The
following example assumes that the module `mod' contains only one file,
`m.c'.

     $ cvs checkout mod               # Retrieve the latest revision, 1.4

     $ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                      # i.e. the changes between revision 1.2
                                      # and 1.2.2.2, into your working copy
                                      # of the file.

     $ cvs commit -m "Included R1fix" # Create revision 1.5.

   A conflict can result from a merge operation.  If that happens, you
should resolve it before committing the new revision.  *Note Conflicts
example::.

   If your source files contain keywords (*note Keyword substitution::),
you might be getting more conflicts than strictly necessary.  See *Note
Merging and keywords::, for information on how to avoid this.

   The `checkout' command also supports the `-j BRANCHNAME' flag.  The
same effect as above could be achieved with this:

     $ cvs checkout -j R1fix mod
     $ cvs commit -m "Included R1fix"

   It should be noted that `update -j TAGNAME' will also work but may
not produce the desired result.  *Note Merging adds and removals::, for
more.


File: cvs.info,  Node: Merging more than once,  Next: Merging two revisions,  Prev: Merging a branch,  Up: Branching and merging

5.7 Merging from a branch several times
=======================================

Continuing our example, the revision tree now looks like this:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

where the starred line represents the merge from the `R1fix' branch to
the main trunk, as just discussed.

   Now suppose that development continues on the `R1fix' branch:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                         +---------+    +---------+    +---------+

and then you want to merge those new changes onto the main trunk.  If
you just use the `cvs update -j R1fix m.c' command again, CVS will
attempt to merge again the changes which you have already merged, which
can have undesirable side effects.

   So instead you need to specify that you only want to merge the
changes on the branch which have not yet been merged into the trunk.
To do that you specify two `-j' options, and CVS merges the changes from
the first revision to the second revision.  For example, in this case
the simplest way would be

     cvs update -j 1.2.2.2 -j R1fix m.c    # Merge changes from 1.2.2.2 to the
                                           # head of the R1fix branch

   The problem with this is that you need to specify the 1.2.2.2
revision manually.  A slightly better approach might be to use the date
the last merge was done:

     cvs update -j R1fix:yesterday -j R1fix m.c

   Better yet, tag the R1fix branch after every merge into the trunk,
and then use that tag for subsequent merges:

     cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c


File: cvs.info,  Node: Merging two revisions,  Next: Merging adds and removals,  Prev: Merging more than once,  Up: Branching and merging

5.8 Merging differences between any two revisions
=================================================

With two `-j REVISION' flags, the `update' (and `checkout') command can
merge the differences between any two revisions into your working file.

     $ cvs update -j 1.5 -j 1.3 backend.c

will undo all changes made between revision 1.3 and 1.5.  Note the
order of the revisions!

   If you try to use this option when operating on multiple files,
remember that the numeric revisions will probably be very different
between the various files.  You almost always use symbolic tags rather
than revision numbers when operating on multiple files.

   Specifying two `-j' options can also undo file removals or
additions.  For example, suppose you have a file named `file1' which
existed as revision 1.1, and you then removed it (thus adding a dead
revision 1.2).  Now suppose you want to add it again, with the same
contents it had previously.  Here is how to do it:

     $ cvs update -j 1.2 -j 1.1 file1
     U file1
     $ cvs commit -m test
     Checking in file1;
     /tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
     new revision: 1.3; previous revision: 1.2
     done
     $


File: cvs.info,  Node: Merging adds and removals,  Next: Merging and keywords,  Prev: Merging two revisions,  Up: Branching and merging

5.9 Merging can add or remove files
===================================

If the changes which you are merging involve removing or adding some
files, `update -j' will reflect such additions or removals.

   For example:
     cvs update -A
     touch a b c
     cvs add a b c ; cvs ci -m "added" a b c
     cvs tag -b branchtag
     cvs update -r branchtag
     touch d ; cvs add d
     rm a ; cvs rm a
     cvs ci -m "added d, removed a"
     cvs update -A
     cvs update -jbranchtag

   After these commands are executed and a `cvs commit' is done, file
`a' will be removed and file `d' added in the main branch.

   Note that using a single static tag (`-j TAGNAME') rather than a
dynamic tag (`-j BRANCHNAME') to merge changes from a branch will
usually not remove files which were removed on the branch since CVS
does not automatically add static tags to dead revisions.  The
exception to this rule occurs when a static tag has been attached to a
dead revision manually.  Use the branch tag to merge all changes from
the branch or use two static tags as merge endpoints to be sure that
all intended changes are propagated in the merge.


File: cvs.info,  Node: Merging and keywords,  Prev: Merging adds and removals,  Up: Branching and merging

5.10 Merging and keywords
=========================

If you merge files containing keywords (*note Keyword substitution::),
you will normally get numerous conflicts during the merge, because the
keywords are expanded differently in the revisions which you are
merging.

   Therefore, you will often want to specify the `-kk' (*note
Substitution modes::) switch to the merge command line.  By
substituting just the name of the keyword, not the expanded value of
that keyword, this option ensures that the revisions which you are
merging will be the same as each other, and avoid spurious conflicts.

   For example, suppose you have a file like this:

            +---------+
           _! 1.1.2.1 !   <-  br1
          / +---------+
         /
        /
     +-----+    +-----+
     ! 1.1 !----! 1.2 !
     +-----+    +-----+

and your working directory is currently on the trunk (revision 1.2).
Then you might get the following results from a merge:

     $ cat file1
     key $Revision: 1.2 $
     . . .
     $ cvs update -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     rcsmerge: warning: conflicts during merge
     $ cat file1
     <<<<<<< file1
     key $Revision: 1.2 $
     =======
     key $Revision: 1.1.2.1 $
     >>>>>>> 1.1.2.1
     . . .

   What happened was that the merge tried to merge the differences
between 1.1 and 1.1.2.1 into your working directory.  So, since the
keyword changed from `Revision: 1.1' to `Revision: 1.1.2.1', CVS tried
to merge that change into your working directory, which conflicted with
the fact that your working directory had contained `Revision: 1.2'.

   Here is what happens if you had used `-kk':

     $ cat file1
     key $Revision: 1.2 $
     . . .
     $ cvs update -kk -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     $ cat file1
     key $Revision$
     . . .

   What is going on here is that revision 1.1 and 1.1.2.1 both expand
as plain `Revision', and therefore merging the changes between them
into the working directory need not change anything.  Therefore, there
is no conflict.

   *WARNING: In versions of CVS prior to 1.12.2, there was a major
problem with using `-kk' on merges.  Namely, `-kk' overrode any default
keyword expansion mode set in the archive file in the repository.  This
could, unfortunately for some users, cause data corruption in binary
files (with a default keyword expansion mode set to `-kb').  Therefore,
when a repository contained binary files, conflicts had to be dealt
with manually rather than using `-kk' in a merge command.*

   In CVS version 1.12.2 and later, the keyword expansion mode provided
on the command line to any CVS command no longer overrides the `-kb'
keyword expansion mode setting for binary files, though it will still
override other default keyword expansion modes.  You can now safely
merge using `-kk' to avoid spurious conflicts on lines containing RCS
keywords, even when your repository contains binary files.


File: cvs.info,  Node: Recursive behavior,  Next: Adding and removing,  Prev: Branching and merging,  Up: Top

6 Recursive behavior
********************

Almost all of the subcommands of CVS work recursively when you specify
a directory as an argument.  For instance, consider this directory
structure:

           `$HOME'
             |
             +--tc
             |   |
                 +--CVS
                 |      (internal CVS files)
                 +--Makefile
                 +--backend.c
                 +--driver.c
                 +--frontend.c
                 +--parser.c
                 +--man
                 |    |
                 |    +--CVS
                 |    |  (internal CVS files)
                 |    +--tc.1
                 |
                 +--testing
                      |
                      +--CVS
                      |  (internal CVS files)
                      +--testpgm.t
                      +--test2.t

If `tc' is the current working directory, the following is true:

   * `cvs update testing' is equivalent to

          cvs update testing/testpgm.t testing/test2.t

   * `cvs update testing man' updates all files in the subdirectories

   * `cvs update .' or just `cvs update' updates all files in the `tc'
     directory

   If no arguments are given to `update' it will update all files in
the current working directory and all its subdirectories.  In other
words, `.' is a default argument to `update'.  This is also true for
most of the CVS subcommands, not only the `update' command.

   The recursive behavior of the CVS subcommands can be turned off with
the `-l' option.  Conversely, the `-R' option can be used to force
recursion if `-l' is specified in `~/.cvsrc' (*note ~/.cvsrc::).

     $ cvs update -l         # Don't update files in subdirectories


File: cvs.info,  Node: Adding and removing,  Next: History browsing,  Prev: Recursive behavior,  Up: Top

7 Adding, removing, and renaming files and directories
******************************************************

In the course of a project, one will often add new files.  Likewise
with removing or renaming, or with directories.  The general concept to
keep in mind in all these cases is that instead of making an
irreversible change you want CVS to record the fact that a change has
taken place, just as with modifying an existing file.  The exact
mechanisms to do this in CVS vary depending on the situation.

* Menu:

* Adding files::                Adding files
* Removing files::              Removing files
* Removing directories::        Removing directories
* Moving files::                Moving and renaming files
* Moving directories::          Moving and renaming directories


File: cvs.info,  Node: Adding files,  Next: Removing files,  Up: Adding and removing

7.1 Adding files to a directory
===============================

To add a new file to a directory, follow these steps.

   * You must have a working copy of the directory.  *Note Getting the
     source::.

   * Create the new file inside your working copy of the directory.

   * Use `cvs add FILENAME' to tell CVS that you want to version
     control the file.  If the file contains binary data, specify `-kb'
     (*note Binary files::).

   * Use `cvs commit FILENAME' to actually check in the file into the
     repository.  Other developers cannot see the file until you
     perform this step.

   You can also use the `add' command to add a new directory.

   Unlike most other commands, the `add' command is not recursive.  You
have to expcicitly name files and directories that you wish to add to
the repository.  However, each directory will need to be added
separately before you will be able to add new files to those
directories.

     $ mkdir -p foo/bar
     $ cp ~/myfile foo/bar/myfile
     $ cvs add foo foo/bar
     $ cvs add foo/bar/myfile

 -- Command: cvs add [`-k' kflag] [`-m' message] files ...
     Schedule FILES to be added to the repository.  The files or
     directories specified with `add' must already exist in the current
     directory.  To add a whole new directory hierarchy to the source
     repository (for example, files received from a third-party
     vendor), use the `import' command instead.  *Note import::.

     The added files are not placed in the source repository until you
     use `commit' to make the change permanent.  Doing an `add' on a
     file that was removed with the `remove' command will undo the
     effect of the `remove', unless a `commit' command intervened.
     *Note Removing files::, for an example.

     The `-k' option specifies the default way that this file will be
     checked out; for more information see *Note Substitution modes::.

     The `-m' option specifies a description for the file.  This
     description appears in the history log (if it is enabled, *note
     history file::).  It will also be saved in the version history
     inside the repository when the file is committed.  The `log'
     command displays this description.  The description can be changed
     using `admin -t'.  *Note admin::.  If you omit the `-m
     DESCRIPTION' flag, an empty string will be used.  You will not be
     prompted for a description.

   For example, the following commands add the file `backend.c' to the
repository:

     $ cvs add backend.c
     $ cvs commit -m "Early version. Not yet compilable." backend.c

   When you add a file it is added only on the branch which you are
working on (*note Branching and merging::).  You can later merge the
additions to another branch if you want (*note Merging adds and
removals::).


File: cvs.info,  Node: Removing files,  Next: Removing directories,  Prev: Adding files,  Up: Adding and removing

7.2 Removing files
==================

Directories change.  New files are added, and old files disappear.
Still, you want to be able to retrieve an exact copy of old releases.

   Here is what you can do to remove a file, but remain able to
retrieve old revisions:

   * Make sure that you have not made any uncommitted modifications to
     the file.  *Note Viewing differences::, for one way to do that.
     You can also use the `status' or `update' command.  If you remove
     the file without committing your changes, you will of course not
     be able to retrieve the file as it was immediately before you
     deleted it.

   * Remove the file from your working copy of the directory.  You can
     for instance use `rm'.

   * Use `cvs remove FILENAME' to tell CVS that you really want to
     delete the file.

   * Use `cvs commit FILENAME' to actually perform the removal of the
     file from the repository.

   When you commit the removal of the file, CVS records the fact that
the file no longer exists.  It is possible for a file to exist on only
some branches and not on others, or to re-add another file with the same
name later.  CVS will correctly create or not create the file, based on
the `-r' and `-D' options specified to `checkout' or `update'.

 -- Command: cvs remove [options] files ...
     Schedule file(s) to be removed from the repository (files which
     have not already been removed from the working directory are not
     processed).  This command does not actually remove the file from
     the repository until you commit the removal.  For a full list of
     options, see *Note Invoking CVS::.

   Here is an example of removing several files:

     $ cd test
     $ rm *.c
     $ cvs remove
     cvs remove: Removing .
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   As a convenience you can remove the file and `cvs remove' it in one
step, by specifying the `-f' option.  For example, the above example
could also be done like this:

     $ cd test
     $ cvs remove -f *.c
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   If you execute `remove' for a file, and then change your mind before
you commit, you can undo the `remove' with an `add' command.

     $ ls
     CVS   ja.h  oj.c
     $ rm oj.c
     $ cvs remove oj.c
     cvs remove: scheduling oj.c for removal
     cvs remove: use 'cvs commit' to remove this file permanently
     $ cvs add oj.c
     U oj.c
     cvs add: oj.c, version 1.1.1.1, resurrected

   If you realize your mistake before you run the `remove' command you
can use `update' to resurrect the file:

     $ rm oj.c
     $ cvs update oj.c
     cvs update: warning: oj.c was lost
     U oj.c

   When you remove a file it is removed only on the branch which you
are working on (*note Branching and merging::).  You can later merge
the removals to another branch if you want (*note Merging adds and
removals::).


File: cvs.info,  Node: Removing directories,  Next: Moving files,  Prev: Removing files,  Up: Adding and removing

7.3 Removing directories
========================

In concept, removing directories is somewhat similar to removing
files--you want the directory to not exist in your current working
directories, but you also want to be able to retrieve old releases in
which the directory existed.

   The way that you remove a directory is to remove all the files in
it.  You don't remove the directory itself; there is no way to do that.
Instead you specify the `-P' option to `cvs update' or `cvs checkout',
which will cause CVS to remove empty directories from working
directories.  (Note that `cvs export' always removes empty directories.)
Probably the best way to do this is to always specify `-P'; if you want
an empty directory then put a dummy file (for example `.keepme') in it
to prevent `-P' from removing it.

   Note that `-P' is implied by the `-r' or `-D' options of `checkout'.
This way, CVS will be able to correctly create the directory or not
depending on whether the particular version you are checking out
contains any files in that directory.


File: cvs.info,  Node: Moving files,  Next: Moving directories,  Prev: Removing directories,  Up: Adding and removing

7.4 Moving and renaming files
=============================

Moving files to a different directory or renaming them is not
difficult, but some of the ways in which this works may be non-obvious.
(Moving or renaming a directory is even harder.  *Note Moving
directories::.).

   The examples below assume that the file OLD is renamed to NEW.

* Menu:

* Outside::                     The normal way to Rename
* Inside::                      A tricky, alternative way
* Rename by copying::           Another tricky, alternative way


File: cvs.info,  Node: Outside,  Next: Inside,  Up: Moving files

7.4.1 The Normal way to Rename
------------------------------

The normal way to move a file is to copy OLD to NEW, and then issue the
normal CVS commands to remove OLD from the repository, and add NEW to
it.

     $ mv OLD NEW
     $ cvs remove OLD
     $ cvs add NEW
     $ cvs commit -m "Renamed OLD to NEW" OLD NEW

   This is the simplest way to move a file, it is not error-prone, and
it preserves the history of what was done.  Note that to access the
history of the file you must specify the old or the new name, depending
on what portion of the history you are accessing.  For example, `cvs
log OLD' will give the log up until the time of the rename.

   When NEW is committed its revision numbers will start again, usually
at 1.1, so if that bothers you, use the `-r TAG' option to commit.  For
more information see *Note Assigning revisions::.


File: cvs.info,  Node: Inside,  Next: Rename by copying,  Prev: Outside,  Up: Moving files

7.4.2 Moving the history file
-----------------------------

This method is more dangerous, since it involves moving files inside
the repository.  Read this entire section before trying it out!

     $ cd $CVSROOT/DIR
     $ mv OLD,v NEW,v

Advantages:

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * Old releases cannot easily be fetched from the repository.  (The
     file will show up as NEW even in revisions from the time before it
     was renamed).

   * There is no log information of when the file was renamed.

   * Nasty things might happen if someone accesses the history file
     while you are moving it.  Make sure no one else runs any of the CVS
     commands while you move it.


File: cvs.info,  Node: Rename by copying,  Prev: Inside,  Up: Moving files

7.4.3 Copying the history file
------------------------------

This way also involves direct modifications to the repository.  It is
safe, but not without drawbacks.

     # Copy the RCS file inside the repository
     $ cd $CVSROOT/DIR
     $ cp OLD,v NEW,v
     # Remove the old file
     $ cd ~/DIR
     $ rm OLD
     $ cvs remove OLD
     $ cvs commit OLD
     # Remove all tags from NEW
     $ cvs update NEW
     $ cvs log NEW             # Remember the non-branch tag names
     $ cvs tag -d TAG1 NEW
     $ cvs tag -d TAG2 NEW
     ...

   By removing the tags you will be able to check out old revisions.

Advantages:

   * Checking out old revisions works correctly, as long as you use `-r
     TAG' and not `-D DATE' to retrieve the revisions.

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * You cannot easily see the history of the file across the rename.



File: cvs.info,  Node: Moving directories,  Prev: Moving files,  Up: Adding and removing

7.5 Moving and renaming directories
===================================

The normal way to rename or move a directory is to rename or move each
file within it as described in *Note Outside::.  Then check out with
the `-P' option, as described in *Note Removing directories::.

   If you really want to hack the repository to rename or delete a
directory in the repository, you can do it like this:

  1. Inform everyone who has a checked out copy of the directory that
     the directory will be renamed.  They should commit all their
     changes in all their copies of the project containing the
     directory to be removed, and remove all their working copies of
     said project, before you take the steps below.

  2. Rename the directory inside the repository.

          $ cd $CVSROOT/PARENT-DIR
          $ mv OLD-DIR NEW-DIR

  3. Fix the CVS administrative files, if necessary (for instance if
     you renamed an entire module).

  4. Tell everyone that they can check out again and continue working.


   If someone had a working copy the CVS commands will cease to work
for him, until he removes the directory that disappeared inside the
repository.

   It is almost always better to move the files in the directory
instead of moving the directory.  If you move the directory you are
unlikely to be able to retrieve old releases correctly, since they
probably depend on the name of the directories.


File: cvs.info,  Node: History browsing,  Next: Binary files,  Prev: Adding and removing,  Up: Top

8 History browsing
******************

Once you have used CVS to store a version control history--what files
have changed when, how, and by whom, there are a variety of mechanisms
for looking through the history.

* Menu:

* log messages::                Log messages
* history database::            The history database
* user-defined logging::        User-defined logging


File: cvs.info,  Node: log messages,  Next: history database,  Up: History browsing

8.1 Log messages
================

Whenever you commit a file you specify a log message.

   To look through the log messages which have been specified for every
revision which has been committed, use the `cvs log' command (*note
log::).


File: cvs.info,  Node: history database,  Next: user-defined logging,  Prev: log messages,  Up: History browsing

8.2 The history database
========================

You can use the history file (*note history file::) to log various CVS
actions.  To retrieve the information from the history file, use the
`cvs history' command (*note history::).

   Note: you can control what is logged to this file by using the
`LogHistory' keyword in the `CVSROOT/config' file (*note config::).


File: cvs.info,  Node: user-defined logging,  Prev: history database,  Up: History browsing

8.3 User-defined logging
========================

You can customize CVS to log various kinds of actions, in whatever
manner you choose.  These mechanisms operate by executing a script at
various times.  The script might append a message to a file listing the
information and the programmer who created it, or send mail to a group
of developers, or, perhaps, post a message to a particular newsgroup.
To log commits, use the `loginfo' file (*note loginfo::), and to log
tagging operations, use the `taginfo' file (*note taginfo::).

   To log commits, checkouts, exports, and tags, respectively, you can
also use the `-i', `-o', `-e', and `-t' options in the modules file.
For a more flexible way of giving notifications to various users, which
requires less in the way of keeping centralized scripts up to date, use
the `cvs watch add' command (*note Getting Notified::); this command is
useful even if you are not using `cvs watch on'.


File: cvs.info,  Node: Binary files,  Next: Multiple developers,  Prev: History browsing,  Up: Top

9 Handling binary files
***********************

The most common use for CVS is to store text files.  With text files,
CVS can merge revisions, display the differences between revisions in a
human-visible fashion, and other such operations.  However, if you are
willing to give up a few of these abilities, CVS can store binary
files.  For example, one might store a web site in CVS including both
text files and binary images.

* Menu:

* Binary why::     More details on issues with binary files
* Binary howto::   How to store them


File: cvs.info,  Node: Binary why,  Next: Binary howto,  Up: Binary files

9.1 The issues with binary files
================================

While the need to manage binary files may seem obvious if the files
that you customarily work with are binary, putting them into version
control does present some additional issues.

   One basic function of version control is to show the differences
between two revisions.  For example, if someone else checked in a new
version of a file, you may wish to look at what they changed and
determine whether their changes are good.  For text files, CVS provides
this functionality via the `cvs diff' command.  For binary files, it
may be possible to extract the two revisions and then compare them with
a tool external to CVS (for example, word processing software often has
such a feature).  If there is no such tool, one must track changes via
other mechanisms, such as urging people to write good log messages, and
hoping that the changes they actually made were the changes that they
intended to make.

   Another ability of a version control system is the ability to merge
two revisions.  For CVS this happens in two contexts.  The first is
when users make changes in separate working directories (*note Multiple
developers::).  The second is when one merges explicitly with the
`update -j' command (*note Branching and merging::).

   In the case of text files, CVS can merge changes made independently,
and signal a conflict if the changes conflict.  With binary files, the
best that CVS can do is present the two different copies of the file,
and leave it to the user to resolve the conflict.  The user may choose
one copy or the other, or may run an external merge tool which knows
about that particular file format, if one exists.  Note that having the
user merge relies primarily on the user to not accidentally omit some
changes, and thus is potentially error prone.

   If this process is thought to be undesirable, the best choice may be
to avoid merging.  To avoid the merges that result from separate
working directories, see the discussion of reserved checkouts (file
locking) in *Note Multiple developers::.  To avoid the merges resulting
from branches, restrict use of branches.


File: cvs.info,  Node: Binary howto,  Prev: Binary why,  Up: Binary files

9.2 How to store binary files
=============================

There are two issues with using CVS to store binary files.  The first
is that CVS by default converts line endings between the canonical form
in which they are stored in the repository (linefeed only), and the
form appropriate to the operating system in use on the client (for
example, carriage return followed by line feed for Windows NT).

   The second is that a binary file might happen to contain data which
looks like a keyword (*note Keyword substitution::), so keyword
expansion must be turned off.

   The `-kb' option available with some CVS commands insures that
neither line ending conversion nor keyword expansion will be done.

   Here is an example of how you can create a new file using the `-kb'
flag:

     $ echo '$Id$' > kotest
     $ cvs add -kb -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest

   If a file accidentally gets added without `-kb', one can use the
`cvs admin' command to recover.  For example:

     $ echo '$Id$' > kotest
     $ cvs add -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest
     $ cvs admin -kb kotest
     $ cvs update -A kotest
     # For non-unix systems:
     # Copy in a good copy of the file from outside CVS
     $ cvs commit -m "make it binary" kotest

   When you check in the file `kotest' the file is not preserved as a
binary file, because you did not check it in as a binary file.  The `cvs
admin -kb' command sets the default keyword substitution method for
this file, but it does not alter the working copy of the file that you
have.  If you need to cope with line endings (that is, you are using
CVS on a non-unix system), then you need to check in a new copy of the
file, as shown by the `cvs commit' command above.  On unix, the `cvs
update -A' command suffices.  (Note that you can use `cvs log' to
determine the default keyword substitution method for a file and `cvs
status' to determine the keyword substitution method for a working
copy.)

   However, in using `cvs admin -k' to change the keyword expansion, be
aware that the keyword expansion mode is not version controlled.  This
means that, for example, that if you have a text file in old releases,
and a binary file with the same name in new releases, CVS provides no
way to check out the file in text or binary mode depending on what
version you are checking out.  There is no good workaround for this
problem.

   You can also set a default for whether `cvs add' and `cvs import'
treat a file as binary based on its name; for example you could say
that files who names end in `.exe' are binary.  *Note Wrappers::.
There is currently no way to have CVS detect whether a file is binary
based on its contents.  The main difficulty with designing such a
feature is that it is not clear how to distinguish between binary and
non-binary files, and the rules to apply would vary considerably with
the operating system.


File: cvs.info,  Node: Multiple developers,  Next: Revision management,  Prev: Binary files,  Up: Top

10 Multiple developers
**********************

When more than one person works on a software project things often get
complicated.  Often, two people try to edit the same file
simultaneously.  One solution, known as "file locking" or "reserved
checkouts", is to allow only one person to edit each file at a time.
This is the only solution with some version control systems, including
RCS and SCCS.  Currently the usual way to get reserved checkouts with
CVS is the `cvs admin -l' command (*note admin options::).  This is not
as nicely integrated into CVS as the watch features, described below,
but it seems that most people with a need for reserved checkouts find
it adequate.

   As of CVS version 1.12.10, another technique for getting most of the
effect of reserved checkouts is to enable advisory locks.  To enable
advisory locks, have all developers put "edit -c", "commit -c" in their
.cvsrc file, and turn on watches in the repository.  This prevents them
from doing a `cvs edit' if anyone is already editting the file.  It
also may be possible to use plain watches together with suitable
procedures (not enforced by software), to avoid having two people edit
at the same time.

   The default model with CVS is known as "unreserved checkouts".  In
this model, developers can edit their own "working copy" of a file
simultaneously.  The first person that commits his changes has no
automatic way of knowing that another has started to edit it.  Others
will get an error message when they try to commit the file.  They must
then use CVS commands to bring their working copy up to date with the
repository revision.  This process is almost automatic.

   CVS also supports mechanisms which facilitate various kinds of
communication, without actually enforcing rules like reserved checkouts
do.

   The rest of this chapter describes how these various models work,
and some of the issues involved in choosing between them.

* Menu:

* File status::                 A file can be in several states
* Updating a file::             Bringing a file up-to-date
* Conflicts example::           An informative example
* Informing others::            To cooperate you must inform
* Concurrency::                 Simultaneous repository access
* Watches::                     Mechanisms to track who is editing files
* Choosing a model::            Reserved or unreserved checkouts?


File: cvs.info,  Node: File status,  Next: Updating a file,  Up: Multiple developers

10.1 File status
================

Based on what operations you have performed on a checked out file, and
what operations others have performed to that file in the repository,
one can classify a file in a number of states.  The states, as reported
by the `status' command, are:

Up-to-date
     The file is identical with the latest revision in the repository
     for the branch in use.

Locally Modified
     You have edited the file, and not yet committed your changes.

Locally Added
     You have added the file with `add', and not yet committed your
     changes.

Locally Removed
     You have removed the file with `remove', and not yet committed
     your changes.

Needs Checkout
     Someone else has committed a newer revision to the repository.
     The name is slightly misleading; you will ordinarily use `update'
     rather than `checkout' to get that newer revision.

Needs Patch
     Like Needs Checkout, but the CVS server will send a patch rather
     than the entire file.  Sending a patch or sending an entire file
     accomplishes the same thing.

Needs Merge
     Someone else has committed a newer revision to the repository, and
     you have also made modifications to the file.

Unresolved Conflict
     A file with the same name as this new file has been added to the
     repository from a second workspace.  This file will need to be
     moved out of the way to allow an `update' to complete.

File had conflicts on merge
     This is like Locally Modified, except that a previous `update'
     command gave a conflict.  If you have not already done so, you
     need to resolve the conflict as described in *Note Conflicts
     example::.

Unknown
     CVS doesn't know anything about this file.  For example, you have
     created a new file and have not run `add'.


   To help clarify the file status, `status' also reports the `Working
revision' which is the revision that the file in the working directory
derives from, and the `Repository revision' which is the latest
revision in the repository for the branch in use.  The `Commit
Identifier' reflects the unique commitid of the `commit'.

   The options to `status' are listed in *Note Invoking CVS::.  For
information on its `Sticky tag' and `Sticky date' output, see *Note
Sticky tags::.  For information on its `Sticky options' output, see the
`-k' option in *Note update options::.

   You can think of the `status' and `update' commands as somewhat
complementary.  You use `update' to bring your files up to date, and you
can use `status' to give you some idea of what an `update' would do (of
course, the state of the repository might change before you actually run
`update').  In fact, if you want a command to display file status in a
more brief format than is displayed by the `status' command, you can
invoke

     $ cvs -n -q update

   The `-n' option means to not actually do the update, but merely to
display statuses; the `-q' option avoids printing the name of each
directory.  For more information on the `update' command, and these
options, see *Note Invoking CVS::.


File: cvs.info,  Node: Updating a file,  Next: Conflicts example,  Prev: File status,  Up: Multiple developers

10.2 Bringing a file up to date
===============================

When you want to update or merge a file, use the `cvs update -d'
command.  For files that are not up to date this is roughly equivalent
to a `checkout' command: the newest revision of the file is extracted
from the repository and put in your working directory.  The `-d'
option, not necessary with `checkout', tells CVS that you wish it to
create directories added by other developers.

   Your modifications to a file are never lost when you use `update'.
If no newer revision exists, running `update' has no effect.  If you
have edited the file, and a newer revision is available, CVS will merge
all changes into your working copy.

   For instance, imagine that you checked out revision 1.4 and started
editing it.  In the meantime someone else committed revision 1.5, and
shortly after that revision 1.6.  If you run `update' on the file now,
CVS will incorporate all changes between revision 1.4 and 1.6 into your
file.

   If any of the changes between 1.4 and 1.6 were made too close to any
of the changes you have made, an "overlap" occurs.  In such cases a
warning is printed, and the resulting file includes both versions of
the lines that overlap, delimited by special markers.  *Note update::,
for a complete description of the `update' command.


File: cvs.info,  Node: Conflicts example,  Next: Informing others,  Prev: Updating a file,  Up: Multiple developers

10.3 Conflicts example
======================

Suppose revision 1.4 of `driver.c' contains this:

     #include <stdio.h>

     void main()
     {
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? 0 : 1);
     }

Revision 1.6 of `driver.c' contains this:

     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(!!nerr);
     }

Your working copy of `driver.c', based on revision 1.4, contains this
before you run `cvs update':

     #include <stdlib.h>
     #include <stdio.h>

     void main()
     {
         init_scanner();
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

You run `cvs update':

     $ cvs update driver.c
     RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
     retrieving revision 1.4
     retrieving revision 1.6
     Merging differences between 1.4 and 1.6 into driver.c
     rcsmerge warning: overlaps during merge
     cvs update: conflicts found in driver.c
     C driver.c

CVS tells you that there were some conflicts.  Your original working
file is saved unmodified in `.#driver.c.1.4'.  The new version of
`driver.c' contains this:

     #include <stdlib.h>
     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
     <<<<<<< driver.c
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     =======
         exit(!!nerr);
     >>>>>>> 1.6
     }


   Note how all non-overlapping modifications are incorporated in your
working copy, and that the overlapping section is clearly marked with
`<<<<<<<', `=======' and `>>>>>>>'.

   You resolve the conflict by editing the file, removing the markers
and the erroneous line.  Suppose you end up with this file:
     #include <stdlib.h>
     #include <stdio.h>

     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

You can now go ahead and commit this as revision 1.7.

     $ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7; previous revision: 1.6
     done

   For your protection, CVS will refuse to check in a file if a
conflict occurred and you have not resolved the conflict.  Currently to
resolve a conflict, you must change the timestamp on the file.  In
previous versions of CVS, you also needed to insure that the file
contains no conflict markers.  Because your file may legitimately
contain conflict markers (that is, occurrences of `>>>>>>> ' at the
start of a line that don't mark a conflict), the current version of CVS
will print a warning and proceed to check in the file.

   If you use release 1.04 or later of pcl-cvs (a GNU Emacs front-end
for CVS) you can use an Emacs package called emerge to help you resolve
conflicts.  See the documentation for pcl-cvs.


File: cvs.info,  Node: Informing others,  Next: Concurrency,  Prev: Conflicts example,  Up: Multiple developers

10.4 Informing others about commits
===================================

It is often useful to inform others when you commit a new revision of a
file.  The `-i' option of the `modules' file, or the `loginfo' file,
can be used to automate this process.  *Note modules::.  *Note
loginfo::.  You can use these features of CVS to, for instance,
instruct CVS to mail a message to all developers, or post a message to
a local newsgroup.


File: cvs.info,  Node: Concurrency,  Next: Watches,  Prev: Informing others,  Up: Multiple developers

10.5 Several developers simultaneously attempting to run CVS
============================================================

If several developers try to run CVS at the same time, one may get the
following message:

     [11:43:23] waiting for bach's lock in /usr/local/cvsroot/foo

   CVS will try again every 30 seconds, and either continue with the
operation or print the message again, if it still needs to wait.  If a
lock seems to stick around for an undue amount of time, find the person
holding the lock and ask them about the cvs command they are running.
If they aren't running a cvs command, look in the repository directory
mentioned in the message and remove files which they own whose names
start with `#cvs.rfl', `#cvs.wfl', or `#cvs.lock'.

   Note that these locks are to protect CVS's internal data structures
and have no relationship to the word "lock" in the sense used by
RCS--which refers to reserved checkouts (*note Multiple developers::).

   Any number of people can be reading from a given repository at a
time; only when someone is writing do the locks prevent other people
from reading or writing.

   One might hope for the following property:

     If someone commits some changes in one cvs command, then an update
     by someone else will either get all the changes, or none of them.

but CVS does _not_ have this property.  For example, given the files

     a/one.c
     a/two.c
     b/three.c
     b/four.c

if someone runs

     cvs ci a/two.c b/three.c

and someone else runs `cvs update' at the same time, the person running
`update' might get only the change to `b/three.c' and not the change to
`a/two.c'.


File: cvs.info,  Node: Watches,  Next: Choosing a model,  Prev: Concurrency,  Up: Multiple developers

10.6 Mechanisms to track who is editing files
=============================================

For many groups, use of CVS in its default mode is perfectly
satisfactory.  Users may sometimes go to check in a modification only
to find that another modification has intervened, but they deal with it
and proceed with their check in.  Other groups prefer to be able to
know who is editing what files, so that if two people try to edit the
same file they can choose to talk about who is doing what when rather
than be surprised at check in time.  The features in this section allow
such coordination, while retaining the ability of two developers to
edit the same file at the same time.

   For maximum benefit developers should use `cvs edit' (not `chmod')
to make files read-write to edit them, and `cvs release' (not `rm') to
discard a working directory which is no longer in use, but CVS is not
able to enforce this behavior.

   If a development team wants stronger enforcement of watches and all
team members are using a CVS client version 1.12.10 or greater to
access a CVS server version 1.12.10 or greater, they can enable
advisory locks.  To enable advisory locks, have all developers put
"edit -c" and "commit -c" into all .cvsrc files, and make files default
to read only by turning on watches or putting "cvs -r" into all .cvsrc
files.  This prevents multiple people from editting a file at the same
time (unless explicitly overriden with `-f').

* Menu:

* Setting a watch::             Telling CVS to watch certain files
* Getting Notified::            Telling CVS to notify you
* Editing files::               How to edit a file which is being watched
* Watch information::           Information about who is watching and editing
* Watches Compatibility::       Watches interact poorly with CVS 1.6 or earlier


File: cvs.info,  Node: Setting a watch,  Next: Getting Notified,  Up: Watches

10.6.1 Telling CVS to watch certain files
-----------------------------------------

To enable the watch features, you first specify that certain files are
to be watched.

 -- Command: cvs watch on [`-lR'] [FILES]...
     Specify that developers should run `cvs edit' before editing
     FILES.  CVS will create working copies of FILES read-only, to
     remind developers to run the `cvs edit' command before working on
     them.

     If FILES includes the name of a directory, CVS arranges to watch
     all files added to the corresponding repository directory, and
     sets a default for files added in the future; this allows the user
     to set notification policies on a per-directory basis.  The
     contents of the directory are processed recursively, unless the
     `-l' option is given.  The `-R' option can be used to force
     recursion if the `-l' option is set in `~/.cvsrc' (*note
     ~/.cvsrc::).

     If FILES is omitted, it defaults to the current directory.


 -- Command: cvs watch off [`-lR'] [FILES]...
     Do not create FILES read-only on checkout; thus, developers will
     not be reminded to use `cvs edit' and `cvs unedit'.

     The FILES and options are processed as for `cvs watch on'.



File: cvs.info,  Node: Getting Notified,  Next: Editing files,  Prev: Setting a watch,  Up: Watches

10.6.2 Telling CVS to notify you
--------------------------------

You can tell CVS that you want to receive notifications about various
actions taken on a file.  You can do this without using `cvs watch on'
for the file, but generally you will want to use `cvs watch on', to
remind developers to use the `cvs edit' command.

 -- Command: cvs watch add [`-lR'] [`-a' ACTION]... [FILES]...
     Add the current user to the list of people to receive notification
     of work done on FILES.

     The `-a' option specifies what kinds of events CVS should notify
     the user about.  ACTION is one of the following:

    `edit'
          Another user has applied the `cvs edit' command (described
          below) to a watched file.

    `commit'
          Another user has committed changes to one of the named FILES.

    `unedit'
          Another user has abandoned editing a file (other than by
          committing changes).  They can do this in several ways, by:

             * applying the `cvs unedit' command (described below) to
               the file

             * applying the `cvs release' command (*note release::) to
               the file's parent directory (or recursively to a
               directory more than one level up)

             * deleting the file and allowing `cvs update' to recreate
               it


    `all'
          All of the above.

    `none'
          None of the above.  (This is useful with `cvs edit',
          described below.)


     The `-a' option may appear more than once, or not at all.  If
     omitted, the action defaults to `all'.

     The FILES and options are processed as for `cvs watch on'.


 -- Command: cvs watch remove [`-lR'] [`-a' ACTION]... [FILES]...
     Remove a notification request established using `cvs watch add';
     the arguments are the same.  If the `-a' option is present, only
     watches for the specified actions are removed.


   When the conditions exist for notification, CVS calls the `notify'
administrative file.  Edit `notify' as one edits the other
administrative files (*note Intro administrative files::).  This file
follows the usual conventions for administrative files (*note
syntax::), where each line is a regular expression followed by a
command to execute.  The command should contain a single occurrence of
`%s' which will be replaced by the user to notify; the rest of the
information regarding the notification will be supplied to the command
on standard input.  The standard thing to put in the `notify' file is
the single line:

     ALL mail %s -s "CVS notification"

This causes users to be notified by electronic mail.

   Note that if you set this up in the straightforward way, users
receive notifications on the server machine.  One could of course write
a `notify' script which directed notifications elsewhere, but to make
this easy, CVS allows you to associate a notification address for each
user.  To do so create a file `users' in `CVSROOT' with a line for each
user in the format USER:VALUE.  Then instead of passing the name of the
user to be notified to `notify', CVS will pass the VALUE (normally an
email address on some other machine).

   CVS does not notify you for your own changes.  Currently this check
is done based on whether the user name of the person taking the action
which triggers notification matches the user name of the person getting
notification.  In fact, in general, the watches features only track one
edit by each user.  It probably would be more useful if watches tracked
each working directory separately, so this behavior might be worth
changing.


File: cvs.info,  Node: Editing files,  Next: Watch information,  Prev: Getting Notified,  Up: Watches

10.6.3 How to edit a file which is being watched
------------------------------------------------

Since a file which is being watched is checked out read-only, you
cannot simply edit it.  To make it read-write, and inform others that
you are planning to edit it, use the `cvs edit' command.  Some systems
call this a "checkout", but CVS uses that term for obtaining a copy of
the sources (*note Getting the source::), an operation which those
systems call a "get" or a "fetch".

 -- Command: cvs edit [`-lR'] [`-a' ACTION]... [FILES]...
     Prepare to edit the working files FILES.  CVS makes the FILES
     read-write, and notifies users who have requested `edit'
     notification for any of FILES.

     The `cvs edit' command accepts the same options as the `cvs watch
     add' command, and establishes a temporary watch for the user on
     FILES; CVS will remove the watch when FILES are `unedit'ed or
     `commit'ted.  If the user does not wish to receive notifications,
     she should specify `-a none'.

     The FILES and the options are processed as for the `cvs watch'
     commands.

     There are two additional options that `cvs edit' understands as of
     CVS client and server versions 1.12.10 but `cvs watch' does not.
     The first is `-c', which causes `cvs edit' to fail if anyone else
     is editting the file.  This is probably only useful when `edit -c'
     and `commit -c' are specified in all developers' `.cvsrc' files.
     This behavior may be overriden this via the `-f' option, which
     overrides `-c' and allows multiple edits to succeed.


   Normally when you are done with a set of changes, you use the `cvs
commit' command, which checks in your changes and returns the watched
files to their usual read-only state.  But if you instead decide to
abandon your changes, or not to make any changes, you can use the `cvs
unedit' command.

 -- Command: cvs unedit [`-lR'] [FILES]...
     Abandon work on the working files FILES, and revert them to the
     repository versions on which they are based.  CVS makes those
     FILES read-only for which users have requested notification using
     `cvs watch on'.  CVS notifies users who have requested `unedit'
     notification for any of FILES.

     The FILES and options are processed as for the `cvs watch'
     commands.

     If watches are not in use, the `unedit' command probably does not
     work, and the way to revert to the repository version is with the
     command `cvs update -C file' (*note update::).  The meaning is not
     precisely the same; the latter may also bring in some changes
     which have been made in the repository since the last time you
     updated.

   When using client/server CVS, you can use the `cvs edit' and `cvs
unedit' commands even if CVS is unable to successfully communicate with
the server; the notifications will be sent upon the next successful CVS
command.


File: cvs.info,  Node: Watch information,  Next: Watches Compatibility,  Prev: Editing files,  Up: Watches

10.6.4 Information about who is watching and editing
----------------------------------------------------

 -- Command: cvs watchers [`-lR'] [FILES]...
     List the users currently watching changes to FILES.  The report
     includes the files being watched, and the mail address of each
     watcher.

     The FILES and options are processed as for the `cvs watch'
     commands.


 -- Command: cvs editors [`-lR'] [FILES]...
     List the users currently working on FILES.  The report includes
     the mail address of each user, the time when the user began
     working with the file, and the host and path of the working
     directory containing the file.

     The FILES and options are processed as for the `cvs watch'
     commands.



File: cvs.info,  Node: Watches Compatibility,  Prev: Watch information,  Up: Watches

10.6.5 Using watches with old versions of CVS
---------------------------------------------

If you use the watch features on a repository, it creates `CVS'
directories in the repository and stores the information about watches
in that directory.  If you attempt to use CVS 1.6 or earlier with the
repository, you get an error message such as the following (all on one
line):

     cvs update: cannot open CVS/Entries for reading:
     No such file or directory

and your operation will likely be aborted.  To use the watch features,
you must upgrade all copies of CVS which use that repository in local
or server mode.  If you cannot upgrade, use the `watch off' and `watch
remove' commands to remove all watches, and that will restore the
repository to a state which CVS 1.6 can cope with.


File: cvs.info,  Node: Choosing a model,  Prev: Watches,  Up: Multiple developers

10.7 Choosing between reserved or unreserved checkouts
======================================================

Reserved and unreserved checkouts each have pros and cons.  Let it be
said that a lot of this is a matter of opinion or what works given
different groups' working styles, but here is a brief description of
some of the issues.  There are many ways to organize a team of
developers.  CVS does not try to enforce a certain organization.  It is
a tool that can be used in several ways.

   Reserved checkouts can be very counter-productive.  If two persons
want to edit different parts of a file, there may be no reason to
prevent either of them from doing so.  Also, it is common for someone
to take out a lock on a file, because they are planning to edit it, but
then forget to release the lock.

   People, especially people who are familiar with reserved checkouts,
often wonder how often conflicts occur if unreserved checkouts are
used, and how difficult they are to resolve.  The experience with many
groups is that they occur rarely and usually are relatively
straightforward to resolve.

   The rarity of serious conflicts may be surprising, until one realizes
that they occur only when two developers disagree on the proper design
for a given section of code; such a disagreement suggests that the team
has not been communicating properly in the first place.  In order to
collaborate under _any_ source management regimen, developers must
agree on the general design of the system; given this agreement,
overlapping changes are usually straightforward to merge.

   In some cases unreserved checkouts are clearly inappropriate.  If no
merge tool exists for the kind of file you are managing (for example
word processor files or files edited by Computer Aided Design
programs), and it is not desirable to change to a program which uses a
mergeable data format, then resolving conflicts is going to be
unpleasant enough that you generally will be better off to simply avoid
the conflicts instead, by using reserved checkouts.

   The watches features described above in *Note Watches:: can be
considered to be an intermediate model between reserved checkouts and
unreserved checkouts.  When you go to edit a file, it is possible to
find out who else is editing it.  And rather than having the system
simply forbid both people editing the file, it can tell you what the
situation is and let you figure out whether it is a problem in that
particular case or not.  Therefore, for some groups watches can be
considered the best of both the reserved checkout and unreserved
checkout worlds.

   As of CVS client and server versions 1.12.10, you may also enable
advisory locks by putting `edit -c' and `commit -c' in all developers'
`.cvsrc' files.  After this is done, `cvs edit' will fail if there are
any other editors, and `cvs commit' will fail if the committer has not
registered to edit the file via `cvs edit'.  This is most effective in
conjunction with files checked out read-only by default, which may be
enabled by turning on watches in the repository or by putting `cvs -r'
in all `.cvsrc' files.


File: cvs.info,  Node: Revision management,  Next: Keyword substitution,  Prev: Multiple developers,  Up: Top

11 Revision management
**********************

If you have read this far, you probably have a pretty good grasp on
what CVS can do for you.  This chapter talks a little about things that
you still have to decide.

   If you are doing development on your own using CVS you could
probably skip this chapter.  The questions this chapter takes up become
more important when more than one person is working in a repository.

* Menu:

* When to commit::              Some discussion on the subject


File: cvs.info,  Node: When to commit,  Up: Revision management

11.1 When to commit?
====================

Your group should decide which policy to use regarding commits.
Several policies are possible, and as your experience with CVS grows
you will probably find out what works for you.

   If you commit files too quickly you might commit files that do not
even compile.  If your partner updates his working sources to include
your buggy file, he will be unable to compile the code.  On the other
hand, other persons will not be able to benefit from the improvements
you make to the code if you commit very seldom, and conflicts will
probably be more common.

   It is common to only commit files after making sure that they can be
compiled.  Some sites require that the files pass a test suite.
Policies like this can be enforced using the commitinfo file (*note
commitinfo::), but you should think twice before you enforce such a
convention.  By making the development environment too controlled it
might become too regimented and thus counter-productive to the real
goal, which is to get software written.


File: cvs.info,  Node: Keyword substitution,  Next: Tracking sources,  Prev: Revision management,  Up: Top

12 Keyword substitution
***********************

As long as you edit source files inside a working directory you can
always find out the state of your files via `cvs status' and `cvs log'.
But as soon as you export the files from your development environment
it becomes harder to identify which revisions they are.

   CVS can use a mechanism known as "keyword substitution" (or "keyword
expansion") to help identifying the files.  Embedded strings of the form
`$KEYWORD$' and `$KEYWORD:...$' in a file are replaced with strings of
the form `$KEYWORD:VALUE$' whenever you obtain a new revision of the
file.

* Menu:

* Keyword list::                   Keywords
* Using keywords::                 Using keywords
* Avoiding substitution::          Avoiding substitution
* Substitution modes::             Substitution modes
* Configuring keyword expansion::  Configuring keyword expansion
* Log keyword::                    Problems with the $Log$ keyword.


File: cvs.info,  Node: Keyword list,  Next: Using keywords,  Up: Keyword substitution

12.1 Keyword List
=================

This is a list of the keywords:

`$Author$'
     The login name of the user who checked in the revision.

`$CVSHeader$'
     A standard header (similar to $Header$, but with the CVS root
     stripped off). It contains the relative pathname of the RCS file
     to the CVS root, the revision number, the date (UTC), the author,
     the state, and the locker (if locked). Files will normally never
     be locked when you use CVS.

     Note that this keyword has only been recently introduced to CVS
     and may cause problems with existing installations if $CVSHeader$
     is already in the files for a different purpose. This keyword may
     be excluded using the `KeywordExpand=eCVSHeader' in the
     `CVSROOT/config' file.  See *Note Configuring keyword expansion::
     for more details.

`$Date$'
     The date and time (UTC) the revision was checked in.

`$Header$'
     A standard header containing the full pathname of the RCS file,
     the revision number, the date (UTC), the author, the state, and
     the locker (if locked).  Files will normally never be locked when
     you use CVS.

`$Id$'
     Same as `$Header$', except that the RCS filename is without a path.

`$Name$'
     Tag name used to check out this file.  The keyword is expanded
     only if one checks out with an explicit tag name.  For example,
     when running the command `cvs co -r first', the keyword expands to
     `Name: first'.

`$Locker$'
     The login name of the user who locked the revision (empty if not
     locked, which is the normal case unless `cvs admin -l' is in use).

`$Log$'
     The log message supplied during commit, preceded by a header
     containing the RCS filename, the revision number, the author, and
     the date (UTC).  Existing log messages are _not_ replaced.
     Instead, the new log message is inserted after `$Log:...$'.  By
     default, each new line is prefixed with the same string which
     precedes the `$Log$' keyword, unless it exceeds the
     `MaxCommentLeaderLength' set in `CVSROOT/config'.

     For example, if the file contains:

            /* Here is what people have been up to:
             *
             * $Log: frob.c,v $
             * Revision 1.1  1997/01/03 14:23:51  joe
             * Add the superfrobnicate option
             *
             */

     then additional lines which are added when expanding the `$Log$'
     keyword will be preceded by `   * '.  Unlike previous versions of
     CVS and RCS, the "comment leader" from the RCS file is not used.
     The `$Log$' keyword is useful for accumulating a complete change
     log in a source file, but for several reasons it can be
     problematic.

     If the prefix of the `$Log$' keyword turns out to be longer than
     `MaxCommentLeaderLength', CVS will skip expansion of this keyword
     unless `UseArchiveCommentLeader' is also set in `CVSROOT/config'
     and a `comment leader' is set in the RCS archive file, in which
     case the comment leader will be used instead.  For more on setting
     the comment leader in the RCS archive file, *Note admin::.  For
     more on configuring the default `$Log$' substitution behavior,
     *Note config::.

     *Note Log keyword::.

`$RCSfile$'
     The name of the RCS file without a path.

`$Revision$'
     The revision number assigned to the revision.

`$Source$'
     The full pathname of the RCS file.

`$State$'
     The state assigned to the revision.  States can be assigned with
     `cvs admin -s'--see *Note admin options::.

`Local keyword'
     The `LocalKeyword' option in the `CVSROOT/config' file may be used
     to specify a local keyword which is to be used as an alias for one
     of the keywords: $Id$, $Header$, or $CVSHeader$. For example, if
     the `CVSROOT/config' file contains a line with
     `LocalKeyword=MYBSD=CVSHeader', then a file with the local keyword
     $MYBSD$ will be expanded as if it were a $CVSHeader$ keyword. If
     the src/frob.c file contained this keyword, it might look
     something like this:

            /*
             * $MYBSD: src/frob.c,v 1.1 2003/05/04 09:27:45 john Exp $
             */

     Many repositories make use of a such a "local keyword" feature. An
     old patch to CVS provided the `LocalKeyword' feature using a `tag='
     option and called this the "custom tag" or "local tag" feature. It
     was used in conjunction with the what they called the `tagexpand='
     option. In CVS this other option is known as the `KeywordExpand'
     option.  See *Note Configuring keyword expansion:: for more
     details.

     Examples from popular projects include: $FreeBSD$, $NetBSD$,
     $OpenBSD$, $XFree86$, $Xorg$.

     The advantage of this is that you can include your local version
     information in a file using this local keyword without disrupting
     the upstream version information (which may be a different local
     keyword or a standard keyword). Allowing bug reports and the like
     to more properly identify the source of the original bug to the
     third-party and reducing the number of conflicts that arise during
     an import of a new version.

     All keyword expansion except the local keyword may be disabled
     using the `KeywordExpand' option in the `CVSROOT/config' file--see
     *Note Configuring keyword expansion:: for more details.



File: cvs.info,  Node: Using keywords,  Next: Avoiding substitution,  Prev: Keyword list,  Up: Keyword substitution

12.2 Using keywords
===================

To include a keyword string you simply include the relevant text
string, such as `$Id$', inside the file, and commit the file.  CVS will
automatically (Or, more accurately, as part of the update run that
automatically happens after a commit.)  expand the string as part of
the commit operation.

   It is common to embed the `$Id$' string in the source files so that
it gets passed through to generated files.  For example, if you are
managing computer program source code, you might include a variable
which is initialized to contain that string.  Or some C compilers may
provide a `#pragma ident' directive.  Or a document management system
might provide a way to pass a string through to generated files.

   The `ident' command (which is part of the RCS package) can be used
to extract keywords and their values from a file.  This can be handy
for text files, but it is even more useful for extracting keywords from
binary files.

     $ ident samp.c
     samp.c:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
     $ gcc samp.c
     $ ident a.out
     a.out:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $

   SCCS is another popular revision control system.  It has a command,
`what', which is very similar to `ident' and used for the same purpose.
Many sites without RCS have SCCS.  Since `what' looks for the
character sequence `@(#)' it is easy to include keywords that are
detected by either command.  Simply prefix the keyword with the magic
SCCS phrase, like this:

     static char *id="@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";


File: cvs.info,  Node: Avoiding substitution,  Next: Substitution modes,  Prev: Using keywords,  Up: Keyword substitution

12.3 Avoiding substitution
==========================

Keyword substitution has its disadvantages.  Sometimes you might want
the literal text string `$Author$' to appear inside a file without CVS
interpreting it as a keyword and expanding it into something like
`$Author: ceder $'.

   There is unfortunately no way to selectively turn off keyword
substitution.  You can use `-ko' (*note Substitution modes::) to turn
off keyword substitution entirely.

   In many cases you can avoid using keywords in the source, even
though they appear in the final product.  For example, the source for
this manual contains `$@asis{}Author$' whenever the text `$Author$'
should appear.  In `nroff' and `troff' you can embed the null-character
`\&' inside the keyword for a similar effect.

   It is also possible to specify an explicit list of keywords to
include or exclude using the `KeywordExpand' option in the
`CVSROOT/config' file-see *Note Configuring keyword expansion:: for
more details. This feature is intended primarily for use with the
`LocalKeyword' option-see *Note Keyword list::.


File: cvs.info,  Node: Substitution modes,  Next: Configuring keyword expansion,  Prev: Avoiding substitution,  Up: Keyword substitution

12.4 Substitution modes
=======================

Each file has a stored default substitution mode, and each working
directory copy of a file also has a substitution mode.  The former is
set by the `-k' option to `cvs add' and `cvs admin'; the latter is set
by the `-k' or `-A' options to `cvs checkout' or `cvs update'.  `cvs
diff' and `cvs rdiff' also have `-k' options.  For some examples, see
*Note Binary files::, and *Note Merging and keywords::.

   The modes available are:

`-kkv'
     Generate keyword strings using the default form, e.g.  `$Revision:
     5.7 $' for the `Revision' keyword.

`-kkvl'
     Like `-kkv', except that a locker's name is always inserted if the
     given revision is currently locked.  The locker's name is only
     relevant if `cvs admin -l' is in use.

`-kk'
     Generate only keyword names in keyword strings; omit their values.
     For example, for the `Revision' keyword, generate the string
     `$Revision$' instead of `$Revision: 5.7 $'.  This option is useful
     to ignore differences due to keyword substitution when comparing
     different revisions of a file (*note Merging and keywords::).

`-ko'
     Generate the old keyword string, present in the working file just
     before it was checked in.  For example, for the `Revision'
     keyword, generate the string `$Revision: 1.1 $' instead of
     `$Revision: 5.7 $' if that is how the string appeared when the
     file was checked in.

`-kb'
     Like `-ko', but also inhibit conversion of line endings between
     the canonical form in which they are stored in the repository
     (linefeed only), and the form appropriate to the operating system
     in use on the client.  For systems, like unix, which use linefeed
     only to terminate lines, this is very similar to `-ko'.  For more
     information on binary files, see *Note Binary files::.  In CVS
     version 1.12.2 and later `-kb', as set by `cvs add', `cvs admin',
     or `cvs import' may not be overridden by a `-k' option specified
     on the command line.

`-kv'
     Generate only keyword values for keyword strings.  For example,
     for the `Revision' keyword, generate the string `5.7' instead of
     `$Revision: 5.7 $'.  This can help generate files in programming
     languages where it is hard to strip keyword delimiters like
     `$Revision: $' from a string.  However, further keyword
     substitution cannot be performed once the keyword names are
     removed, so this option should be used with care.

     One often would like to use `-kv' with `cvs export'--*note
     export::.  But be aware that doesn't handle an export containing
     binary files correctly.



File: cvs.info,  Node: Configuring keyword expansion,  Next: Log keyword,  Prev: Substitution modes,  Up: Keyword substitution

12.5 Configuring Keyword Expansion
==================================

In a repository that includes third-party software on vendor branches,
it is sometimes helpful to configure CVS to use a local keyword instead
of the standard $Id$ or $Header$ keywords. Examples from real projects
include $Xorg$, $XFree86$, $FreeBSD$, $NetBSD$, $OpenBSD$, and even
$dotat$.  The advantage of this is that you can include your local
version information in a file using this local keyword (sometimes
called a "custom tag" or a "local tag") without disrupting the upstream
version information (which may be a different local keyword or a
standard keyword). In these cases, it is typically desirable to disable
the expansion of all keywords except the configured local keyword.

   The `KeywordExpand' option in the `CVSROOT/config' file is intended
to allow for the either the explicit exclusion of a keyword or list of
keywords, or for the explicit inclusion of a keyword or a list of
keywords. This list may include the `LocalKeyword' that has been
configured.

   The `KeywordExpand' option is followed by `=' and the next character
may either be `i' to start an inclusion list or `e' to start an
exclusion list. If the following lines were added to the
`CVSROOT/config' file:

             # Add a "MyBSD" keyword and restrict keyword
             # expansion
             LocalKeyword=MyBSD=CVSHeader
             KeywordExpand=iMyBSD

   then only the $MyBSD$ keyword would be expanded.  A list may be
used. The this example:

             # Add a "MyBSD" keyword and restrict keyword
             # expansion to the MyBSD, Name and Date keywords.
             LocalKeyword=MyBSD=CVSHeader
             KeywordExpand=iMyBSD,Name,Date

   would allow $MyBSD$, $Name$, and $Date$ to be expanded.

   It is also possible to configure an exclusion list using the
following:

             # Do not expand the non-RCS keyword CVSHeader
             KeywordExpand=eCVSHeader

   This allows CVS to ignore the recently introduced $CVSHeader$
keyword and retain all of the others. The exclusion entry could also
contain the standard RCS keyword list, but this could be confusing to
users that expect RCS keywords to be expanded, so care should be taken
to properly set user expectations for a repository that is configured
in that manner.

   If there is a desire to not have any RCS keywords expanded and not
use the `-ko' flags everywhere, an administrator may disable all
keyword expansion using the `CVSROOT/config' line:

     	# Do not expand any RCS keywords
     	KeywordExpand=i

   this could be confusing to users that expect RCS keywords like $Id$
to be expanded properly, so care should be taken to properly set user
expectations for a repository so configured.

   It should be noted that a patch to provide both the `KeywordExpand'
and `LocalKeyword' features has been around a long time. However, that
patch implemented these features using `tag=' and `tagexpand=' keywords
and those keywords are NOT recognized.


File: cvs.info,  Node: Log keyword,  Prev: Configuring keyword expansion,  Up: Keyword substitution

12.6 Problems with the $Log$ keyword.
=====================================

The `$Log$' keyword is somewhat controversial.  As long as you are
working on your development system the information is easily accessible
even if you do not use the `$Log$' keyword--just do a `cvs log'.  Once
you export the file the history information might be useless anyhow.

   A more serious concern is that CVS is not good at handling `$Log$'
entries when a branch is merged onto the main trunk.  Conflicts often
result from the merging operation.

   People also tend to "fix" the log entries in the file (correcting
spelling mistakes and maybe even factual errors).  If that is done the
information from `cvs log' will not be consistent with the information
inside the file.  This may or may not be a problem in real life.

   It has been suggested that the `$Log$' keyword should be inserted
_last_ in the file, and not in the files header, if it is to be used at
all.  That way the long list of change messages will not interfere with
everyday source file browsing.


File: cvs.info,  Node: Tracking sources,  Next: Builds,  Prev: Keyword substitution,  Up: Top

13 Tracking third-party sources
*******************************

If you modify a program to better fit your site, you probably want to
include your modifications when the next release of the program
arrives.  CVS can help you with this task.

   In the terminology used in CVS, the supplier of the program is
called a "vendor".  The unmodified distribution from the vendor is
checked in on its own branch, the "vendor branch".  CVS reserves branch
1.1.1 for this use.

   When you modify the source and commit it, your revision will end up
on the main trunk.  When a new release is made by the vendor, you
commit it on the vendor branch and copy the modifications onto the main
trunk.

   Use the `import' command to create and update the vendor branch.
When you import a new file, (usually) the vendor branch is made the
`head' revision, so anyone that checks out a copy of the file gets that
revision.  When a local modification is committed it is placed on the
main trunk, and made the `head' revision.

* Menu:

* First import::                Importing for the first time
* Update imports::              Updating with the import command
* Reverting local changes::     Reverting to the latest vendor release
* Binary files in imports::     Binary files require special handling
* Keywords in imports::         Keyword substitution might be undesirable
* Multiple vendor branches::    What if you get sources from several places?


File: cvs.info,  Node: First import,  Next: Update imports,  Up: Tracking sources

13.1 Importing for the first time
=================================

Use the `import' command to check in the sources for the first time.
When you use the `import' command to track third-party sources, the
"vendor tag" and "release tags" are useful.  The "vendor tag" is a
symbolic name for the branch (which is always 1.1.1, unless you use the
`-b BRANCH' flag--see *Note Multiple vendor branches::.).  The "release
tags" are symbolic names for a particular release, such as `FSF_0_04'.

   Note that `import' does _not_ change the directory in which you
invoke it.  In particular, it does not set up that directory as a CVS
working directory; if you want to work with the sources import them
first and then check them out into a different directory (*note Getting
the source::).

   Suppose you have the sources to a program called `wdiff' in a
directory `wdiff-0.04', and are going to make private modifications
that you want to be able to use even when new releases are made in the
future.  You start by importing the source to your repository:

     $ cd wdiff-0.04
     $ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04

   The vendor tag is named `FSF_DIST' in the above example, and the
only release tag assigned is `WDIFF_0_04'.


File: cvs.info,  Node: Update imports,  Next: Reverting local changes,  Prev: First import,  Up: Tracking sources

13.2 Updating with the import command
=====================================

When a new release of the source arrives, you import it into the
repository with the same `import' command that you used to set up the
repository in the first place.  The only difference is that you specify
a different release tag this time:

     $ tar xfz wdiff-0.05.tar.gz
     $ cd wdiff-0.05
     $ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05

   *WARNING: If you use a release tag that already exists in one of the
repository archives, files removed by an import may not be detected.*

   For files that have not been modified locally, the newly created
revision becomes the head revision.  If you have made local changes,
`import' will warn you that you must merge the changes into the main
trunk, and tell you to use `checkout -j' to do so:

     $ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff

The above command will check out the latest revision of `wdiff',
merging the changes made on the vendor branch `FSF_DIST' since
yesterday into the working copy.  If any conflicts arise during the
merge they should be resolved in the normal way (*note Conflicts
example::).  Then, the modified files may be committed.

   However, it is much better to use the two release tags rather than
using a date on the branch as suggested above:

     $ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff

The reason this is better is that using a date, as suggested above,
assumes that you do not import more than one release of a product per
day.  More importantly, using the release tags allows CVS to detect
files that were removed between the two vendor releases and mark them
for removal.  Since `import' has no way to detect removed files, you
should do a merge like this even if `import' doesn't tell you to.


File: cvs.info,  Node: Reverting local changes,  Next: Binary files in imports,  Prev: Update imports,  Up: Tracking sources

13.3 Reverting to the latest vendor release
===========================================

You can also revert local changes completely and return to the latest
vendor release by changing the `head' revision back to the vendor
branch on all files.  For example, if you have a checked-out copy of
the sources in `~/work.d/wdiff', and you want to revert to the vendor's
version for all the files in that directory, you would type:

     $ cd ~/work.d/wdiff
     $ cvs admin -bFSF_DIST .

You must specify the `-bFSF_DIST' without any space after the `-b'.
*Note admin options::.


File: cvs.info,  Node: Binary files in imports,  Next: Keywords in imports,  Prev: Reverting local changes,  Up: Tracking sources

13.4 How to handle binary files with cvs import
===============================================

Use the `-k' wrapper option to tell import which files are binary.
*Note Wrappers::.


File: cvs.info,  Node: Keywords in imports,  Next: Multiple vendor branches,  Prev: Binary files in imports,  Up: Tracking sources

13.5 How to handle keyword substitution with cvs import
=======================================================

The sources which you are importing may contain keywords (*note Keyword
substitution::).  For example, the vendor may use CVS or some other
system which uses similar keyword expansion syntax.  If you just import
the files in the default fashion, then the keyword expansions supplied
by the vendor will be replaced by keyword expansions supplied by your
own copy of CVS.  It may be more convenient to maintain the expansions
supplied by the vendor, so that this information can supply information
about the sources that you imported from the vendor.

   To maintain the keyword expansions supplied by the vendor, supply
the `-ko' option to `cvs import' the first time you import the file.
This will turn off keyword expansion for that file entirely, so if you
want to be more selective you'll have to think about what you want and
use the `-k' option to `cvs update' or `cvs admin' as appropriate.


File: cvs.info,  Node: Multiple vendor branches,  Prev: Keywords in imports,  Up: Tracking sources

13.6 Multiple vendor branches
=============================

All the examples so far assume that there is only one vendor from which
you are getting sources.  In some situations you might get sources from
a variety of places.  For example, suppose that you are dealing with a
project where many different people and teams are modifying the
software.  There are a variety of ways to handle this, but in some
cases you have a bunch of source trees lying around and what you want
to do more than anything else is just to all put them in CVS so that
you at least have them in one place.

   For handling situations in which there may be more than one vendor,
you may specify the `-b' option to `cvs import'.  It takes as an
argument the vendor branch to import to.  The default is `-b 1.1.1'.

   For example, suppose that there are two teams, the red team and the
blue team, that are sending you sources.  You want to import the red
team's efforts to branch 1.1.1 and use the vendor tag RED.  You want to
import the blue team's efforts to branch 1.1.3 and use the vendor tag
BLUE.  So the commands you might use are:

     $ cvs import dir RED RED_1-0
     $ cvs import -b 1.1.3 dir BLUE BLUE_1-5

   Note that if your vendor tag does not match your `-b' option, CVS
will not detect this case!  For example,

     $ cvs import -b 1.1.3 dir RED RED_1-0

Be careful; this kind of mismatch is sure to sow confusion or worse.  I
can't think of a useful purpose for the ability to specify a mismatch
here, but if you discover such a use, don't.  CVS is likely to make this
an error in some future release.


File: cvs.info,  Node: Builds,  Next: Special Files,  Prev: Tracking sources,  Up: Top

14 How your build system interacts with CVS
*******************************************

As mentioned in the introduction, CVS does not contain software for
building your software from source code.  This section describes how
various aspects of your build system might interact with CVS.

   One common question, especially from people who are accustomed to
RCS, is how to make their build get an up to date copy of the sources.
The answer to this with CVS is two-fold.  First of all, since CVS
itself can recurse through directories, there is no need to modify your
`Makefile' (or whatever configuration file your build tool uses) to
make sure each file is up to date.  Instead, just use two commands,
first `cvs -q update' and then `make' or whatever the command is to
invoke your build tool.  Secondly, you do not necessarily _want_ to get
a copy of a change someone else made until you have finished your own
work.  One suggested approach is to first update your sources, then
implement, build and test the change you were thinking of, and then
commit your sources (updating first if necessary).  By periodically (in
between changes, using the approach just described) updating your
entire tree, you ensure that your sources are sufficiently up to date.

   One common need is to record which versions of which source files
went into a particular build.  This kind of functionality is sometimes
called "bill of materials" or something similar.  The best way to do
this with CVS is to use the `tag' command to record which versions went
into a given build (*note Tags::).

   Using CVS in the most straightforward manner possible, each
developer will have a copy of the entire source tree which is used in a
particular build.  If the source tree is small, or if developers are
geographically dispersed, this is the preferred solution.  In fact one
approach for larger projects is to break a project down into smaller
separately-compiled subsystems, and arrange a way of releasing them
internally so that each developer need check out only those subsystems
which they are actively working on.

   Another approach is to set up a structure which allows developers to
have their own copies of some files, and for other files to access
source files from a central location.  Many people have come up with
some such a system using features such as the symbolic link feature
found in many operating systems, or the `VPATH' feature found in many
versions of `make'.  One build tool which is designed to help with this
kind of thing is Odin (see
`ftp://ftp.cs.colorado.edu/pub/distribs/odin').


File: cvs.info,  Node: Special Files,  Next: CVS commands,  Prev: Builds,  Up: Top

15 Special Files
****************

In normal circumstances, CVS works only with regular files.  Every file
in a project is assumed to be persistent; it must be possible to open,
read and close them; and so on.  CVS also ignores file permissions and
ownerships, leaving such issues to be resolved by the developer at
installation time.  In other words, it is not possible to "check in" a
device into a repository; if the device file cannot be opened, CVS will
refuse to handle it.  Files also lose their ownerships and permissions
during repository transactions.


File: cvs.info,  Node: CVS commands,  Next: Invoking CVS,  Prev: Special Files,  Up: Top

Appendix A Guide to CVS commands
********************************

This appendix describes the overall structure of CVS commands, and
describes some commands in detail (others are described elsewhere; for
a quick reference to CVS commands, *note Invoking CVS::).

* Menu:

* Structure::                   Overall structure of CVS commands
* Exit status::                 Indicating CVS's success or failure
* ~/.cvsrc::                    Default options with the ~/.cvsrc file
* Global options::              Options you give to the left of cvs_command
* Common options::              Options you give to the right of cvs_command
* Date input formats::		Acceptable formats for date specifications
* admin::                       Administration
* annotate::                    What revision modified each line of a file?
* checkout::                    Checkout sources for editing
* commit::                      Check files into the repository
* diff::                        Show differences between revisions
* export::                      Export sources from CVS, similar to checkout
* history::                     Show status of files and users
* import::                      Import sources into CVS, using vendor branches
* log::                         Show log messages for files
* ls & rls::                    List files in the repository
* rdiff::                       'patch' format diffs between releases
* release::                     Indicate that a directory is no longer in use
* server & pserver::            Act as a server for a client on stdin/stdout
* update::                      Bring work tree in sync with repository


File: cvs.info,  Node: Structure,  Next: Exit status,  Up: CVS commands

A.1 Overall structure of CVS commands
=====================================

The overall format of all CVS commands is:

     cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]

`cvs'
     The name of the CVS program.

`cvs_options'
     Some options that affect all sub-commands of CVS.  These are
     described below.

`cvs_command'
     One of several different sub-commands.  Some of the commands have
     aliases that can be used instead; those aliases are noted in the
     reference manual for that command.  There are only two situations
     where you may omit `cvs_command': `cvs -H' elicits a list of
     available commands, and `cvs -v' displays version information on
     CVS itself.

`command_options'
     Options that are specific for the command.

`command_args'
     Arguments to the commands.

   There is unfortunately some confusion between `cvs_options' and
`command_options'.  When given as a `cvs_option', some options only
affect some of the commands.  When given as a `command_option' it may
have a different meaning, and be accepted by more commands.  In other
words, do not take the above categorization too seriously.  Look at the
documentation instead.


File: cvs.info,  Node: Exit status,  Next: ~/.cvsrc,  Prev: Structure,  Up: CVS commands

A.2 CVS's exit status
=====================

CVS can indicate to the calling environment whether it succeeded or
failed by setting its "exit status".  The exact way of testing the exit
status will vary from one operating system to another.  For example in
a unix shell script the `$?' variable will be 0 if the last command
returned a successful exit status, or greater than 0 if the exit status
indicated failure.

   If CVS is successful, it returns a successful status; if there is an
error, it prints an error message and returns a failure status.  The
one exception to this is the `cvs diff' command.  It will return a
successful status if it found no differences, or a failure status if
there were differences or if there was an error.  Because this behavior
provides no good way to detect errors, in the future it is possible that
`cvs diff' will be changed to behave like the other CVS commands.


File: cvs.info,  Node: ~/.cvsrc,  Next: Global options,  Prev: Exit status,  Up: CVS commands

A.3 Default options and the ~/.cvsrc file
=========================================

There are some `command_options' that are used so often that you might
have set up an alias or some other means to make sure you always
specify that option.  One example (the one that drove the
implementation of the `.cvsrc' support, actually) is that many people
find the default output of the `diff' command to be very hard to read,
and that either context diffs or unidiffs are much easier to understand.

   The `~/.cvsrc' file is a way that you can add default options to
`cvs_commands' within cvs, instead of relying on aliases or other shell
scripts.

   The format of the `~/.cvsrc' file is simple.  The file is searched
for a line that begins with the same name as the `cvs_command' being
executed.  If a match is found, then the remainder of the line is split
up (at whitespace characters) into separate options and added to the
command arguments _before_ any options from the command line.

   If a command has two names (e.g., `checkout' and `co'), the official
name, not necessarily the one used on the command line, will be used to
match against the file.  So if this is the contents of the user's
`~/.cvsrc' file:

     log -N
     diff -uN
     rdiff -u
     update -Pd
     checkout -P
     release -d

the command `cvs checkout foo' would have the `-P' option added to the
arguments, as well as `cvs co foo'.

   With the example file above, the output from `cvs diff foobar' will
be in unidiff format.  `cvs diff -c foobar' will provide context diffs,
as usual.  Getting "old" format diffs would be slightly more
complicated, because `diff' doesn't have an option to specify use of
the "old" format, so you would need `cvs -f diff foobar'.

   In place of the command name you can use `cvs' to specify global
options (*note Global options::).  For example the following line in
`.cvsrc'

     cvs -z6

causes CVS to use compression level 6.


File: cvs.info,  Node: Global options,  Next: Common options,  Prev: ~/.cvsrc,  Up: CVS commands

A.4 Global options
==================

The available `cvs_options' (that are given to the left of
`cvs_command') are:

`--allow-root=ROOTDIR'
     May be invoked multiple times to specify one legal CVSROOT
     directory with each invocation.  Also causes CVS to preparse the
     configuration file for each specified root, which can be useful
     when configuring write proxies,  See *Note Password authentication
     server:: & *Note Write proxies::.

`-a'
     Authenticate all communication between the client and the server.
     Only has an effect on the CVS client.  As of this writing, this is
     only implemented when using a GSSAPI connection (*note GSSAPI
     authenticated::).  Authentication prevents certain sorts of attacks
     involving hijacking the active TCP connection.  Enabling
     authentication does not enable encryption.

`-b BINDIR'
     In CVS 1.9.18 and older, this specified that RCS programs are in
     the BINDIR directory.  Current versions of CVS do not run RCS
     programs; for compatibility this option is accepted, but it does
     nothing.

`-T TEMPDIR'
     Use TEMPDIR as the directory where temporary files are located.

     The CVS client and server store temporary files in a temporary
     directory.  The path to this temporary directory is set via, in
     order of precedence:

        * The argument to the global `-T' option.

        * The value set for `TmpDir' in the config file (server only -
          *note config::).

        * The contents of the `$TMPDIR' environment variable
          (`%TMPDIR%' on Windows - *note Environment variables::).

        * /tmp


     Temporary directories should always be specified as an absolute
     pathname.  When running a CVS client, `-T' affects only the local
     process; specifying `-T' for the client has no effect on the
     server and vice versa.

`-d CVS_ROOT_DIRECTORY'
     Use CVS_ROOT_DIRECTORY as the root directory pathname of the
     repository.  Overrides the setting of the `$CVSROOT' environment
     variable.  *Note Repository::.

`-e EDITOR'
     Use EDITOR to enter revision log information.  Overrides the
     setting of the `$CVSEDITOR' and `$EDITOR' environment variables.
     For more information, see *Note Committing your changes::.

`-f'
     Do not read the `~/.cvsrc' file.  This option is most often used
     because of the non-orthogonality of the CVS option set.  For
     example, the `cvs log' option `-N' (turn off display of tag names)
     does not have a corresponding option to turn the display on.  So
     if you have `-N' in the `~/.cvsrc' entry for `log', you may need
     to use `-f' to show the tag names.

`-H'
`--help'
     Display usage information about the specified `cvs_command' (but
     do not actually execute the command).  If you don't specify a
     command name, `cvs -H' displays overall help for CVS, including a
     list of other help options.

`-R'
     Turns on read-only repository mode.  This allows one to check out
     from a read-only repository, such as within an anoncvs server, or
     from a CD-ROM repository.

     Same effect as if the `CVSREADONLYFS' environment variable is set.
     Using `-R' can also considerably speed up checkouts over NFS.

`-n'
     Do not change any files.  Attempt to execute the `cvs_command',
     but only to issue reports; do not remove, update, or merge any
     existing files, or create any new files.

     Note that CVS will not necessarily produce exactly the same output
     as without `-n'.  In some cases the output will be the same, but
     in other cases CVS will skip some of the processing that would
     have been required to produce the exact same output.

`-Q'
     Cause the command to be really quiet; the command will only
     generate output for serious problems.

`-q'
     Cause the command to be somewhat quiet; informational messages,
     such as reports of recursion through subdirectories, are
     suppressed.

`-r'
     Make new working files read-only.  Same effect as if the
     `$CVSREAD' environment variable is set (*note Environment
     variables::).  The default is to make working files writable,
     unless watches are on (*note Watches::).

`-s VARIABLE=VALUE'
     Set a user variable (*note Variables::).

`-t'
     Trace program execution; display messages showing the steps of CVS
     activity.  Particularly useful with `-n' to explore the potential
     impact of an unfamiliar command.

`-v'

`--version'
     Display version and copyright information for CVS.

`-w'
     Make new working files read-write.  Overrides the setting of the
     `$CVSREAD' environment variable.  Files are created read-write by
     default, unless `$CVSREAD' is set or `-r' is given.

`-x'
     Encrypt all communication between the client and the server.  Only
     has an effect on the CVS client.  As of this writing, this is only
     implemented when using a GSSAPI connection (*note GSSAPI
     authenticated::) or a Kerberos connection (*note Kerberos
     authenticated::).  Enabling encryption implies that message
     traffic is also authenticated.  Encryption support is not
     available by default; it must be enabled using a special configure
     option, `--enable-encryption', when you build CVS.

`-z LEVEL'
     Request compression LEVEL for network traffic.  CVS interprets
     LEVEL identically to the `gzip' program.  Valid levels are 1 (high
     speed, low compression) to 9 (low speed, high compression), or 0
     to disable compression (the default).  Data sent to the server will
     be compressed at the requested level and the client will request
     the server use the same compression level for data returned.  The
     server will use the closest level allowed by the server
     administrator to compress returned data.  This option only has an
     effect when passed to the CVS client.


File: cvs.info,  Node: Common options,  Next: Date input formats,  Prev: Global options,  Up: CVS commands

A.5 Common command options
==========================

This section describes the `command_options' that are available across
several CVS commands.  These options are always given to the right of
`cvs_command'. Not all commands support all of these options; each
option is only supported for commands where it makes sense.  However,
when a command has one of these options you can almost always count on
the same behavior of the option as in other commands.  (Other command
options, which are listed with the individual commands, may have
different behavior from one CVS command to the other).

   *Note_ the `history' command is an exception; it supports many
options that conflict even with these standard options.*

`-D DATE_SPEC'
     Use the most recent revision no later than DATE_SPEC.  DATE_SPEC
     is a single argument, a date description specifying a date in the
     past.

     The specification is "sticky" when you use it to make a private
     copy of a source file; that is, when you get a working file using
     `-D', CVS records the date you specified, so that further updates
     in the same directory will use the same date (for more information
     on sticky tags/dates, *note Sticky tags::).

     `-D' is available with the `annotate', `checkout', `diff',
     `export', `history', `ls', `rdiff', `rls', `rtag', `tag', and
     `update' commands.  (The `history' command uses this option in a
     slightly different way; *note history options::).

     For a complete description of the date formats accepted by CVS,
     *Note Date input formats::.

     Remember to quote the argument to the `-D' flag so that your shell
     doesn't interpret spaces as argument separators.  A command using
     the `-D' flag can look like this:

          $ cvs diff -D "1 hour ago" cvs.texinfo

`-f'
     When you specify a particular date or tag to CVS commands, they
     normally ignore files that do not contain the tag (or did not
     exist prior to the date) that you specified.  Use the `-f' option
     if you want files retrieved even when there is no match for the
     tag or date.  (The most recent revision of the file will be used).

     Note that even with `-f', a tag that you specify must exist (that
     is, in some file, not necessary in every file).  This is so that
     CVS will continue to give an error if you mistype a tag name.

     `-f' is available with these commands: `annotate', `checkout',
     `export', `rdiff', `rtag', and `update'.

     *WARNING:  The `commit' and `remove' commands also have a `-f'
     option, but it has a different behavior for those commands.  See
     *Note commit options::, and *Note Removing files::.*

`-k KFLAG'
     Override the default processing of RCS keywords other than `-kb'.
     *Note Keyword substitution::, for the meaning of KFLAG.  Used with
     the `checkout' and `update' commands, your KFLAG specification is
     "sticky"; that is, when you use this option with a `checkout' or
     `update' command, CVS associates your selected KFLAG with any files
     it operates on, and continues to use that KFLAG with future
     commands on the same files until you specify otherwise.

     The `-k' option is available with the `add', `checkout', `diff',
     `export', `import', `rdiff', and `update' commands.

     *WARNING: Prior to CVS version 1.12.2, the `-k' flag overrode the
     `-kb' indication for a binary file.  This could sometimes corrupt
     binary files.  *Note Merging and keywords::, for more.*

`-l'
     Local; run only in current working directory, rather than
     recursing through subdirectories.

     Available with the following commands: `annotate', `checkout',
     `commit', `diff', `edit', `editors', `export', `log', `rdiff',
     `remove', `rtag', `status', `tag', `unedit', `update', `watch',
     and `watchers'.

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

     Available with the following commands: `add', `commit' and
     `import'.

`-n'
     Do not run any tag program.  (A program can be specified to run in
     the modules database (*note modules::); this option bypasses it).

     *Note_ this is not the same as the `cvs -n' program option, which
     you can specify to the left of a cvs command!*

     Available with the `checkout', `commit', `export', and `rtag'
     commands.

`-P'
     Prune empty directories.  See *Note Removing directories::.

`-p'
     Pipe the files retrieved from the repository to standard output,
     rather than writing them in the current directory.  Available with
     the `checkout' and `update' commands.

`-R'
     Process directories recursively.  This is the default for all CVS
     commands, with the exception of `ls' & `rls'.

     Available with the following commands: `annotate', `checkout',
     `commit', `diff', `edit', `editors', `export', `ls', `rdiff',
     `remove', `rls', `rtag', `status', `tag', `unedit', `update',
     `watch', and `watchers'.

`-r TAG'

`-r TAG[:DATE]'
     Use the revision specified by the TAG argument (and the DATE
     argument for the commands which accept it) instead of the default
     "head" revision.  As well as arbitrary tags defined with the `tag'
     or `rtag' command, two special tags are always available: `HEAD'
     refers to the most recent version available in the repository, and
     `BASE' refers to the revision you last checked out into the
     current working directory.

     The tag specification is sticky when you use this with `checkout'
     or `update' to make your own copy of a file: CVS remembers the tag
     and continues to use it on future update commands, until you
     specify otherwise (for more information on sticky tags/dates,
     *note Sticky tags::).

     The tag can be either a symbolic or numeric tag, as described in
     *Note Tags::, or the name of a branch, as described in *Note
     Branching and merging::.  When TAG is the name of a branch, some
     commands accept the optional DATE argument to specify the revision
     as of the given date on the branch.  When a command expects a
     specific revision, the name of a branch is interpreted as the most
     recent revision on that branch.

     Specifying the `-q' global option along with the `-r' command
     option is often useful, to suppress the warning messages when the
     RCS file does not contain the specified tag.

     *Note_ this is not the same as the overall `cvs -r' option, which
     you can specify to the left of a CVS command!*

     `-r TAG' is available with the `commit' and `history' commands.

     `-r TAG[:DATE]' is available with the `annotate', `checkout',
     `diff', `export', `rdiff', `rtag', and `update' commands.

`-W'
     Specify file names that should be filtered.  You can use this
     option repeatedly.  The spec can be a file name pattern of the
     same type that you can specify in the `.cvswrappers' file.
     Available with the following commands: `import', and `update'.



File: cvs.info,  Node: Date input formats,  Next: admin,  Prev: Common options,  Up: CVS commands

A.6 Date input formats
======================

First, a quote:

     Our units of temporal measurement, from seconds on up to months,
     are so complicated, asymmetrical and disjunctive so as to make
     coherent mental reckoning in time all but impossible.  Indeed, had
     some tyrannical god contrived to enslave our minds to time, to
     make it all but impossible for us to escape subjection to sodden
     routines and unpleasant surprises, he could hardly have done
     better than handing down our present system.  It is like a set of
     trapezoidal building blocks, with no vertical or horizontal
     surfaces, like a language in which the simplest thought demands
     ornate constructions, useless particles and lengthy
     circumlocutions.  Unlike the more successful patterns of language
     and science, which enable us to face experience boldly or at least
     level-headedly, our system of temporal calculation silently and
     persistently encourages our terror of time.

     ...  It is as though architects had to measure length in feet,
     width in meters and height in ells; as though basic instruction
     manuals demanded a knowledge of five different languages.  It is
     no wonder then that we often look into our own immediate past or
     future, last Tuesday or a week from Sunday, with feelings of
     helpless confusion.  ...

     -- Robert Grudin, `Time and the Art of Living'.

   This section describes the textual date representations that GNU
programs accept.  These are the strings you, as a user, can supply as
arguments to the various programs.  The C interface (via the `get_date'
function) is not described here.

* Menu:

* General date syntax::            Common rules.
* Calendar date items::            19 Dec 1994.
* Time of day items::              9:20pm.
* Time zone items::                EST, PDT, GMT.
* Day of week items::              Monday and others.
* Relative items in date strings:: next tuesday, 2 years ago.
* Pure numbers in date strings::   19931219, 1440.
* Seconds since the Epoch::        @1078100502.
* Specifying time zone rules::     TZ="America/New_York", TZ="UTC0".
* Authors of get_date::            Bellovin, Eggert, Salz, Berets, et al.


File: cvs.info,  Node: General date syntax,  Next: Calendar date items,  Up: Date input formats

A.6.1 General date syntax
-------------------------

A "date" is a string, possibly empty, containing many items separated
by whitespace.  The whitespace may be omitted when no ambiguity arises.
The empty string means the beginning of today (i.e., midnight).  Order
of the items is immaterial.  A date string may contain many flavors of
items:

   * calendar date items

   * time of day items

   * time zone items

   * day of the week items

   * relative items

   * pure numbers.

We describe each of these item types in turn, below.

   A few ordinal numbers may be written out in words in some contexts.
This is most useful for specifying day of the week items or relative
items (see below).  Among the most commonly used ordinal numbers, the
word `last' stands for -1, `this' stands for 0, and `first' and `next'
both stand for 1.  Because the word `second' stands for the unit of
time there is no way to write the ordinal number 2, but for convenience
`third' stands for 3, `fourth' for 4, `fifth' for 5, `sixth' for 6,
`seventh' for 7, `eighth' for 8, `ninth' for 9, `tenth' for 10,
`eleventh' for 11 and `twelfth' for 12.

   When a month is written this way, it is still considered to be
written numerically, instead of being "spelled in full"; this changes
the allowed strings.

   In the current implementation, only English is supported for words
and abbreviations like `AM', `DST', `EST', `first', `January',
`Sunday', `tomorrow', and `year'.

   The output of the `date' command is not always acceptable as a date
string, not only because of the language problem, but also because
there is no standard meaning for time zone items like `IST'.  When using
`date' to generate a date string intended to be parsed later, specify a
date format that is independent of language and that does not use time
zone items other than `UTC' and `Z'.  Here are some ways to do this:

     $ LC_ALL=C TZ=UTC0 date
     Mon Mar  1 00:21:42 UTC 2004
     $ TZ=UTC0 date +'%Y-%m-%d %H:%M:%SZ'
     2004-03-01 00:21:42Z
     $ date --iso-8601=ns | tr T ' '  # --iso-8601 is a GNU extension.
     2004-02-29 16:21:42,692722128-0800
     $ date --rfc-2822  # a GNU extension
     Sun, 29 Feb 2004 16:21:42 -0800
     $ date +'%Y-%m-%d %H:%M:%S %z'  # %z is a GNU extension.
     2004-02-29 16:21:42 -0800
     $ date +'@%s.%N'  # %s and %N are GNU extensions.
     @1078100502.692722128

   Alphabetic case is completely ignored in dates.  Comments may be
introduced between round parentheses, as long as included parentheses
are properly nested.  Hyphens not followed by a digit are currently
ignored.  Leading zeros on numbers are ignored.


File: cvs.info,  Node: Calendar date items,  Next: Time of day items,  Prev: General date syntax,  Up: Date input formats

A.6.2 Calendar date items
-------------------------

A "calendar date item" specifies a day of the year.  It is specified
differently, depending on whether the month is specified numerically or
literally.  All these strings specify the same calendar date:

     1972-09-24     # ISO 8601.
     72-9-24        # Assume 19xx for 69 through 99,
                    # 20xx for 00 through 68.
     72-09-24       # Leading zeros are ignored.
     9/24/72        # Common U.S. writing.
     24 September 1972
     24 Sept 72     # September has a special abbreviation.
     24 Sep 72      # Three-letter abbreviations always allowed.
     Sep 24, 1972
     24-sep-72
     24sep72

   The year can also be omitted.  In this case, the last specified year
is used, or the current year if none.  For example:

     9/24
     sep 24

   Here are the rules.

   For numeric months, the ISO 8601 format `YEAR-MONTH-DAY' is allowed,
where YEAR is any positive number, MONTH is a number between 01 and 12,
and DAY is a number between 01 and 31.  A leading zero must be present
if a number is less than ten.  If YEAR is 68 or smaller, then 2000 is
added to it; otherwise, if YEAR is less than 100, then 1900 is added to
it.  The construct `MONTH/DAY/YEAR', popular in the United States, is
accepted.  Also `MONTH/DAY', omitting the year.

   Literal months may be spelled out in full: `January', `February',
`March', `April', `May', `June', `July', `August', `September',
`October', `November' or `December'.  Literal months may be abbreviated
to their first three letters, possibly followed by an abbreviating dot.
It is also permitted to write `Sept' instead of `September'.

   When months are written literally, the calendar date may be given as
any of the following:

     DAY MONTH YEAR
     DAY MONTH
     MONTH DAY YEAR
     DAY-MONTH-YEAR

   Or, omitting the year:

     MONTH DAY


File: cvs.info,  Node: Time of day items,  Next: Time zone items,  Prev: Calendar date items,  Up: Date input formats

A.6.3 Time of day items
-----------------------

A "time of day item" in date strings specifies the time on a given day.
Here are some examples, all of which represent the same time:

     20:02:00.000000
     20:02
     8:02pm
     20:02-0500      # In EST (U.S. Eastern Standard Time).

   More generally, the time of day may be given as
`HOUR:MINUTE:SECOND', where HOUR is a number between 0 and 23, MINUTE
is a number between 0 and 59, and SECOND is a number between 0 and 59
possibly followed by `.' or `,' and a fraction containing one or more
digits.  Alternatively, `:SECOND' can be omitted, in which case it is
taken to be zero.

   If the time is followed by `am' or `pm' (or `a.m.' or `p.m.'), HOUR
is restricted to run from 1 to 12, and `:MINUTE' may be omitted (taken
to be zero).  `am' indicates the first half of the day, `pm' indicates
the second half of the day.  In this notation, 12 is the predecessor of
1: midnight is `12am' while noon is `12pm'.  (This is the zero-oriented
interpretation of `12am' and `12pm', as opposed to the old tradition
derived from Latin which uses `12m' for noon and `12pm' for midnight.)

   The time may alternatively be followed by a time zone correction,
expressed as `SHHMM', where S is `+' or `-', HH is a number of zone
hours and MM is a number of zone minutes.  You can also separate HH
from MM with a colon.  When a time zone correction is given this way, it
forces interpretation of the time relative to Coordinated Universal
Time (UTC), overriding any previous specification for the time zone or
the local time zone.  For example, `+0530' and `+05:30' both stand for
the time zone 5.5 hours ahead of UTC (e.g., India).  The MINUTE part of
the time of day may not be elided when a time zone correction is used.
This is the best way to specify a time zone correction by fractional
parts of an hour.

   Either `am'/`pm' or a time zone correction may be specified, but not
both.


File: cvs.info,  Node: Time zone items,  Next: Day of week items,  Prev: Time of day items,  Up: Date input formats

A.6.4 Time zone items
---------------------

A "time zone item" specifies an international time zone, indicated by a
small set of letters, e.g., `UTC' or `Z' for Coordinated Universal
Time.  Any included periods are ignored.  By following a
non-daylight-saving time zone by the string `DST' in a separate word
(that is, separated by some white space), the corresponding daylight
saving time zone may be specified.  Alternatively, a
non-daylight-saving time zone can be followed by a time zone
correction, to add the two values.  This is normally done only for
`UTC'; for example, `UTC+05:30' is equivalent to `+05:30'.

   Time zone items other than `UTC' and `Z' are obsolescent and are not
recommended, because they are ambiguous; for example, `EST' has a
different meaning in Australia than in the United States.  Instead,
it's better to use unambiguous numeric time zone corrections like
`-0500', as described in the previous section.

   If neither a time zone item nor a time zone correction is supplied,
time stamps are interpreted using the rules of the default time zone
(*note Specifying time zone rules::).


File: cvs.info,  Node: Day of week items,  Next: Relative items in date strings,  Prev: Time zone items,  Up: Date input formats

A.6.5 Day of week items
-----------------------

The explicit mention of a day of the week will forward the date (only
if necessary) to reach that day of the week in the future.

   Days of the week may be spelled out in full: `Sunday', `Monday',
`Tuesday', `Wednesday', `Thursday', `Friday' or `Saturday'.  Days may
be abbreviated to their first three letters, optionally followed by a
period.  The special abbreviations `Tues' for `Tuesday', `Wednes' for
`Wednesday' and `Thur' or `Thurs' for `Thursday' are also allowed.

   A number may precede a day of the week item to move forward
supplementary weeks.  It is best used in expression like `third
monday'.  In this context, `last DAY' or `next DAY' is also acceptable;
they move one week before or after the day that DAY by itself would
represent.

   A comma following a day of the week item is ignored.


File: cvs.info,  Node: Relative items in date strings,  Next: Pure numbers in date strings,  Prev: Day of week items,  Up: Date input formats

A.6.6 Relative items in date strings
------------------------------------

"Relative items" adjust a date (or the current date if none) forward or
backward.  The effects of relative items accumulate.  Here are some
examples:

     1 year
     1 year ago
     3 years
     2 days

   The unit of time displacement may be selected by the string `year'
or `month' for moving by whole years or months.  These are fuzzy units,
as years and months are not all of equal duration.  More precise units
are `fortnight' which is worth 14 days, `week' worth 7 days, `day'
worth 24 hours, `hour' worth 60 minutes, `minute' or `min' worth 60
seconds, and `second' or `sec' worth one second.  An `s' suffix on
these units is accepted and ignored.

   The unit of time may be preceded by a multiplier, given as an
optionally signed number.  Unsigned numbers are taken as positively
signed.  No number at all implies 1 for a multiplier.  Following a
relative item by the string `ago' is equivalent to preceding the unit
by a multiplier with value -1.

   The string `tomorrow' is worth one day in the future (equivalent to
`day'), the string `yesterday' is worth one day in the past (equivalent
to `day ago').

   The strings `now' or `today' are relative items corresponding to
zero-valued time displacement, these strings come from the fact a
zero-valued time displacement represents the current time when not
otherwise changed by previous items.  They may be used to stress other
items, like in `12:00 today'.  The string `this' also has the meaning
of a zero-valued time displacement, but is preferred in date strings
like `this thursday'.

   When a relative item causes the resulting date to cross a boundary
where the clocks were adjusted, typically for daylight saving time, the
resulting date and time are adjusted accordingly.

   The fuzz in units can cause problems with relative items.  For
example, `2003-07-31 -1 month' might evaluate to 2003-07-01, because
2003-06-31 is an invalid date.  To determine the previous month more
reliably, you can ask for the month before the 15th of the current
month.  For example:

     $ date -R
     Thu, 31 Jul 2003 13:02:39 -0700
     $ date --date='-1 month' +'Last month was %B?'
     Last month was July?
     $ date --date="$(date +%Y-%m-15) -1 month" +'Last month was %B!'
     Last month was June!

   Also, take care when manipulating dates around clock changes such as
daylight saving leaps.  In a few cases these have added or subtracted
as much as 24 hours from the clock, so it is often wise to adopt
universal time by setting the `TZ' environment variable to `UTC0'
before embarking on calendrical calculations.


File: cvs.info,  Node: Pure numbers in date strings,  Next: Seconds since the Epoch,  Prev: Relative items in date strings,  Up: Date input formats

A.6.7 Pure numbers in date strings
----------------------------------

The precise interpretation of a pure decimal number depends on the
context in the date string.

   If the decimal number is of the form YYYYMMDD and no other calendar
date item (*note Calendar date items::) appears before it in the date
string, then YYYY is read as the year, MM as the month number and DD as
the day of the month, for the specified calendar date.

   If the decimal number is of the form HHMM and no other time of day
item appears before it in the date string, then HH is read as the hour
of the day and MM as the minute of the hour, for the specified time of
day.  MM can also be omitted.

   If both a calendar date and a time of day appear to the left of a
number in the date string, but no relative item, then the number
overrides the year.


File: cvs.info,  Node: Seconds since the Epoch,  Next: Specifying time zone rules,  Prev: Pure numbers in date strings,  Up: Date input formats

A.6.8 Seconds since the Epoch
-----------------------------

If you precede a number with `@', it represents an internal time stamp
as a count of seconds.  The number can contain an internal decimal
point (either `.' or `,'); any excess precision not supported by the
internal representation is truncated toward minus infinity.  Such a
number cannot be combined with any other date item, as it specifies a
complete time stamp.

   Internally, computer times are represented as a count of seconds
since an epoch--a well-defined point of time.  On GNU and POSIX
systems, the epoch is 1970-01-01 00:00:00 UTC, so `@0' represents this
time, `@1' represents 1970-01-01 00:00:01 UTC, and so forth.  GNU and
most other POSIX-compliant systems support such times as an extension
to POSIX, using negative counts, so that `@-1' represents 1969-12-31
23:59:59 UTC.

   Traditional Unix systems count seconds with 32-bit two's-complement
integers and can represent times from 1901-12-13 20:45:52 through
2038-01-19 03:14:07 UTC.  More modern systems use 64-bit counts of
seconds with nanosecond subcounts, and can represent all the times in
the known lifetime of the universe to a resolution of 1 nanosecond.

   On most systems, these counts ignore the presence of leap seconds.
For example, on most systems `@915148799' represents 1998-12-31
23:59:59 UTC, `@915148800' represents 1999-01-01 00:00:00 UTC, and
there is no way to represent the intervening leap second 1998-12-31
23:59:60 UTC.


File: cvs.info,  Node: Specifying time zone rules,  Next: Authors of get_date,  Prev: Seconds since the Epoch,  Up: Date input formats

A.6.9 Specifying time zone rules
--------------------------------

Normally, dates are interpreted using the rules of the current time
zone, which in turn are specified by the `TZ' environment variable, or
by a system default if `TZ' is not set.  To specify a different set of
default time zone rules that apply just to one date, start the date
with a string of the form `TZ="RULE"'.  The two quote characters (`"')
must be present in the date, and any quotes or backslashes within RULE
must be escaped by a backslash.

   For example, with the GNU `date' command you can answer the question
"What time is it in New York when a Paris clock shows 6:30am on October
31, 2004?" by using a date beginning with `TZ="Europe/Paris"' as shown
in the following shell transcript:

     $ export TZ="America/New_York"
     $ date --date='TZ="Europe/Paris" 2004-10-31 06:30'
     Sun Oct 31 01:30:00 EDT 2004

   In this example, the `--date' operand begins with its own `TZ'
setting, so the rest of that operand is processed according to
`Europe/Paris' rules, treating the string `2004-10-31 06:30' as if it
were in Paris.  However, since the output of the `date' command is
processed according to the overall time zone rules, it uses New York
time.  (Paris was normally six hours ahead of New York in 2004, but
this example refers to a brief Halloween period when the gap was five
hours.)

   A `TZ' value is a rule that typically names a location in the `tz'
database (http://www.twinsun.com/tz/tz-link.htm).  A recent catalog of
location names appears in the TWiki Date and Time Gateway
(http://twiki.org/cgi-bin/xtra/tzdate).  A few non-GNU hosts require a
colon before a location name in a `TZ' setting, e.g.,
`TZ=":America/New_York"'.

   The `tz' database includes a wide variety of locations ranging from
`Arctic/Longyearbyen' to `Antarctica/South_Pole', but if you are at sea
and have your own private time zone, or if you are using a non-GNU host
that does not support the `tz' database, you may need to use a POSIX
rule instead.  Simple POSIX rules like `UTC0' specify a time zone
without daylight saving time; other rules can specify simple daylight
saving regimes.  *Note Specifying the Time Zone with `TZ': (libc)TZ
Variable.


File: cvs.info,  Node: Authors of get_date,  Prev: Specifying time zone rules,  Up: Date input formats

A.6.10 Authors of `get_date'
----------------------------

`get_date' was originally implemented by Steven M. Bellovin
(<smb@research.att.com>) while at the University of North Carolina at
Chapel Hill.  The code was later tweaked by a couple of people on
Usenet, then completely overhauled by Rich $alz (<rsalz@bbn.com>) and
Jim Berets (<jberets@bbn.com>) in August, 1990.  Various revisions for
the GNU system were made by David MacKenzie, Jim Meyering, Paul Eggert
and others.

   This chapter was originally produced by Franc,ois Pinard
(<pinard@iro.umontreal.ca>) from the `getdate.y' source code, and then
edited by K. Berry (<kb@cs.umb.edu>).


File: cvs.info,  Node: admin,  Next: annotate,  Prev: Date input formats,  Up: CVS commands

A.7 admin--Administration
=========================

   * Requires: repository, working directory.

   * Changes: repository.

   * Synonym: rcs

   This is the CVS interface to assorted administrative facilities.
Some of them have questionable usefulness for CVS but exist for
historical purposes.  Some of the questionable options are likely to
disappear in the future.  This command _does_ work recursively, so
extreme care should be used.

   On unix, if there is a group named `cvsadmin', only members of that
group can run `cvs admin' commands, except for those specified using the
`UserAdminOptions' configuration option in the `CVSROOT/config' file.
Options specified using `UserAdminOptions' can be run by any user.  See
*Note config:: for more on `UserAdminOptions'.

   The `cvsadmin' group should exist on the server, or any system
running the non-client/server CVS.  To disallow `cvs admin' for all
users, create a group with no users in it.  On NT, the `cvsadmin'
feature does not exist and all users can run `cvs admin'.

* Menu:

* admin options::               admin options


File: cvs.info,  Node: admin options,  Up: admin

A.7.1 admin options
-------------------

Some of these options have questionable usefulness for CVS but exist
for historical purposes.  Some even make it impossible to use CVS until
you undo the effect!

`-AOLDFILE'
     Might not work together with CVS.  Append the access list of
     OLDFILE to the access list of the RCS file.

`-aLOGINS'
     Might not work together with CVS.  Append the login names
     appearing in the comma-separated list LOGINS to the access list of
     the RCS file.

`-b[REV]'
     Set the default branch to REV.  In CVS, you normally do not
     manipulate default branches; sticky tags (*note Sticky tags::) are
     a better way to decide which branch you want to work on.  There is
     one reason to run `cvs admin -b': to revert to the vendor's
     version when using vendor branches (*note Reverting local
     changes::).  There can be no space between `-b' and its argument.

`-cSTRING'
     Sets the comment leader to STRING.  The comment leader is not used
     by current versions of CVS or RCS 5.7.  Therefore, you can almost
     surely not worry about it.  *Note Keyword substitution::.

`-e[LOGINS]'
     Might not work together with CVS.  Erase the login names appearing
     in the comma-separated list LOGINS from the access list of the RCS
     file.  If LOGINS is omitted, erase the entire access list.  There
     can be no space between `-e' and its argument.

`-I'
     Run interactively, even if the standard input is not a terminal.
     This option does not work with the client/server CVS and is likely
     to disappear in a future release of CVS.

`-i'
     Useless with CVS.  This creates and initializes a new RCS file,
     without depositing a revision.  With CVS, add files with the `cvs
     add' command (*note Adding files::).

`-kSUBST'
     Set the default keyword substitution to SUBST.  *Note Keyword
     substitution::.  Giving an explicit `-k' option to `cvs update',
     `cvs export', or `cvs checkout' overrides this default.

`-l[REV]'
     Lock the revision with number REV.  If a branch is given, lock the
     latest revision on that branch.  If REV is omitted, lock the
     latest revision on the default branch.  There can be no space
     between `-l' and its argument.

     This can be used in conjunction with the `rcslock.pl' script in
     the `contrib' directory of the CVS source distribution to provide
     reserved checkouts (where only one user can be editing a given
     file at a time).  See the comments in that file for details (and
     see the `README' file in that directory for disclaimers about the
     unsupported nature of contrib).  According to comments in that
     file, locking must set to strict (which is the default).

`-L'
     Set locking to strict.  Strict locking means that the owner of an
     RCS file is not exempt from locking for checkin.  For use with
     CVS, strict locking must be set; see the discussion under the `-l'
     option above.

`-mREV:MSG'
     Replace the log message of revision REV with MSG.

`-NNAME[:[REV]]'
     Act like `-n', except override any previous assignment of NAME.
     For use with magic branches, see *Note Magic branch numbers::.

`-nNAME[:[REV]]'
     Associate the symbolic name NAME with the branch or revision REV.
     It is normally better to use `cvs tag' or `cvs rtag' instead.
     Delete the symbolic name if both `:' and REV are omitted;
     otherwise, print an error message if NAME is already associated
     with another number.  If REV is symbolic, it is expanded before
     association.  A REV consisting of a branch number followed by a
     `.' stands for the current latest revision in the branch.  A `:'
     with an empty REV stands for the current latest revision on the
     default branch, normally the trunk.  For example, `cvs admin
     -nNAME:' associates NAME with the current latest revision of all
     the RCS files; this contrasts with `cvs admin -nNAME:$' which
     associates NAME with the revision numbers extracted from keyword
     strings in the corresponding working files.

`-oRANGE'
     Deletes ("outdates") the revisions given by RANGE.

     Note that this command can be quite dangerous unless you know
     _exactly_ what you are doing (for example see the warnings below
     about how the REV1:REV2 syntax is confusing).

     If you are short on disc this option might help you.  But think
     twice before using it--there is no way short of restoring the
     latest backup to undo this command!  If you delete different
     revisions than you planned, either due to carelessness or (heaven
     forbid) a CVS bug, there is no opportunity to correct the error
     before the revisions are deleted.  It probably would be a good
     idea to experiment on a copy of the repository first.

     Specify RANGE in one of the following ways:

    `REV1::REV2'
          Collapse all revisions between rev1 and rev2, so that CVS
          only stores the differences associated with going from rev1
          to rev2, not intermediate steps.  For example, after `-o
          1.3::1.5' one can retrieve revision 1.3, revision 1.5, or the
          differences to get from 1.3 to 1.5, but not the revision 1.4,
          or the differences between 1.3 and 1.4.  Other examples: `-o
          1.3::1.4' and `-o 1.3::1.3' have no effect, because there are
          no intermediate revisions to remove.

    `::REV'
          Collapse revisions between the beginning of the branch
          containing REV and REV itself.  The branchpoint and REV are
          left intact.  For example, `-o ::1.3.2.6' deletes revision
          1.3.2.1, revision 1.3.2.5, and everything in between, but
          leaves 1.3 and 1.3.2.6 intact.

    `REV::'
          Collapse revisions between REV and the end of the branch
          containing REV.  Revision REV is left intact but the head
          revision is deleted.

    `REV'
          Delete the revision REV.  For example, `-o 1.3' is equivalent
          to `-o 1.2::1.4'.

    `REV1:REV2'
          Delete the revisions from REV1 to REV2, inclusive, on the
          same branch.  One will not be able to retrieve REV1 or REV2
          or any of the revisions in between.  For example, the command
          `cvs admin -oR_1_01:R_1_02 .' is rarely useful.  It means to
          delete revisions up to, and including, the tag R_1_02.  But
          beware!  If there are files that have not changed between
          R_1_02 and R_1_03 the file will have _the same_ numerical
          revision number assigned to the tags R_1_02 and R_1_03.  So
          not only will it be impossible to retrieve R_1_02; R_1_03
          will also have to be restored from the tapes!  In most cases
          you want to specify REV1::REV2 instead.

    `:REV'
          Delete revisions from the beginning of the branch containing
          REV up to and including REV.

    `REV:'
          Delete revisions from revision REV, including REV itself, to
          the end of the branch containing REV.

     None of the revisions to be deleted may have branches or locks.

     If any of the revisions to be deleted have symbolic names, and one
     specifies one of the `::' syntaxes, then CVS will give an error
     and not delete any revisions.  If you really want to delete both
     the symbolic names and the revisions, first delete the symbolic
     names with `cvs tag -d', then run `cvs admin -o'.  If one
     specifies the non-`::' syntaxes, then CVS will delete the
     revisions but leave the symbolic names pointing to nonexistent
     revisions.  This behavior is preserved for compatibility with
     previous versions of CVS, but because it isn't very useful, in the
     future it may change to be like the `::' case.

     Due to the way CVS handles branches REV cannot be specified
     symbolically if it is a branch.  *Note Magic branch numbers::, for
     an explanation.

     Make sure that no-one has checked out a copy of the revision you
     outdate.  Strange things will happen if he starts to edit it and
     tries to check it back in.  For this reason, this option is not a
     good way to take back a bogus commit; commit a new revision
     undoing the bogus change instead (*note Merging two revisions::).

`-q'
     Run quietly; do not print diagnostics.

`-sSTATE[:REV]'
     Useful with CVS.  Set the state attribute of the revision REV to
     STATE.  If REV is a branch number, assume the latest revision on
     that branch.  If REV is omitted, assume the latest revision on the
     default branch.  Any identifier is acceptable for STATE.  A useful
     set of states is `Exp' (for experimental), `Stab' (for stable),
     and `Rel' (for released).  By default, the state of a new revision
     is set to `Exp' when it is created.  The state is visible in the
     output from CVS LOG (*note log::), and in the `$Log$' and
     `$State$' keywords (*note Keyword substitution::).  Note that CVS
     uses the `dead' state for its own purposes (*note Attic::); to
     take a file to or from the `dead' state use commands like `cvs
     remove' and `cvs add' (*note Adding and removing::), not `cvs
     admin -s'.

`-t[FILE]'
     Useful with CVS.  Write descriptive text from the contents of the
     named FILE into the RCS file, deleting the existing text.  The
     FILE pathname may not begin with `-'.  The descriptive text can be
     seen in the output from `cvs log' (*note log::).  There can be no
     space between `-t' and its argument.

     If FILE is omitted, obtain the text from standard input,
     terminated by end-of-file or by a line containing `.' by itself.
     Prompt for the text if interaction is possible; see `-I'.

`-t-STRING'
     Similar to `-tFILE'. Write descriptive text from the STRING into
     the RCS file, deleting the existing text.  There can be no space
     between `-t' and its argument.

`-U'
     Set locking to non-strict.  Non-strict locking means that the
     owner of a file need not lock a revision for checkin.  For use
     with CVS, strict locking must be set; see the discussion under the
     `-l' option above.

`-u[REV]'
     See the option `-l' above, for a discussion of using this option
     with CVS.  Unlock the revision with number REV.  If a branch is
     given, unlock the latest revision on that branch.  If REV is
     omitted, remove the latest lock held by the caller.  Normally,
     only the locker of a revision may unlock it; somebody else
     unlocking a revision breaks the lock.  This causes the original
     locker to be sent a `commit' notification (*note Getting
     Notified::).  There can be no space between `-u' and its argument.

`-VN'
     In previous versions of CVS, this option meant to write an RCS
     file which would be acceptable to RCS version N, but it is now
     obsolete and specifying it will produce an error.

`-xSUFFIXES'
     In previous versions of CVS, this was documented as a way of
     specifying the names of the RCS files.  However, CVS has always
     required that the RCS files used by CVS end in `,v', so this
     option has never done anything useful.



File: cvs.info,  Node: annotate,  Next: checkout,  Prev: admin,  Up: CVS commands

A.8 annotate--What revision modified each line of a file?
=========================================================

   * Synopsis: annotate [options] files...

   * Requires: repository.

   * Changes: nothing.

   For each file in FILES, print the head revision of the trunk,
together with information on the last modification for each line.

* Menu:

* annotate options::            annotate options
* annotate example::            annotate example


File: cvs.info,  Node: annotate options,  Next: annotate example,  Up: annotate

A.8.1 annotate options
----------------------

These standard options are supported by `annotate' (*note Common
options::, for a complete description of them):

`-l'
     Local directory only, no recursion.

`-R'
     Process directories recursively.

`-f'
     Use head revision if tag/date not found.

`-F'
     Annotate binary files.

`-r TAG[:DATE]'
     Annotate file as of specified revision/tag or, when DATE is
     specified and TAG is a branch tag, the version from the branch TAG
     as it existed on DATE.  See *Note Common options::.

`-D DATE'
     Annotate file as of specified date.


File: cvs.info,  Node: annotate example,  Prev: annotate options,  Up: annotate

A.8.2 annotate example
----------------------

For example:

     $ cvs annotate ssfile
     Annotations for ssfile
     ***************
     1.1          (mary     27-Mar-96): ssfile line 1
     1.2          (joe      28-Mar-96): ssfile line 2

   The file `ssfile' currently contains two lines.  The `ssfile line 1'
line was checked in by `mary' on March 27.  Then, on March 28, `joe'
added a line `ssfile line 2', without modifying the `ssfile line 1'
line.  This report doesn't tell you anything about lines which have
been deleted or replaced; you need to use `cvs diff' for that (*note
diff::).

   The options to `cvs annotate' are listed in *Note Invoking CVS::,
and can be used to select the files and revisions to annotate.  The
options are described in more detail there and in *Note Common
options::.


File: cvs.info,  Node: checkout,  Next: commit,  Prev: annotate,  Up: CVS commands

A.9 checkout--Check out sources for editing
===========================================

   * Synopsis: checkout [options] modules...

   * Requires: repository.

   * Changes: working directory.

   * Synonyms: co, get

   Create or update a working directory containing copies of the source
files specified by MODULES.  You must execute `checkout' before using
most of the other CVS commands, since most of them operate on your
working directory.

   The MODULES are either symbolic names for some collection of source
directories and files, or paths to directories or files in the
repository.  The symbolic names are defined in the `modules' file.
*Note modules::.

   Depending on the modules you specify, `checkout' may recursively
create directories and populate them with the appropriate source files.
You can then edit these source files at any time (regardless of
whether other software developers are editing their own copies of the
sources); update them to include new changes applied by others to the
source repository; or commit your work as a permanent change to the
source repository.

   Note that `checkout' is used to create directories.  The top-level
directory created is always added to the directory where `checkout' is
invoked, and usually has the same name as the specified module.  In the
case of a module alias, the created sub-directory may have a different
name, but you can be sure that it will be a sub-directory, and that
`checkout' will show the relative path leading to each file as it is
extracted into your private work area (unless you specify the `-Q'
global option).

   The files created by `checkout' are created read-write, unless the
`-r' option to CVS (*note Global options::) is specified, the `CVSREAD'
environment variable is specified (*note Environment variables::), or a
watch is in effect for that file (*note Watches::).

   Note that running `checkout' on a directory that was already built
by a prior `checkout' is also permitted.  This is similar to specifying
the `-d' option to the `update' command in the sense that new
directories that have been created in the repository will appear in
your work area.  However, `checkout' takes a module name whereas
`update' takes a directory name.  Also to use `checkout' this way it
must be run from the top level directory (where you originally ran
`checkout' from), so before you run `checkout' to update an existing
directory, don't forget to change your directory to the top level
directory.

   For the output produced by the `checkout' command see *Note update
output::.

* Menu:

* checkout options::            checkout options
* checkout examples::           checkout examples


File: cvs.info,  Node: checkout options,  Next: checkout examples,  Up: checkout

A.9.1 checkout options
----------------------

These standard options are supported by `checkout' (*note Common
options::, for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.  This option is
     sticky, and implies `-P'.  See *Note Sticky tags::, for more
     information on sticky tags/dates.

`-f'
     Only useful with the `-D' or `-r' flags.  If no matching revision
     is found, retrieve the most recent revision (instead of ignoring
     the file).

`-k KFLAG'
     Process keywords according to KFLAG.  See *Note Keyword
     substitution::.  This option is sticky; future updates of this
     file in this working directory will use the same KFLAG.  The
     `status' command can be viewed to see the sticky options.  See
     *Note Invoking CVS::, for more information on the `status' command.

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any checkout program (as specified with the `-o' option
     in the modules file; *note modules::).

`-P'
     Prune empty directories.  See *Note Moving directories::.

`-p'
     Pipe files to the standard output.

`-R'
     Checkout directories recursively.  This option is on by default.

`-r TAG[:DATE]'
     Checkout the revision specified by TAG or, when DATE is specified
     and TAG is a branch tag, the version from the branch TAG as it
     existed on DATE.  This option is sticky, and implies `-P'.  See
     *Note Sticky tags::, for more information on sticky tags/dates.
     Also, see *Note Common options::.

   In addition to those, you can use these special command options with
`checkout':

`-A'
     Reset any sticky tags, dates, or `-k' options.  See *Note Sticky
     tags::, for more information on sticky tags/dates.

`-c'
     Copy the module file, sorted, to the standard output, instead of
     creating or modifying any files or directories in your working
     directory.

`-d DIR'
     Create a directory called DIR for the working files, instead of
     using the module name.  In general, using this flag is equivalent
     to using `mkdir DIR; cd DIR' followed by the checkout command
     without the `-d' flag.

     There is an important exception, however.  It is very convenient
     when checking out a single item to have the output appear in a
     directory that doesn't contain empty intermediate directories.  In
     this case _only_, CVS tries to "shorten" pathnames to avoid those
     empty directories.

     For example, given a module `foo' that contains the file `bar.c',
     the command `cvs co -d dir foo' will create directory `dir' and
     place `bar.c' inside.  Similarly, given a module `bar' which has
     subdirectory `baz' wherein there is a file `quux.c', the command
     `cvs co -d dir bar/baz' will create directory `dir' and place
     `quux.c' inside.

     Using the `-N' flag will defeat this behavior.  Given the same
     module definitions above, `cvs co -N -d dir foo' will create
     directories `dir/foo' and place `bar.c' inside, while `cvs co -N -d
     dir bar/baz' will create directories `dir/bar/baz' and place
     `quux.c' inside.

`-j TAG'
     With two `-j' options, merge changes from the revision specified
     with the first `-j' option to the revision specified with the
     second `j' option, into the working directory.

     With one `-j' option, merge changes from the ancestor revision to
     the revision specified with the `-j' option, into the working
     directory.  The ancestor revision is the common ancestor of the
     revision which the working directory is based on, and the revision
     specified in the `-j' option.

     In addition, each -j option can contain an optional date
     specification which, when used with branches, can limit the chosen
     revision to one within a specific date.  An optional date is
     specified by adding a colon (:) to the tag:
     `-jSYMBOLIC_TAG:DATE_SPECIFIER'.

     *Note Branching and merging::.

`-N'
     Only useful together with `-d DIR'.  With this option, CVS will
     not "shorten" module paths in your working directory when you
     check out a single module.  See the `-d' flag for examples and a
     discussion.

`-s'
     Like `-c', but include the status of all modules, and sort it by
     the status string.  *Note modules::, for info about the `-s'
     option that is used inside the modules file to set the module
     status.


File: cvs.info,  Node: checkout examples,  Prev: checkout options,  Up: checkout

A.9.2 checkout examples
-----------------------

Get a copy of the module `tc':

     $ cvs checkout tc

   Get a copy of the module `tc' as it looked one day ago:

     $ cvs checkout -D yesterday tc


File: cvs.info,  Node: commit,  Next: diff,  Prev: checkout,  Up: CVS commands

A.10 commit--Check files into the repository
============================================

   * Synopsis: commit [-lnRf] [-m 'log_message' | -F file] [-r
     revision] [files...]

   * Requires: working directory, repository.

   * Changes: repository.

   * Synonym: ci

   Use `commit' when you want to incorporate changes from your working
source files into the source repository.

   If you don't specify particular files to commit, all of the files in
your working current directory are examined.  `commit' is careful to
change in the repository only those files that you have really changed.
By default (or if you explicitly specify the `-R' option), files in
subdirectories are also examined and committed if they have changed;
you can use the `-l' option to limit `commit' to the current directory
only.

   `commit' verifies that the selected files are up to date with the
current revisions in the source repository; it will notify you, and
exit without committing, if any of the specified files must be made
current first with `update' (*note update::).  `commit' does not call
the `update' command for you, but rather leaves that for you to do when
the time is right.

   When all is well, an editor is invoked to allow you to enter a log
message that will be written to one or more logging programs (*note
modules::, and *note loginfo::) and placed in the RCS file inside the
repository.  This log message can be retrieved with the `log' command;
see *Note log::.  You can specify the log message on the command line
with the `-m MESSAGE' option, and thus avoid the editor invocation, or
use the `-F FILE' option to specify that the argument file contains the
log message.

   At `commit', a unique commitid is placed in the RCS file inside the
repository. All files committed at once get the same commitid. The
commitid can be retrieved with the `log' and `status' command; see
*Note log::, *Note File status::.

* Menu:

* commit options::              commit options
* commit examples::             commit examples

